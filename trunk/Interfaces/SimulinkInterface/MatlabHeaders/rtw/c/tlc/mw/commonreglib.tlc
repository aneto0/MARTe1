%% Abstract:
%%      Library to support the various forms of model registration.

%% Copyright 1994-2012 The MathWorks, Inc.

%if EXISTS("_REGLIB_") == 0
%assign _REGLIB_ = 1

%% =============================================================================
%% Create global cache variable to hold S-function registration code
%% =============================================================================

%<LibAddToCompiledModel("SFunctionRegistration", 0)>


%% Function: FcnDynamicLog ================================================
%% Abstract:
%%   Are we logging in the face of code variants?
%%
%function FcnDynamicLog() void
  %return ::CompiledModel.HasCodeVariants
%endfunction
  
%% Function: FcnSuitableForMemset ==============================================
%%
%function FcnSuitableForMemset(valueToSet, dataTypeId, storageClass) void
  %%
  %if storageClass == "Custom"
    %%
    %% don't use memset for custom storage class
    %%
    %return 0
  %endif
  %%
  %if LibIsEnumDataType(dataTypeId)
    %%
    %% We don't want to use memset for enumerated data
    %%
    %return 0
  %endif
  %%
  %assign storageDataType = ...
    LibGetDataTypeStorageIdFromId(...
    LibGetDataTypeIdAliasedThruToFromId(dataTypeId))
  %%
  %switch storageDataType
    %%
    %case tSS_DOUBLE
    %case tSS_SINGLE
      %%
      %% For a given chip, the bit encoding of floating point numbers might or 
      %% might NOT represent 0.0 as the all zero bit pattern.  For this reason,
      %% memset is not trusted when dealing with floating point.
      %%
      %if InitFltsAndDblsToZero || ...
          !SLibValueIsAllZeroBitsCrudeCheck(dataTypeId, valueToSet)
        %%
        %return 0
        %%
      %else
        %%
        %return 1
        %%
      %endif
      %break
    %case tSS_UINT8
    %case tSS_UINT16
    %case tSS_UINT32
    %case tSS_INT8
    %case tSS_INT16
    %case tSS_INT32
    %case tSS_BOOLEAN
      %%
      %% Data type is OK for memset, provide
      %% value is suitable
      %%
      %break
    %default
      %%
      %% Data type not recognized
      %%   use memset only if the value is zero
      %%
      %if SLibValueIsAllZeroBitsCrudeCheck(dataTypeId, valueToSet)
        %return 1
      %else
        %return 0
      %endif
      %%break
  %endswitch
  %%
  %% Check suitability of value
  %%
  %% memset takes an int value, but writes out an unsigned char.
  %% there is a potential for lost information.   If the data
  %% type is bigger than a char, then memset actually writes
  %% the bit pattern multiple times into the wider memory
  %% slot.  For wider data, not many values will be comprised
  %% of the same char bit pattern repeated multiple times.
  %% The all zero bit pattern is an important value that
  %% does meet that criteria.  A key goal of this code
  %% is for the all zero case to be handled by memset.
  %%
  %% For most other values, memset will not be suitable. 
  %%
  %if SLibValueIsAllZeroBitsCrudeCheck(dataTypeId, valueToSet)
    %%
    %return 1
    %%
  %elseif ( TYPE(valueToSet) == "Number" ) || ( TYPE(valueToSet) == "Unsigned" )
    %%
    %switch storageDataType
        %%
      %case tSS_UINT8
      %case tSS_INT8
        %%
        %if IntegerSizes.CharNumBits < 8
          %%
          %% multiple chars make up data type
          %%
          %return 0
          %%
        %endif
        %break
        %%
      %case tSS_UINT16
      %case tSS_INT16
        %%
        %if IntegerSizes.CharNumBits < 16
          %%
          %% multiple chars make up 16 bit data type
          %%
          %return 0
          %%
        %endif
        %break
        %%
      %case tSS_UINT32
      %case tSS_INT32
        %%
        %if IntegerSizes.CharNumBits < 32
          %%
          %% multiple chars make up 32 bit data type
          %%
          %return 0
          %%
        %endif
        %break
        %%
      %case tSS_BOOLEAN
      %default
        %%
        %% don't try memset for boolean and non-zero value.
        %%
        %return 0
        %%break
        %%
    %endswitch
    %%
    %% memset takes an int value, but writes out an unsigned char.
    %% there is a potential for lost information.   Not clear what
    %% happens with negative values, so avoid that case.
    %%
    %if valueToSet >= 0
      %return 1
    %else
      %return 0
    %endif
  %endif
  %%
  %return 0
  %%
%endfunction

%% Function: FcnPreferMemsetToAssignment =======================================
%%
%function FcnPreferMemsetToAssignment(width, dataTypeId) void
  %%
  %if LibIsEnumDataType(dataTypeId)
    %%
    %% We don't want to use memset for enumerated data
    %%
    %return 0
  %elseif !ISEQUAL(width,1) 
    %%
    %% if not scalar, assume memset perferrable
    %%
    %return 1
  %else
    %%
    %assign storageDataType = ...
      LibGetDataTypeStorageIdFromId(...
      LibGetDataTypeIdAliasedThruToFromId(dataTypeId))
    %%
    %switch storageDataType
        %%
      %case tSS_DOUBLE
      %case tSS_SINGLE
      %case tSS_UINT8
      %case tSS_UINT16
      %case tSS_UINT32
      %case tSS_INT8
      %case tSS_INT16
      %case tSS_INT32
      %case tSS_BOOLEAN
        %%
        %% For known builtin data types, assume
        %% scalar assignment is preferrable to memset
        %%
        %return 0
        %%break
      %default
        %% 
        %% unrecognized data type, 
        %%   assume memset perferrable.
        %return 1
        %%break
    %endswitch
  %endif
%endfunction

%% Function: FcnMemsetToZeroInitSuffice ========================================
%%
%% When setting a chunk of memory of given data type ID to its 
%% default initial value, determine if a memset to 0 is sufficient.
%%
%function FcnMemsetToZeroInitSuffice(dataTypeId) void
  %%
  %assign retValue = 0
  %%
  %assign dataTypeThruId = LibGetDataTypeIdAliasedThruToFromId(dataTypeId)
  %%
  %if SLibDefaultInitialValueIsAllZeroBits(dataTypeThruId)
    %%
    %% hard code 0 as the init value below for speed
    %%
    %if FcnSuitableForMemset(0, dataTypeThruId, "")
      %%
      %assign retValue = 1
    %endif
  %endif
  %%
  %return retValue
%endfunction

%% Function: FcnCastValueForMemsetUse ==========================================
%%
%% The second input argument to memset is data type int.
%% Some compilers complain about trivial conversions like
%%     memset(ptr,  0.0,  40)
%% This function cleans up the second input argument in
%% a trivial way so the compiler doesn't complain.
%%     memset(ptr,    0,  40)
%% 
%%
%function FcnCastValueForMemsetUse(dTypeId, valueToSet) void
  %%
  %if SLibValueIsAllZeroBitsCrudeCheck(dTypeId, valueToSet)
    %assign retValue = 0
  %else
    %assign retValue = valueToSet
  %endif
  %%
  %return retValue
%endfunction

%% Function: FcnSkipDataInitialValueInReg ======================================
%%
%% When a signal or dwork record has non-empty InitialValue, determine
%% whether it needs to appear in RegFcn code (for example if the same
%% InitialValue already been assigned in custom storage class Static
%% init, it no longer needs to appear in RegFcn code)
%%
%function FcnSkipDataInitialValueInReg(datarec) void
  %assert !ISEMPTY(datarec.InitialValue)
  %assert (datarec.StorageClass != "ImportedExtern" && ...
       datarec.StorageClass != "ImportedExternPointer")
  %%
  %assign retValue = TLC_FALSE
  %%
  %if (datarec.StorageClass == "Custom")
    %assign cscDefn = SLibGetCSCDefForData(datarec)
    %assign dataInit = SLibGetDataInitForData(cscDefn, datarec)
    %if (dataInit == "Static" || dataInit == "None")
      %assign retValue = TLC_TRUE
    %endif
  %endif
  %%
  %return retValue
%endfunction

%% Function: SLibEmitForLoopCounterCode =======================================
%% Abstract:
%%   Helper function to emit iterator definition and for-loop stmt, where
%%   the iterator type, for the target, depends on the number of iterations
%function SLibEmitForLoopCounterCode(loopCount) Output
  %assign ctrType = SLibGetTypeForCounter(loopCount)
  %% put out the iterator definition
  %<ctrType[1]> i;
  %% then put out the for-loop stmt
  %% if the type is unsigned, put suffix after constants of for-range
  %if ctrType[1][0] == "u"
     for (i = 0U; i < %<loopCount>U; i++) {
  %else
     for (i = 0; i < %<loopCount>; i++) {
  %endif
%endfunction


%% Function: SLibEmitLibCustomInitCode =========================================
%% Abstract:
%%   Helper function to emit initialization code for Custom Data.  Take into
%%   account width (1 is a simple assignment), complexity (might require
%%   real and imaginary field assignments) and RollThreshold (can we use a
%%   for loop, or do we emit one initialization "foreach" element?
%%
%function SLibEmitLibCustomInitCode(name, initCount, isComplex) Output
  %if initCount == 1
    %% scalar case
    %if isComplex
      %<LibCustomData(name,"initialize","",tRealPart)>
      %<LibCustomData(name,"initialize","",tImagPart)>
    %else
      %<LibCustomData(name,"initialize","","")>
    %endif
  %elseif initCount >= RollThreshold
    %assign sigIndexer = SLibGet1DArrayIndexer(initCount, "i", "", 0)
    %% guard against empty for-loop if removing zero initialization
    %openfile customLoopBuffer
    %if isComplex
      %<LibCustomData(name,"initialize",sigIndexer,tRealPart)>
      %<LibCustomData(name,"initialize",sigIndexer,tImagPart)>
    %else
      %<LibCustomData(name,"initialize",sigIndexer,"")>
    %endif
    %closefile customLoopBuffer
    %if  !WHITE_SPACE(customLoopBuffer)
    {
      %<SLibEmitForLoopCounterCode(initCount)>
          %<customLoopBuffer>\
      }
    }
    %endif
  %else
    %foreach initIdx = initCount
      %assign sigIndexer = SLibGet1DArrayIndexer(initCount, "%<initIdx>", "", 0)
      %if isComplex
        %<LibCustomData(name,"initialize",sigIndexer,tRealPart)>
        %<LibCustomData(name,"initialize",sigIndexer,tImagPart)>
      %else
        %<LibCustomData(name,"initialize",sigIndexer,"")>
      %endif
    %endforeach
  %endif
%endfunction

%% Function: SLibRemoveZeroInitForData =========================================
%% Abstract:
%%   Return true if a given init value should not be emitted into code
%%   because that ZeroExternalMemoryAtStartup/ZeroInternalMemoryAtStartup
%%   option is false, and that the value is of zero-representation
%%
%% Note on how the two options are checked:
%%     "ExternalInput" : checks ZeroExternalMemoryAtStartup
%%     "ExternalOutput": checks ZeroExternalMemoryAtStartup
%%     "BlockOutput" with external storage class and drives root outport:
%%                       checks ZeroExternalMemoryAtStartup
%%      Any other      : checks ZeroInternalMemoryAtStartup
%%
%function SLibRemoveZeroInitForData(datarec, valueToInit) void

  %assign retVal = TLC_TRUE
  
  %if (datarec.RecordType == "ExternalInput")  || ...
      (datarec.RecordType == "ExternalOutput") || ...
      ( (datarec.RecordType == "BlockOutput") && ...
        (datarec.StorageClass != "Auto")      && ...
        (datarec.DrivesRootOutport == "yes") )
    %if ZeroExternalMemoryAtStartup
      %assign retVal = TLC_FALSE
    %endif
  %else
    %if ZeroInternalMemoryAtStartup
      %assign retVal = TLC_FALSE
    %endif
  %endif

  %if retVal
    %assign dTypeId = SLibGetRecordDataTypeId(datarec)
    %assign isZero = SLibValueIsAllZeroBitsCrudeCheck(dTypeId, valueToInit)
    
    %assign retVal = isZero
  %endif
  
  %if ::GenerateInitCodeRemoved
     %assign retVal = !retVal
  %endif
  
  %return retVal
%endfunction

%% Function: SLibRemoveZeroInitForDataDefault ==================================
%% Abstract:
%%   Similar to SLibRemoveZeroInitForData, but checks the default initial
%%   value.  Would not trigger the GroundUsed flag for struct data type.
%%
%function SLibRemoveZeroInitForDataDefault(datarec) void
  %assign retVal = TLC_TRUE
  
  %if (datarec.RecordType == "ExternalInput")  || ...
      (datarec.RecordType == "ExternalOutput") || ...
      ( (datarec.RecordType == "BlockOutput") && ...
        (datarec.StorageClass != "Auto")      && ...
        (datarec.DrivesRootOutport == "yes") )
    %if ZeroExternalMemoryAtStartup
      %assign retVal = TLC_FALSE
    %endif
  %else
    %if ZeroInternalMemoryAtStartup
      %assign retVal = TLC_FALSE
    %endif
  %endif

  %if retVal
    %if (datarec.RecordType=="ExternalOutput")
      %assign dTypeId = LibBlockInputSignalDataTypeId(0)
    %else
      %assign dTypeId = SLibGetRecordDataTypeId(datarec)
    %endif
    
    %assign retVal = SLibDataTypeRequiresZeroInit(dTypeId, TLC_FALSE)
  %endif
  
  %if ::GenerateInitCodeRemoved
    %assign retVal = !retVal
  %endif
  
  %return retVal
%endfunction

%% Function: SLibZeroMemory ====================================================
%% Abstract:
%%   Provide filtered access to ZeroInternalMemoryAtStartup and
%%   ZeroExternalMemoryAtStartup.  This allows us to recover
%%   memory zeroing routine in S-function wrapper when needed
%%
%function SLibZeroMemory(recordType) void
  %assign retVal = TLC_FALSE
  
  %if (recordType=="ExternalInput") || ...
    (recordType=="ExternalOutput")
    %if ZeroExternalMemoryAtStartup
      %assign retVal = TLC_TRUE
    %endif
  %else
    %if ZeroInternalMemoryAtStartup
      %assign retVal = TLC_TRUE
    %endif
  %endif

  %if ::GenerateInitCodeRemoved
    %assign retVal = !retVal
  %endif
  
  %return retVal
  
%endfunction

%% Function: LibDumpModelInitializeSizes =======================================
%% Abstract:
%%   Dumps the declaration statements required for MdlInitializeSizes.
%%   Supports these code formats
%%     o RealTime
%%     o RealTimeMalloc
%%
%function LibDumpModelInitializeSizes() Output
  %<RTMSet("NumContStates", NumContStates)>; /* Number of continuous states */
  %<RTMSet("NumY", NumModelOutputs)>;  /* Number of model outputs */
  %<RTMSet("NumU", NumModelInputs)>;    /* Number of model inputs */
  %if DirectFeedthrough == "yes"
    %<RTMSet("DirectFeedThrough", 1)>;  /* The model is direct feedthrough */
  %else
    %<RTMSet("DirectFeedThrough", 0)>;  /* The model is not direct feedthrough */
  %endif
  %<RTMSet("NumSampleTimes", NumSynchronousSampleTimes)>;   /* Number of sample times */
  %<RTMSet("NumBlocks", NumNonVirtBlocksInModel)>; /* Number of blocks */
  %if NumBlockSignals > 0
    %<RTMSet("NumBlockIO", BlockOutputs.NumGlobalBlockOutputs)>; ...
      /* Number of block outputs */
  %endif
  %if !LibParametersStructIsEmpty()
    %assign nPrms = ::CompiledModel.NumPrmStructElements
    %<RTMSet("NumBlockParams", nPrms)>;  /* Sum of parameter "widths" */
  %endif
%endfunction


%% Function: LibDumpModelInitializeSampleTimes =================================
%% Abstract:
%%   Dumps the code required to register the models sample times
%function LibDumpModelInitializeSampleTimes() Output
  %if CodeFormat == "S-Function" && AllSampleTimesInherited == "yes"
    %<RTMSetIdxed("SampleTime", 0, "INHERITED_SAMPLE_TIME")>;
    %<RTMSetIdxed("OffsetTime", 0, "0.0")>;
  %else
    /* task periods */
    %foreach tidIdx = NumSynchronousSampleTimes
      %assign period = SampleTime[tidIdx].PeriodAndOffset[0]
      %<RTMSetIdxed("SampleTime", tidIdx, period)>;
    %endforeach

    /* task offsets */
    %foreach tidIdx = NumSynchronousSampleTimes
      %assign offset = SampleTime[tidIdx].PeriodAndOffset[1]
      %<RTMSetIdxed("OffsetTime", tidIdx, offset)>;
    %endforeach
  %endif
%endfunction


%% Function SLibBooleanZCTest ==================================================
%% Abstract:
%%   Generates the appropriate zero-crossing test for boolean trigger signals.
%%
%function SLibBooleanZCTest(zcDir, trigSignal, prevZC,castRequired) void
  %assign cast = castRequired ? "(ZCEventType) " : ""
  %switch zcDir
    %case "RISING_ZERO_CROSSING"
      %return "%<cast>(%<trigSignal> && (%<prevZC> != POS_ZCSIG))"
    %case "FALLING_ZERO_CROSSING"
      %return "%<cast>(!%<trigSignal> && (%<prevZC> != ZERO_ZCSIG))"
    %case "ANY_ZERO_CROSSING"
      %return "%<cast>((%<trigSignal> != (%<prevZC> == POS_ZCSIG)) &&\n(%<prevZC> != UNINITIALIZED_ZCSIG))"
  %endswitch

%endfunction


%% Function SLibUnsignedZCTest =================================================
%% Abstract:
%%   Generates the appropriate zero-crossing test for unsigned trigger signals.
%%
%function SLibUnsignedZCTest(zcDir, trigSignal, prevZC, castRequired) void

  %assign cast = castRequired ? "(ZCEventType) " : ""
  %switch zcDir
    %case "RISING_ZERO_CROSSING"
      %return "%<cast>((%<trigSignal> > 0) && (%<prevZC> != POS_ZCSIG))"
    %case "FALLING_ZERO_CROSSING"
      %return "%<cast>((%<trigSignal> == 0) && (%<prevZC> != ZERO_ZCSIG ))"
    %case "ANY_ZERO_CROSSING"
      %return "%<cast>(((%<trigSignal> > 0) != (%<prevZC> == POS_ZCSIG)) &&\n(%<prevZC> != UNINITIALIZED_ZCSIG))"
  %endswitch

%endfunction


%% Function SLibGetZCEventInitValue ============================================
%% Abstract:
%%   When initializing PrevZCState, get the value we should intialize to based
%% on whether an unsiged signal is driving the zero-crossing.
%function SLibGetZCEventInitValue(zcs, idx) void
  %assign zcDir = LibConvertZCDirection(zcs.ZcEventType)
  %if zcs.UnsignedSigSrc
    %switch zcDir
      %case "RISING_ZERO_CROSSING"
        %assign value = "POS_ZCSIG"
        %break
      %case "FALLING_ZERO_CROSSING"
        %assign value = "ZERO_ZCSIG"
        %break
      %default
        %assign value = "UNINITIALIZED_ZCSIG"
        %break
    %endswitch
  %else
    %assign value = "UNINITIALIZED_ZCSIG"
  %endif

  %return value
%endfunction


%function SLibInitPrevZCSignalStateForBlk(blkZcRec, ppIf, ppFi) void
  %assign rootBuf = ""
  %assign numZcSignal = blkZcRec.NumZcSignalInfos
  %foreach zcsIdx = numZcSignal
    %assign zcs = blkZcRec.ZcSignalInfo[zcsIdx]       
    %%
    %% Check if the value will be the same for all elements
    %% in the vector.  Only then can we roll.  Currently
    %% there are no blocks that could cause canRoll to
    %% become false.  The block would have to have:
    %%  1. Multiple ZC Events.
    %%  2. Different directions for each event.
    %%  3. The event is driven by an Unsigned source.
    %%
    %% The Model block has 1 and 2, but not 3.  If we
    %% hit this assert, we need to change this logic to
    %% set canRoll to false.
    %%
    %if zcs.NeedsEvent == 1
      %assign   tmpBuf = ""
      %openfile tmpBuf
      %<ppIf>
      %assign canRoll = zcs.Width >= RollThreshold           
      %if canRoll
        %assign value = SLibGetZCEventInitValue(zcs, 0)
        %foreach trigIdx = zcs.Width - 1
          %assert value == SLibGetZCEventInitValue(zcs, trigIdx+1)
        %endforeach
      %endif
      %if canRoll && zcs.Width > 1
        {
          int_T idx;
          for (idx = 0; idx < %<zcs.Width>; idx ++) {
            %<SLibPrevZCSignalState(zcs,"","", zcsIdx, "idx")> = %<value>;
          }
        }
      %else                      
        %foreach trigIdx = zcs.Width    
          %assign value = SLibGetZCEventInitValue(zcs, trigIdx)
          %<SLibPrevZCSignalState(zcs,"","", zcsIdx, trigIdx)> = %<value>;
        %endforeach       
      %endif
      %<ppFi>
      %closefile tmpBuf
      
      %assign idx = SLibGetSystemAndCallSideIndex(blkZcRec)
      %if SigSrcLivesInStandaloneSS(idx)
        %assign ssIdx = StandaloneParentSysIdxOfSigSrc(idx)
        %<LibAddToSystemField(System[ssIdx], "CachedInitializeDataBody", tmpBuf)>
      %else
        %assign rootBuf = rootBuf + tmpBuf
      %endif
    %endif
  %endforeach
  %return rootBuf
%endfunction

%%adzc
%% Function SLibInitPrevZCSignalState ==========================================
%% Abstract:
%%   Initialize the previous zero-crossing state for a block.  Note that it
%%   is initialized to a value that guarantees that the trigger is never true
%%   at time zero.  Since the registration code sets previous zc's to
%%   UNINITIALIZED_ZCSIG, only overwrite when necessary (i.e., rising/falling
%%   triggers for unsigned and boolean data types).
%%
%function SLibInitPrevZCSignalStates() void
  %assign baseSystemIdx = GetBaseSystemIdx()
  %assign comma = ""
  %assign linefeed = ""
  %assign staticBuf = ""
  %assign rootBuf = ""
  
  %with System[baseSystemIdx] %% base system
    /* Zero-crossing state initialization */
    %assign numBlkZcRec = ZcRec.NumBlkZcRecs
    %foreach blkZcRecIdx = numBlkZcRec
      %assign blkZcRec = ZcRec.BlkZcRec[blkZcRecIdx]
      %if !blkZcRec.InitInStart
        %assign ppIf = ""
        %assign ppFi = ""
        %if SLibGraphicalBlockExist(blkZcRec)
          %assign ppStuff = SLibDataPreprocessorStuff(blkZcRec)
          %assign ppIf = ppStuff[0]
          %assign ppFi = ppStuff[1]
        %endif
        %assign sysIdx = -1
        %assign rootBuf = rootBuf + SLibInitPrevZCSignalStateForBlk(blkZcRec, ppIf, ppFi)
      %endif
    %endforeach
  %endwith %% root system
  %return rootBuf
%endfunction 
%%adzc

%% Function: LibDumpModelRegPrevZCStates ================================
%% Abstract:
%%   Dumps the code required to initialize the previous zero crossing events
%function SLibDumpModelRegPrevZCStates() Output
  /* previous zero-crossing states */
  {
    %if UsingMalloc
      ZCSigState *zc = (ZCSigState *) malloc(sizeof(%<tPrevZCStateType>));
      %<RTMChkMemAndReturnIfErr("zc")>;
    %else
      %assign addr = MultiInstanceERTCode ? "" : "&"
      ZCSigState *zc = (ZCSigState *) %<addr>%<LibGetPreviousZCStruct()>;
      %<SLibAccessArgHelper(rootSystem.Interface.ZCEventArgDef,"",rootSystem.CurrentTID)>
    %endif
    %<RTMSet("PrevZCSigState", "zc")>;
  }
%endfunction


%% Function: LibDumpModelInitPrevZCStates ================================
%% Abstract:
%%   Dumps the code required to initialize the previous zero crossing events
%function SLibDumpModelInitPrevZCStates() Output
  /* previous zero-crossing states */
  {
    %if UsingMalloc && ::CompiledModel.HasSimStructVars == 0 && !SLibIsERTCodeFormat()
      {
        
        %<tPrevZCStateType> *%<LibGetPreviousZCStruct()> = \
        (%<tPrevZCStateType> *) %<RTMGet("PrevZCSigState")>;
        %<SLibInitPrevZCStates()>\
        
      }
    %else      
      %<SLibInitPrevZCSignalStates()>\
    %endif
  }
%endfunction


%% Function: LibDumpModelInitializePrevZCStates ================================
%% Abstract:
%%   Dumps the code required to initialize the previous zero crossing events
%function LibDumpModelInitializePrevZCStates(bEmitReg, bEmitInit) Output
    %if bEmitReg
      %<SLibDumpModelRegPrevZCStates()>
    %endif    
    %if bEmitInit
      %<SLibDumpModelInitPrevZCStates()>
    %endif %% 
%endfunction


%% Function: FcnDisableStateLogging ============================================
%% Abstract:
%function FcnDisableStateLogging(dlo) void
  %assign dlo.StateSaveName = ""
  %assign dlo.FinalStateName = ""
  %return
%endfunction

%% Function: FcnIsStateLoggingEnabled ==========================================
%% Abstract:
%function FcnIsStateLoggingEnabled(dlo) void
  %return (dlo.StateSaveName != "" || dlo.FinalStateName != "")
%endfunction

%% Function: InitLogDataTypeConvertStructure
%% Abstract: 
%%   Initialize the RTWLogDataTypeConvert structure used by logging.
%%
%% Returns:
%% Struct with the following fields:
%%  0. needConvert
%%  1. dTypeEnum
%%  2. dTypeStorageEnum
%%  3. bitsPerChunk
%%  4. numOfChunk
%%  5. isSigned
%%  6. fSlope
%%  7. fixExp
%%  8. bias
%function InitLogDataTypeConvertStructure(dTypeId) void
  %if LibIsBuiltInDataType(dTypeId)
    %%
    %assign needConvert = 0
    %assign dTypeEnum = LibGetDataTypeEnumFromId(dTypeId)
    %assign dTypeStorageEnum = dTypeEnum
    %% These next three members are not used in this case
    %assign bitsPerChunk     = 0
    %assign numOfChunk       = 0
    %assign isSigned         = 0
    %assign fSlope = 1.0
    %assign fixExp = 0
    %assign bias   = 0.0
  %else
    %assign needConvert = 1
    %assign curDT = FixPt_GetDataTypeFromIndex(dTypeId)
    %assign dTypeEnum        = LibGetDataTypeEnumFromId(tSS_DOUBLE)
    %assign dTypeStorageEnum = LibGetDataTypeEnumFromId(curDT.StorageId)
    %if !FixPt_DataTypeIsFloat(curDT)
      %assign bitsPerChunk     = LargestIntegerNumBits
      %assign numOfChunk       = FixPt_NumChunks(curDT.RequiredBits)
      %assign isSigned         = curDT.IsSigned
    %else
      %% floating point and scaled doubles      
      %% These next three members are not used in this case
      %assign bitsPerChunk     = 0
      %assign numOfChunk       = 0
      %assign isSigned         = 0
    %endif
    %assign fSlope = curDT.FracSlope
    %assign fixExp = curDT.FixedExp
    %assign bias   = curDT.Bias
  %endif
  %assign retVectStr = ["%<needConvert>", "%<dTypeEnum>", "%<dTypeStorageEnum>", "%<bitsPerChunk>", "%<numOfChunk>", "%<isSigned>", "%<fSlope>", "%<fixExp>", "%<bias>" ]
  %return retVectStr
  %%
%endfunction %%InitLogDataTypeConvertStructure
  
%% Function: FcnLogStateSetup ==================================================
%% Abstract:
%%   Setup states for structure logging
%%
%function FcnLogStateSetup(bEmitReg, bEmitInit, dlo) Output
  %assign cr           = ""
  %assign qt           = "\""
  %assign comma        = ""
  %assign sigPtrsStr   = ""
  %assign widthStr     = ""
  %assign dimsStr      = ""
  %assign isVarDimsStr = ""
  %assign numDimsStr   = ""
  %assign dTypeStr     = ""
  %assign cmplxStr     = ""
  %assign labelStr     = ""
  %assign labelLenStr  = ""
  %assign blkNameStr   = ""
  %assign crossMdlStr  = ""
  %assign blkNameLenStr= ""
  %assign stateNameStr = ""
  %assign dataTypeConvertInitStr = ""

  %assign numLoggedStates = 0
  
  %assign cr = "\n"
  %assign nSig = "rt_LoggedStateSignalInfo.numSignals"
  %assign nSigpp = "rt_LoggedStateSignalInfo.numSignals++"
  
  %assign numLoggedRecords = 0
  %foreach i = ::CompiledModel.ContStates.NumContStates
    %assign cs         = ::CompiledModel.ContStates.ContState[i]
    %if cs.DataLoggingOn
      %assign numLoggedRecords = numLoggedRecords + cs.Partitions.NumPartitions
    %endif
  %endforeach
  %foreach i = ::CompiledModel.DWorks.NumDWorks
    %assign dwRec = ::CompiledModel.DWorks.DWork[i]
    %if (dwRec.UsedAs == "DSTATE" && dwRec.DataLoggingOn)
      %if SLibIsGlobalDataRecWithNoExternalLinkage(dwRec)
        %continue
      %endif
      %assign numLoggedRecords = numLoggedRecords + 1
    %endif
  %endforeach
  %assign loggedRecordIdx = 0
  %with ::CompiledModel.ContStates
    %assign dTypeId    = tSS_DOUBLE
    %assign cmpxSig    = 0
    %assign label      = "CSTATE"
    %%
    %assign dtConvertParams = InitLogDataTypeConvertStructure(dTypeId)
    %%
    %foreach i = NumContStates
      %if (loggedRecordIdx < (numLoggedRecords-1)) || FcnDynamicLog()
        %assign comma = ","
      %else
        %assign comma = ""
      %endif
      %assign cs         = ContState[i]
      %if !cs.DataLoggingOn
        %continue
      %endif
      %assign offset = 0
      %foreach recIdx    = cs.Partitions.NumPartitions
        %assign sigAddr    = "&" + SLibContinuousState(cs, "", "", offset,NumSystems-1, TLC_FALSE)
        %assign width      = cs.Partitions.Partition[recIdx].Width
        %assign stateName  = cs.Partitions.Partition[recIdx].Name
        %if cs.Partitions.Partition[recIdx].PathAlias == ""
          %assign blkName    = SLibGrBlockPath(cs.GrSrc)
        %else
          %assign blkName    = cs.Partitions.Partition[recIdx].PathAlias
        %endif
        %if UsingMalloc
          %assign lhs_eq     = "((void **) %<RTMLoggingGet("LogXSignalPtrs")>)[%<numLoggedStates>] = "
        %else
          %if FcnDynamicLog()
            %assign lhs_eq     = "rt_LoggedStateSignalPtrs[%<nSig>] = "
          %else
            %assign lhs_eq     = "rt_LoggedStateSignalPtrs[%<numLoggedStates>] = "
          %endif
        %endif 
        %%
	%assign sigPtrsStr   = sigPtrsStr + cr + lhs_eq + "(void*)" + sigAddr + ";\n"
        %if FcnDynamicLog()
          %assign sigPtrsStr   = sigPtrsStr + nSigpp + ";\n"
        %endif
        %assign sigPtrsStr   = sigPtrsStr + cr
        %assign widthStr     = widthStr      + cr + "%<width>%<comma>" + cr  + cr
        %assign numDimsStr   = numDimsStr    + cr + "1%<comma>" + cr  + cr
        %assign dimsStr      = dimsStr       + cr + "%<width>%<comma>" + cr  + cr
        %assign isVarDimsStr = isVarDimsStr  + cr + "0%<comma>" + cr  + cr
        %assign dTypeStr     = dTypeStr      + cr + "%<dtConvertParams[1]>%<comma>" + cr  + cr
        %assign cmplxStr     = cmplxStr      + cr + "%<cmpxSig>%<comma>" + cr  + cr
        %assign labelStr     = labelStr      + cr + qt + label + qt + "%<comma>" + cr  + cr
        %assign blkNameStr   = blkNameStr    + cr + qt + STRING(blkName) + qt + "%<comma>" + cr  + cr
        %assign stateNameStr = stateNameStr  + cr + qt + stateName + qt + "%<comma>" + cr  + cr
        %assign crossMdlStr  = crossMdlStr   + cr + "0%<comma>" + cr  + cr
        %assign dataTypeConvertInitStr = dataTypeConvertInitStr + cr + ...
          "{ %<dtConvertParams[0]>, %<dtConvertParams[1]>, %<dtConvertParams[2]>," + ...
          " %<dtConvertParams[3]>, %<dtConvertParams[4]>, %<dtConvertParams[5]>," + ...
          " %<dtConvertParams[6]>, %<dtConvertParams[7]>, %<dtConvertParams[8]>}%<comma>" + cr  + cr
        %%
        %assign numLoggedStates = numLoggedStates+1
        %assign loggedRecordIdx = loggedRecordIdx + 1
        %assign offset = offset + cs.Partitions.Partition[recIdx].Width
      %endforeach
    %endforeach
  %endwith

  %with ::CompiledModel.DWorks
    %foreach i = NumDWorks
      %if (DWork[i].UsedAs == "DSTATE" && DWork[i].DataLoggingOn)
        %if SLibIsGlobalDataRecWithNoExternalLinkage(DWork[i])
          %continue
        %endif
        %if (loggedRecordIdx < (numLoggedRecords-1)) || FcnDynamicLog()
          %assign comma = ","
        %else
          %assign comma = ""
        %endif
        %assign label = "DSTATE"
        %if DWork[i].Name != ""
          %assign label = DWork[i].Name
        %endif
	%assign ds  = DWork[i]
        %assign ppIf = ""
        %assign ppFi = ""
        %if FcnDynamicLog()
          %assign ppStuff = SLibDataPreprocessorStuff(ds)
          %assign ppIf = ppStuff[0]
          %assign ppFi = ppStuff[1]
        %endif
        %assign sigAddr   = SLibGetGlobalDWorkAddr(i,TLC_FALSE)	
	%assign width     = SLibDWorkWidth(ds)
        %assign stateName = ds.LogStateName
	%assign dTypeId   = LibGetDataTypeIdAliasedThruToFromId(...
	  LibGetRecordDataTypeId(ds))
	%assign cmpxSig   = SLibDWorkIsComplex(ds)
        %%
        %if (!LibIsDataTypeLogSupported(dTypeId, TLC_FALSE))
          %assign warnTxt = "MAT-File logging is not supported for " ...
            "states with data type '%<LibGetDataTypeNameFromId(dTypeId)>'."
          %<LibReportWarning(warnTxt)>
          %continue
        %endif
        %%
        %assign dtConvertParams = InitLogDataTypeConvertStructure(dTypeId)
        %%        
	%%% ============================================================
	%assign blkName = ...
          ISFIELD(ds, "GrSrc") ? SLibGrBlockPath(ds.GrSrc) : "synthesized block"
        %if UsingMalloc
            %assign lhs_eq     = "((void **) %<RTMLoggingGet("LogXSignalPtrs")>)[%<numLoggedStates>] = "
        %else
          %if FcnDynamicLog()
            %assign lhs_eq     = "rt_LoggedStateSignalPtrs[%<nSig>] = "
          %else
            %assign lhs_eq     = "rt_LoggedStateSignalPtrs[%<numLoggedStates>] = "
          %endif
        %endif 
	%%
	%assign sigPtrsStr   = sigPtrsStr + ppIf + cr + lhs_eq + "(void*)" + sigAddr + ";\n"
        %if FcnDynamicLog()
          %assign sigPtrsStr   = sigPtrsStr + nSigpp + ";\n"
        %endif
        %assign sigPtrsStr   = sigPtrsStr + ppFi + cr
	%assign widthStr     = widthStr      + ppIf + cr + "%<width>%<comma>" + cr + ppFi + cr
        %assign isVarDimsStr = isVarDimsStr  + ppIf + cr + "0%<comma>" + cr + ppFi + cr
	%assign numDimsStr   = numDimsStr    + ppIf + cr + "1%<comma>" + cr + ppFi + cr
	%assign dimsStr      = dimsStr       + ppIf + cr + "%<width>%<comma>" + cr + ppFi + cr
	%assign dTypeStr     = dTypeStr      + ppIf + cr + "%<dtConvertParams[1]>%<comma>" + cr + ppFi + cr
	%assign cmplxStr     = cmplxStr      + ppIf + cr + "%<cmpxSig>%<comma>" + cr + ppFi + cr
	%assign labelStr     = labelStr      + ppIf + cr + qt + label + qt + "%<comma>" + cr + ppFi + cr
	%assign blkNameStr   = blkNameStr    + ppIf + cr + qt + STRING(blkName) + qt + "%<comma>" + cr + ppFi + cr
	%assign stateNameStr = stateNameStr  + ppIf + cr + qt + STRING(stateName) + qt + "%<comma>" + cr + ppFi + cr
	%assign crossMdlStr  = crossMdlStr   + ppIf + cr + "0%<comma>" + cr + ppFi + cr
        %%
        %assign dataTypeConvertInitStr = dataTypeConvertInitStr + ppIf + cr + ...
          "{ %<dtConvertParams[0]>, %<dtConvertParams[1]>, %<dtConvertParams[2]>," + ...
          " %<dtConvertParams[3]>, %<dtConvertParams[4]>, %<dtConvertParams[5]>," + ...
        " %<dtConvertParams[6]>, %<dtConvertParams[7]>, %<dtConvertParams[8]>}%<comma>" + cr + ppFi + cr
        %%
        %assign numLoggedStates = numLoggedStates+1
        %assign loggedRecordIdx = loggedRecordIdx + 1
      %endif
    %endforeach
    %if FcnDynamicLog()
      %assign widthStr     = widthStr      +  "0" + cr
      %assign numDimsStr   = numDimsStr    +  "0" + cr
      %assign dimsStr      = dimsStr       +  "0" + cr
      %assign isVarDimsStr = isVarDimsStr  +  "0" + cr
      %assign dTypeStr     = dTypeStr      +  "SS_DOUBLE" + cr
      %assign cmplxStr     = cmplxStr      +  "0" + cr
      %assign labelStr     = labelStr      +  qt + qt + cr
      %assign blkNameStr   = blkNameStr    +  qt + qt + cr
      %assign stateNameStr = stateNameStr  +  qt + qt + cr
      %assign crossMdlStr  = crossMdlStr   +  "0" + cr
      %assign dataTypeConvertInitStr = dataTypeConvertInitStr +  ...
        "{ 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 0, 0, 0 }" + cr
    %endif
  %endwith
  %%
  %% Reset actual NumLoggedStates in logging record
  %%
  %assign dlo.NumLoggedStates = numLoggedStates
  %%
  %if (numLoggedStates == 0)
    %<FcnDisableStateLogging(dlo)>
    %return
  %endif
  {
  %if bEmitInit
  %assign typeQ = "static "
    %<typeQ> int_T rt_LoggedStateWidths[] =\
    {
      %<widthStr>
    };

    %<typeQ> int_T rt_LoggedStateNumDimensions[] =\
    {
      %<numDimsStr>
    };

    %<typeQ> int_T rt_LoggedStateDimensions[] =\
    {
      %<dimsStr>
    };
    
    %<typeQ> boolean_T rt_LoggedStateIsVarDims[] =\
    {
      %<isVarDimsStr>
    };
    
    %<typeQ> BuiltInDTypeId rt_LoggedStateDataTypeIds[] =\
    {
      %<dTypeStr>
    };

    %<typeQ> int_T rt_LoggedStateComplexSignals[] =\
    {
      %<cmplxStr>
    };

    %<typeQ> const char_T  *rt_LoggedStateLabels[] = {
    %<labelStr>};

    %<typeQ> const char_T *rt_LoggedStateBlockNames[] = {
    %<blkNameStr>};
      
    %<typeQ> const char_T *rt_LoggedStateNames[] = {
    %<stateNameStr>};

    %<typeQ> boolean_T rt_LoggedStateCrossMdlRef[] =\
    {
      %<crossMdlStr>
    };

    %<typeQ> RTWLogDataTypeConvert rt_RTWLogDataTypeConvert[] =\
    {
      %<dataTypeConvertInitStr>
    };

    %<typeQ> RTWLogSignalInfo rt_LoggedStateSignalInfo =\
    {
      %if FcnDynamicLog()
        0,
      %else
        %<numLoggedStates>,
      %endif
      rt_LoggedStateWidths,
      rt_LoggedStateNumDimensions,
      rt_LoggedStateDimensions,
      %% isVarDims field is useless for state logging
      %% So we set it to all 0's
      rt_LoggedStateIsVarDims, %% isVarDims
      %% currSigDims field is useless for state logging
      %% Just set it to NULL
      %<SLibGetNullDefinitionFromTfl()>, %% currSigDims
      %<SLibGetNullDefinitionFromTfl()>, %% currSigDimsSize
      rt_LoggedStateDataTypeIds,
      rt_LoggedStateComplexSignals,
      %<SLibGetNullDefinitionFromTfl()>,
      {rt_LoggedStateLabels},
      %<SLibGetNullDefinitionFromTfl()>,
      %<SLibGetNullDefinitionFromTfl()>,
      %<SLibGetNullDefinitionFromTfl()>,
      {rt_LoggedStateBlockNames},
      {rt_LoggedStateNames},
      rt_LoggedStateCrossMdlRef,
      rt_RTWLogDataTypeConvert
    };
  %endif %% bEmitInit
   
  %if bEmitReg
    %if UsingMalloc
      void **rt_LoggedStateSignalPtrs = ...
        (void **)malloc(sizeof(void *) * %<numLoggedStates>);
    %else
      static void * rt_LoggedStateSignalPtrs[%<numLoggedStates>];
    %endif
  %endif
  
  %if bEmitReg
    %if UsingMalloc
      %<RTMChkMemAndReturnIfErr("rt_LoggedStateSignalPtrs")>;
    %endif
    %<RTMLoggingSet("LogXSignalPtrs", ...
      "(LogSignalPtrsType) rt_LoggedStateSignalPtrs")>
  %endif %% bEmitReg
  
  %if bEmitInit
    %<RTMLoggingSet("LogXSignalInfo", "&rt_LoggedStateSignalInfo")>
    %<sigPtrsStr>\
  %endif
  }
%endfunction  %% FcnLogStateSetup


%% Function: FcnDisableOutputLogging ===========================================
%% Abstract:
%function FcnDisableOutputLogging(dlo) void
  %assign dlo.OutputSaveName = ""
  %return
%endfunction

%% Function: FcnIsOutputLoggingEnabled =========================================
%% Abstract:
%function FcnIsOutputLoggingEnabled(dlo) void
  %return (dlo.OutputSaveName != "")
%endfunction

%% Function: FcnLogOutputSetup =================================================
%% Abstract:
%%   Setup outputs for structure logging
%%
%function FcnLogOutputSetup(bEmitReg, bEmitInit, dlo) Output
  
  %%
  %assign typeQ        = "static "
  %assign nOutportBlks = ExternalOutputs.NumExternalOutputs
  %assign comma        = ""
  %assign sigPtrsStr   = ""
  %assign nOutputsLogged = 0
  %%
  %foreach idx = nOutportBlks
    %assign extOut = ExternalOutputs.ExternalOutput[idx]
    %assign sysIdx = extOut.Block[0]
    %assign blkIdx = extOut.Block[1]
    %assign outportBlock = System[sysIdx].Block[blkIdx]
    %%
    %with outportBlock
      %assign dTypeId = LibGetDataTypeIdAliasedThruToFromId(...
	LibBlockInputSignalDataTypeId(0))
      %if LibIsDataTypeLogSupported(dTypeId, TLC_FALSE)
	%assign sigLoc  = LibBlockDstSignalLocation("outportblk","","",0)
	%assign sigAddr = "&%<sigLoc>"
        %assign nOutputsLogged = nOutputsLogged+1
      %else
        %% Signal cannot be logged
        %% ==> Initialize data pointer to NULL so that the logging
        %%     infrastructure knows to skip this signal.
        %% ==> Lower down in this function we will skipp adding info
        %%     for this signal to the other logging structures.
	%assign sigAddr = SLibGetNullDefinitionFromTfl()
        %assign warnTxt = "Unable to log signal driving this block " ...
	  "because MAT-File logging is not supported for " ...
          "data type '%<LibGetDataTypeNameFromId(dTypeId)>'."
	%<LibBlockReportWarning(outportBlock, warnTxt)>
      %endif
    %endwith %% outportBlock
    %%
    %if UsingMalloc || MultiInstanceERTCode
      %if UsingMalloc
        %assign lhs_eq = "((void **) %<RTMLoggingGet("LogYSignalPtrs")>)[%<idx>] = "
      %else
        %assign lhs_eq = "rt_LoggedOutputSignalPtrs[%<idx>] = "
      %endif 
      %assign sigPtrsStr = sigPtrsStr + lhs_eq + sigAddr + ";\n"
    %else
      %assign sigPtrsStr = sigPtrsStr + comma + "\n" + sigAddr
    %endif
    %assign comma = ", "
  %endforeach
  
  %if (nOutputsLogged == 0)
    %<FcnDisableOutputLogging(dlo)>
    %return
  %endif

  {
    %if UsingMalloc
      %if bEmitReg
      void **rt_LoggedOutputSignalPtrs = (void **)malloc(%<nOutportBlks>*sizeof(void*));

      %<RTMChkMemAndReturnIfErr("rt_LoggedOutputSignalPtrs")>;
      %endif %% bEmitReg

      %if bEmitInit
      %<sigPtrsStr>\
      %endif %% bEmitInit
    %elseif MultiInstanceERTCode
      %if bEmitReg
      static void * rt_LoggedOutputSignalPtrs[%<nOutportBlks>];
      %endif %% bEmitReg

      %if bEmitInit
      %<sigPtrsStr>
      %endif %% bEmitInit
    %else
      %if bEmitReg && bEmitInit
      static void * rt_LoggedOutputSignalPtrs[] = \
      {\
	%<sigPtrsStr>
      };
      %else
        %% All legacy cases intertwine malloc and init
        %assert 0
      %endif %% bEmitReg && bEmitInit
    %endif

    %if bEmitReg
    %<RTMLoggingSet("LogYSignalPtrs", ...
      "((LogSignalPtrsType)rt_LoggedOutputSignalPtrs)")>
    %endif %% bEmitReg
  }
  %assign cr           = ""
  %assign qt           = "\""
  %assign comma        = ""
  %assign widthStr     = ""
  %assign numDimsStr   = ""
  %assign dimsStr      = ""
  %assign isVarDimsStr  = "" 
  %assign currSigDimsStr = ""
  %assign currSigDimsInitStr = ""
  %assign currSigDimsSetStr = ""
  %assign currSigDimsSizeStr = ""
  %assign dTypeStr     = ""
  %assign cmplxStr     = ""
  %assign labelStr     = ""
  %assign labelLenStr  = ""
  %assign blkNameStr   = ""
  %assign blkNameLenStr= ""
  %assign logSigInfoInitStr = ""
  %assign logSigInfoVarsStr = ""
  %%
  %assign dataTypeConvertInitStr = ""
  %%
  %assign widthVar = "rt_LoggedOutputWidths"
  %assign numDimsVar = "rt_LoggedOutputNumDimensions"
  %assign dimsVar = "rt_LoggedOutputDimensions"
  %assign isVarDimsVar = "rt_LoggedOutputIsVarDims"
  %assign currSigDimsVar = "rt_LoggedCurrentSignalDimensions" 
  %assign currSigDimsSizeVar = "rt_LoggedCurrentSignalDimensionsSize" 
  %assign dTypeVar = "rt_LoggedOutputDataTypeIds"
  %assign cmplxVar = "rt_LoggedOutputComplexSignals"
  %assign labelVar = "rt_LoggedOutputLabels"
  %assign labelLenVar = "rt_LoggedOutputLabelLengths"
  %assign blkNameVar = "rt_LoggedOutputBlockNames"
  %assign blkNameLenVar = "rt_LoggedOutputBlockNameLengths"
  %assign rt_RTWLogDataTypeConvertVar = "rt_RTWLogDataTypeConvert"
  %%
  %assign nSignalInfos = 0
{
  %assign numDimsRunningCount = 0
  %assign numOutportsLoggedIdx = 0
  %assign numCurrSigDims = 0
  %assign currSigDimsSize = ConfigSet.TargetBitPerInt/8
  %%
  %foreach idx = nOutportBlks
    %assign extOut = ExternalOutputs.ExternalOutput[idx]
    %assign sysIdx = extOut.Block[0]
    %assign blkIdx = extOut.Block[1]
    %assign outportBlock = System[sysIdx].Block[blkIdx]
    %%
    %with System[sysIdx]
      %with outportBlock
        %assign dTypeId = LibGetDataTypeIdAliasedThruToFromId(...
          LibBlockInputSignalDataTypeId(0))
        %%
        %if (!LibIsDataTypeLogSupported(dTypeId, TLC_FALSE))
	  %% Cannot log signals that don't have data type convert
     	  %% between functions
  	  %continue
        %endif
        %assign width     = LibBlockInputSignalWidth(0)
        %assign numDims   = LibBlockInputSignalNumDimensions(0)
        %assign dims      = LibBlockInputSignalDimensions(0)
        %assign isVarDims = ISFIELD(extOut, "HasVarDims")
        %assign cmpxSig   = LibBlockInputSignalIsComplex(0)
        %assign label     = extOut.SigLabel
        %assign blkName   = LibGetBlockPath(outportBlock)
        %%
        %assign dtConvertParams = InitLogDataTypeConvertStructure(dTypeId)        
        %%
      %endwith %% outportBlock        
    %endwith %% System[sysIdx]
    %%
    %% count the signals that are actually handled
    %%
    %assign nSignalInfos = nSignalInfos + 1
    %%
    %assign widthStr     = widthStr      + comma + cr + "%<width>"
    %assign numDimsStr   = numDimsStr    + comma + cr + "%<numDims>"
    %assign dimsStr      = dimsStr       + comma + cr
    %assign currSigDimsInitStr = currSigDimsInitStr + comma + cr
    %assign currSigDimsSizeStr  = currSigDimsSizeStr  + comma + cr
    
    %foreach dimsIdx = numDims
      %assign dimsStr = dimsStr + "%<dims[dimsIdx]>"
      %assign currSigDimsInitStr = currSigDimsInitStr + SLibGetNullDefinitionFromTfl()
      %if isVarDims
        %with System[sysIdx]
          %with outportBlock
            %assign currSigDims = SLibGetOutportSize(idx, numDims, "", -1, "", dimsIdx)
          %endwith %% outportBlock
        %endwith %% System[sysIdx]
        %assign currSigDimsStr = currSigDimsStr + "&%<currSigDims>" 
        %assign currSigDimsSizeStr = currSigDimsSizeStr + "%<currSigDimsSize>"
      %else
        %assign currSigDims = widthVar
        %assign currSigDimsStr = currSigDimsStr + ...
                                               "&%<currSigDims>[%<nSignalInfos-1>]"        
        %assign currSigDimsSizeStr = currSigDimsSizeStr + "%<currSigDimsSize>"
      %endif
      
      %if dimsIdx != numDims-1
        %assign dimsStr = dimsStr + ", "
        %assign currSigDimsInitStr = currSigDimsInitStr + ", "
        %assign currSigDimsSizeStr = currSigDimsSizeStr + ", "
      %endif
      
      %assign currSigDimsStr = "%<currSigDimsVar>[%<numCurrSigDims>] " + ...
                  "= %<currSigDimsStr>; \n"
      %assign currSigDimsSetStr = currSigDimsSetStr + currSigDimsStr
      %assign currSigDimsStr = ""
    
      %assign numCurrSigDims = numCurrSigDims + 1
    %endforeach
    
    %assign isVarDimsStr  = isVarDimsStr + comma + cr + "%<isVarDims>"
    %assign dTypeStr     = dTypeStr      + comma + cr + "%<dtConvertParams[1]>"
    %assign cmplxStr     = cmplxStr      + comma + cr + "%<cmpxSig>"
    %%
    %assign dataTypeConvertInitStr = dataTypeConvertInitStr + comma + cr + ...
      "{ %<dtConvertParams[0]>, %<dtConvertParams[1]>, %<dtConvertParams[2]>," + ...
      " %<dtConvertParams[3]>, %<dtConvertParams[4]>, %<dtConvertParams[5]>," + ...
      " %<dtConvertParams[6]>, %<dtConvertParams[7]>, %<dtConvertParams[8]>}"
    %%
    %assign labelStr     = labelStr   + comma + cr + qt + STRING(label) + qt
    %assign blkNameStr   = blkNameStr + comma + cr + qt + STRING(blkName) + qt
    %%
    %if dlo.NumOutputSaveNames != 1
      %if nSignalInfos == 1
        %assign pointerMathAddition     = ""
        %assign pointerMathAdditionDims = ""
      %else
        %assign pointerMathAddition     = "+%<numOutportsLoggedIdx>"
        %assign pointerMathAdditionDims = "+%<numDimsRunningCount>"
      %endif
      %assign numOutportsLoggedIdx = numOutportsLoggedIdx + 1
      %assign numDimsRunningCount = numDimsRunningCount + numDims
      %%
      %openfile tempBuffer
      %<typeQ> const char_T *%<labelVar>_%<idx>[] = {"%<STRING(label)>"};
      %<typeQ> const char_T *%<blkNameVar>_%<idx>[] = {"%<STRING(blkName)>"};
	
      %closefile tempBuffer 
      %assign logSigInfoVarsStr = logSigInfoVarsStr + tempBuffer
      
      %openfile tempBuffer
        %<comma>
        {
          1,
          %<widthVar>%<pointerMathAddition>,
          %<numDimsVar>%<pointerMathAddition>,
          %<dimsVar>%<pointerMathAdditionDims>,
          %<isVarDimsVar>%<pointerMathAddition>,
          %<currSigDimsVar>%<pointerMathAdditionDims>,
          %<currSigDimsSizeVar>%<pointerMathAdditionDims>,
          %<dTypeVar>%<pointerMathAddition>,
          %<cmplxVar>%<pointerMathAddition>,
          %<SLibGetNullDefinitionFromTfl()>,
	  {%<labelVar>_%<idx>},
          %<SLibGetNullDefinitionFromTfl()>,
          %<SLibGetNullDefinitionFromTfl()>,
          %<SLibGetNullDefinitionFromTfl()>,
	  {%<blkNameVar>_%<idx>},
          {%<SLibGetNullDefinitionFromTfl()>},
	  %<SLibGetNullDefinitionFromTfl()>,
          %<rt_RTWLogDataTypeConvertVar>%<pointerMathAddition>
        }\
      %closefile tempBuffer
      %%
      %assign logSigInfoInitStr = logSigInfoInitStr + tempBuffer
      %%
    %endif
    %%
    %assign comma = ","
    %assign cr = "\n"
    %%
  %endforeach
  %%
  %if bEmitInit
  %if nSignalInfos > 0

    %<typeQ> int_T %<widthVar>[] =\
    {
      %<widthStr>
    };

    %<typeQ> int_T %<numDimsVar>[] =\
    {
      %<numDimsStr>
    };

    %<typeQ> int_T %<dimsVar>[] =\
    {
      %<dimsStr>
    };

    %<typeQ> boolean_T %<isVarDimsVar>[] =\
    {
      %<isVarDimsStr>
    };
    
    %<typeQ> void* %<currSigDimsVar>[] =\
    {
      %<currSigDimsInitStr>
    };
   
    %<typeQ> int_T %<currSigDimsSizeVar>[] =\
    {
      %<currSigDimsSizeStr>
    };

    %<typeQ> BuiltInDTypeId %<dTypeVar>[] =\
    {
      %<dTypeStr>
    };

    %<typeQ> int_T %<cmplxVar>[] =\
    {
      %<cmplxStr>
    };

    %if dlo.NumOutputSaveNames == 1
      
      %<typeQ> const char_T *%<labelVar>[] = {
        %<labelStr>};
      
      %<typeQ> const char_T *%<blkNameVar>[] = {
        %<blkNameStr>};

    %else
	%<logSigInfoVarsStr>
    %endif

    %<typeQ> RTWLogDataTypeConvert %<rt_RTWLogDataTypeConvertVar>[] =\
    {
      %<dataTypeConvertInitStr>
    };

  %else
    %assign widthVar = SLibGetNullDefinitionFromTfl()
    %assign numDimsVar = SLibGetNullDefinitionFromTfl()
    %assign dimsVar = SLibGetNullDefinitionFromTfl()
    %assign isVarDimsVar = SLibGetNullDefinitionFromTfl()
    %assign currSigDimsVar = SLibGetNullDefinitionFromTfl()
    %assign dTypeVar = SLibGetNullDefinitionFromTfl()
    %assign cmplxVar = SLibGetNullDefinitionFromTfl()
    %assign labelVar = SLibGetNullDefinitionFromTfl()
    %assign labelLenVar = SLibGetNullDefinitionFromTfl()
    %assign blkNameVar = SLibGetNullDefinitionFromTfl()
    %assign blkNameLenVar = SLibGetNullDefinitionFromTfl()
    %assign rt_RTWLogDataTypeConvertVar = SLibGetNullDefinitionFromTfl()
  %endif

  %if dlo.NumOutputSaveNames == 1
    %assign numberOfSignalInfosInEachStruct = nSignalInfos
  %else
    %assign numberOfSignalInfosInEachStruct = 1
  %endif

  %<typeQ> RTWLogSignalInfo rt_LoggedOutputSignalInfo[] =\
  {
    %if dlo.NumOutputSaveNames == 1
      %% Single output name
      {
        %<nSignalInfos>,
	%<widthVar>,
	%<numDimsVar>,
	%<dimsVar>,
        %<isVarDimsVar>,
        %<currSigDimsVar>, 
        %<currSigDimsSizeVar>,
	%<dTypeVar>,
	%<cmplxVar>,
	%<SLibGetNullDefinitionFromTfl()>,
	{%<labelVar>},
	%<SLibGetNullDefinitionFromTfl()>,
	%<SLibGetNullDefinitionFromTfl()>,
	%<SLibGetNullDefinitionFromTfl()>,
	{%<blkNameVar>},
        {%<SLibGetNullDefinitionFromTfl()>},
	%<SLibGetNullDefinitionFromTfl()>,
        %<rt_RTWLogDataTypeConvertVar>
      }
    %else
      %% Multiple output names
      %<logSigInfoInitStr>
    %endif
  };
  %endif %% bEmitInit
  
  %if bEmitInit
  %<RTMLoggingSet("LogYSignalInfo", "rt_LoggedOutputSignalInfo")>
  /* set currSigDims field */
  %<currSigDimsSetStr>
  %endif %% bEmitInit
}

  

%endfunction  %% FcnLogOutputSetup


%% Function: SLibDumpModelRegDataLoggingSetup ==================================
%% Abstract:
%%	Writes the statements need to initialize for MAT file data logging.
%%      Note, we always do this even if MAT file data logging is turned
%%      off in the event that another form of data logging exists which
%%      needs to make use of this information.
%%
%function SLibDumpModelRegDataLoggingSetup(bEmitReg, bEmitInit) Output
  %assert(!IsModelReferenceTarget())
  
  %if bEmitReg
  /* Setup for data logging */
  {
    %if UsingMalloc
      RTWLogInfo *rt_DataLoggingInfo = ...
	(RTWLogInfo *) malloc(sizeof(RTWLogInfo));
      %<RTMChkMemAndReturnIfErr("rt_DataLoggingInfo")>;
    %else
      static RTWLogInfo rt_DataLoggingInfo;
    %endif

    %assign amps = UsingMalloc ? "" : "&"
    %<RTMLoggingSet("RTWLogInfo", "%<amps>rt_DataLoggingInfo")>
  }
  %endif %% bEmitReg


  /* Setup for data logging */
  {
    %assign dlo = ::CompiledModel.DataLoggingOpts

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Setup for Data being logged as "state". This includes continuous and %%
    %% discretes states which live in the dwork vector.                     %%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign needsMMI = 0
    %if FcnIsStateLoggingEnabled(dlo)
      /*
       * Set pointers to the data and signal info each state
       */
       %if ::CompiledModel.RTWStatesLogging == 0
        %<FcnLogStateSetup(bEmitReg, bEmitInit, dlo)>\
      %else
        %% If we're using the CAPI then everything is setup in the 
        %% startDataLogging call
	%% Need to set the pointer to the mmi in the RTWLogInfo
        %assign needsMMI = 1
      %endif
    %else
      %if bEmitReg
      %<RTMLoggingSet("LogXSignalInfo", SLibGetNullDefinitionFromTfl())>
      %<RTMLoggingSet("LogXSignalPtrs", SLibGetNullDefinitionFromTfl())>
      %endif %% bEmitReg
    %endif %% Logging state

    %if bEmitInit 
    %%
    %% Logging names and other attributes (format, max rows, etc.)
    %%
    %% *** NOTE ***
    %%  Names must be set AFTER setting up state logging because if none of
    %%  the states can be logged then the save names will be cleared
    %% ************
    %%
    %<RTMLoggingSet("LogT", "\"%<dlo.TimeSaveName>\"")>
    %<RTMLoggingSet("LogX", "\"%<dlo.StateSaveName>\"")>
    %<RTMLoggingSet("LogXFinal", "\"%<dlo.FinalStateName>\"")>
    %% add dlo.SigLogSaveName
    %<RTMLoggingSet("SigLog", "\"%<dlo.SignalLoggingName>\"")>
    %<RTMLoggingSet("LogVarNameModifier", "\"%<LogVarNameModifier>\"")>
    %<RTMLoggingSet("LogFormat", dlo.SaveFormat)>
    %<RTMLoggingSet("LogMaxRows", dlo.MaxRows)>
    %<RTMLoggingSet("LogDecimation", dlo.Decimation)>

    %% Set the pointer to the mmi in the RTWLogInfo
    %if needsMMI || MatFileSignalLogging
      	%if isRSim && !IsModelReferenceTarget()
	  %<RTMLoggingSet("MMI", "&(%<RSimRTWCAPIVarPtr>->mmi)")>  
	%else
	  %<RTMLoggingSet("MMI", "&(%<RTMGet("DataMapInfo")>.mmi)")>
	%endif
    %endif
    %endif %% bEmitInit
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Setup for logging outputs %%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%
    %% NOTE:
    %%   FcnLogOutputSetup will disable output logging if no outputs can be logged
    %%   so we need to call this before setting up the logging structures.
    %if FcnIsOutputLoggingEnabled(dlo)
      /*
       * Set pointers to the data and signal info for each output
       */ 
      %<FcnLogOutputSetup(bEmitReg, bEmitInit, dlo)>\
    %endif
      
    %% ANSI C compiler option restricts string length to 509 characters 
    %if bEmitInit
       %assign maxLength = 509 
       %if SIZE(dlo.OutputSaveName,1) <= maxLength 
         %<RTMLoggingSet("LogY", "\"%<dlo.OutputSaveName>\"")>
       %else 
         %assign len =  SIZE(dlo.OutputSaveName,1) 
         %assign times = len/maxLength + 1 
         { 
            static char_T temp_str [%<len+1>]; 
    
            %foreach idx = times 
              %assign str = "" 
              %foreach idx2 = maxLength 
                %assign lenSoFar = idx*maxLength + idx2 
                %if lenSoFar >= len 
                  %break 
                %endif 
                %assign str = str + dlo.OutputSaveName[lenSoFar] 
              %endforeach 
              (void) %<LibGenStringFcnCall2Args("strcpy",... 
              "&temp_str[%<idx*maxLength>]", "\"%<str>\"")>; 
            %endforeach 
            %<RTMLoggingSet("LogY", "temp_str")> 
          } 
       %endif 
    %endif %% bEmitInit

    %if (FcnIsOutputLoggingEnabled(dlo) == TLC_FALSE)
      %if bEmitReg
      %<RTMLoggingSet("LogYSignalInfo", SLibGetNullDefinitionFromTfl())>
      %<RTMLoggingSet("LogYSignalPtrs", SLibGetNullDefinitionFromTfl())>
      %endif %% bEmitReg
    %endif
  }

%endfunction %% SLibDumpModelRegDataLoggingSetup

%%Function:   SLibInitDataInitialValue ========================================
%%Abstract: 
%%  This function wraps assignment for multiword and signal word. In Multiword, 
%%  direct value assignment is not allowed. A temp var will be created to hold
%%  Multiword value and then assign temp var to the destination variable.
%%
%function SLibInitDataInitialValue(dTypeId, var, val) Output
  %if LibIsStructDataType(dTypeId) %% includes LibIsDataTypeMultiWordFixpt
    %assign dTypeName = LibGetDataTypeNameFromId(dTypeId)    
    %assign tmpVar = "temp"
    %if !LibIsDataTypeMultiWordFixpt(dTypeId)
      %% Multi-word types are already padded, we need padding only
      %% for struct/bus parameters
      %assign val = "{" + val + "}"
    %endif
    %%multiword and bus case
    {
      %<dTypeName> %<tmpVar> = %<val>;
      %<var> = %<tmpVar>;
    }
  %else
    %%single word case
    %<var> = %<val>;
  %endif
  %return
%endfunction %%LocalInitDataInitialValue

%% Function: FcnInitDataInitialValue ===========================================
%% Abstract:
%%   This function emits code to initialize data using InitialValue in datarec.
%%   It checks remove zero initialization option.  The datarec could be a block
%%   IO or DWork.  The InitialValue in datarec should already have proper data
%%   type, width and complexity that match the block IO or DWork.  There is no
%%   need for using memset on  which is only be considered for internal 
%%   structures with default zero initial values.
%%
%%   Note: argument dataId is ignored when datarec.StorageClass is "Custom"
%%
%function FcnInitDataInitialValue(datarec, dataId) Output
  %%
  %assign storageClass = datarec.StorageClass
  %assign dTypeId      = LibGetRecordDataTypeId(datarec)
  %assign width        = LibGetRecordWidth(datarec)
  %assign isComplex    = SLibGetRecordIsComplex(datarec)
  %assign initValue    = datarec.InitialValue
  %if ((ISEQUAL(storageClass, "ImportedExternPointer")) && ...
       (ISEQUAL(width, 1)))
    %assign optionalDeref = "*"
  %else
    %assign optionalDeref = ""
  %endif

  %% The storage class should be ImportedExtern or ImportedExternPointer
  %% only when the source block for the signal is a Model Reference block
  %assert( (! (ISEQUAL(storageClass, "ImportedExtern") ||...
               ISEQUAL(storageClass, "ImportedExternPointer"))) ||...
           ISEQUAL(System[datarec.SigSrc[0]].Block[datarec.SigSrc[2]].Type, "ModelReference"))
  
  %%
  %foreach wIdx = width
    %assign wIdxStr = SLibGet1DArrayIndexer(width, "", "", wIdx)
    %%
    %switch storageClass
      %case "Auto"
      %case "ExportedGlobal"
      %case "ImportedExtern"
      %case "ImportedExternPointer"
        %%
        %if isComplex
          %if LibIsNonBuiltInTypeNeededForFixpt(dTypeId)
            %assign initRe = FcnGetNonBuiltInRe(initValue[wIdx])
            %assign initIm = FcnGetNonBuiltInIm(initValue[wIdx])
          %else
            %assign initRe = REAL(initValue[wIdx])
            %assign initIm = IMAG(initValue[wIdx])
          %endif
          
          %assign rval = SLibGetFormattedValue(datarec, initRe)
          %if !SLibRemoveZeroInitForData(datarec, rval)
            %assign var = optionalDeref + STRING(dataId) + wIdxStr+ "." +tRealPart
            %<SLibInitDataInitialValue(dTypeId, var, rval)>\            
          %endif
          %assign ival = SLibGetFormattedValue(datarec, initIm)
          %if !SLibRemoveZeroInitForData(datarec, ival)
            %assign var = optionalDeref + STRING(dataId) + wIdxStr +"." + tImagPart
            %<SLibInitDataInitialValue(dTypeId, var, ival)>\
          %endif
        %else
          %assign val = SLibGetFormattedValue(datarec, initValue[wIdx])
          %if !SLibRemoveZeroInitForData(datarec, val)
            %assign var = optionalDeref + STRING(dataId) + wIdxStr
            %<SLibInitDataInitialValue(dTypeId, var, val)>\
          %endif
        %endif
        %break
        %%
      %case "Custom"
        %%
        %if isComplex
          %if LibIsNonBuiltInTypeNeededForFixpt(dTypeId)
            %assign initRe = FcnGetNonBuiltInRe(initValue[wIdx])
            %assign initIm = FcnGetNonBuiltInIm(initValue[wIdx])
          %else
            %assign initRe = REAL(initValue[wIdx])
            %assign initIm = IMAG(initValue[wIdx])
          %endif
          %assign rval = SLibGetFormattedValue(datarec, initRe)
          %assign ival = SLibGetFormattedValue(datarec, initIm)
        %else
          %assign val = SLibGetFormattedValue(datarec, initValue[wIdx])
        %endif
        %if (datarec.CustomStorageClassVersion > 1)
          %% GetSet
          %if isComplex
            %if !SLibRemoveZeroInitForData(datarec, rval)
              %<LibAccessCustomData(datarec,"set",wIdxStr,tRealPart,rval)>
            %endif
            %if !SLibRemoveZeroInitForData(datarec, ival)
              %<LibAccessCustomData(datarec,"set",wIdxStr,tImagPart,ival)>
            %endif
          %else
            %if !SLibRemoveZeroInitForData(datarec, val)
              %<LibAccessCustomData(datarec,"set",wIdxStr,"",val)>
            %endif
          %endif
          %%
        %else
          %% non-GetSet
          %if isComplex
            %if !SLibRemoveZeroInitForData(datarec, rval)
              %assign var = LibCustomData(datarec,"contents",wIdxStr,tRealPart)
              %<SLibInitDataInitialValue(dTypeId, var, rval)>\
            %endif
            %if !SLibRemoveZeroInitForData(datarec, ival)
              %assign var = LibCustomData(datarec,"contents",wIdxStr,tImagPart)
              %<SLibInitDataInitialValue(dTypeId, var, ival)>\
            %endif
          %else
            %if !SLibRemoveZeroInitForData(datarec, val)
              %assign var = LibCustomData(datarec,"contents",wIdxStr,"")
              %<SLibInitDataInitialValue(dTypeId, var, val)>\
            %endif
          %endif
        %endif
        %break
        %%
      %default
        %assert TLC_FALSE
    %endswitch
    %%
  %endforeach
%endfunction %% FcnInitDataInitialValue

%% Function: FcnIsImportedScopeCustomStorageCheck ==============================
%% Abstract:
%%   Returns true if a give data record is associated with an imported scoped
%%   custom storage class.
%%
%function FcnIsImportedScopeCustomStorageCheck(dataRec) void
  %if dataRec.StorageClass == "Custom"
    %assign dataScope = SLibGetDataScope(dataRec.CSCDefn, dataRec)
    %return dataScope == "Imported"
  %endif
  %return TLC_FALSE
%endfunction

%% Function: FcnIsFileScopeCustomStorageCheck ==================================
%% Abstract:
%%   Returns true if a give data record is associated with a file scoped custom
%%   storage class.
%%
%function FcnIsFileScopeCustomStorageCheck(dataRec) void
  %if dataRec.StorageClass == "Custom"
    %assign dataScope = SLibGetDataScope(dataRec.CSCDefn, dataRec)
    %return dataScope == "File"
  %endif
  %return TLC_FALSE
%endfunction

%% Function: FcnIsNotInterfaceableStorageClassCheck ============================
%% Abstract:
%%   The ERT S-function sets it block function type to "Initialize" when
%%   it is generating its zero intialization code. The ERT s-fuction initializes
%%   all internal memory to zero at startup to ensure a consistent simulation
%%   result. We report a warning if it attempts to inialize a file scoped 
%%   custom storage object.
%%
%function FcnIsNotInterfaceableStorageClassCheck(dataRec) void
  %assert ::BlockFcn == "Initialize" || ::BlockFcn == "Registration"  
  %if ::BlockFcn == "Initialize" && FcnIsFileScopeCustomStorageCheck(dataRec)
    %assert !ZeroInternalMemoryAtStartup    
    %assign errTxt = "The auto-generated SIL block will be unable to " ...
      "initialize '%<LibGetRecordIdentifier(dataRec)>' since its storage " ...
      "class prohibits an external interface. This can cause a " ...
      "simulation behaviour mismatch of the SIL block with its " ...
      "source model or subsystem. " ...
      "Please disable the 'Remove internal data zero initialization' " ...
      "option in the Optimization pane of the models Configuration " ...
      "Parameters dialog to addess this warning."
    %<LibReportWarning(errTxt)>
    %return TLC_TRUE
  %endif
  %return TLC_FALSE
%endfunction

%% Function: FcnGetNonRootFileFunctionOwner ====================================
%% Abstract:
%%   This function returns the none-inlined parent system index, if the
%%   data record owner generates generates code into a seperate file.
%%
%function FcnGetNonRootFileFunctionOwner(dataRec, sysIdxInitValue) void
  %assign sysIdx = sysIdxInitValue
  %assign csIdx = SLibGetSystemAndCallSideIndex(dataRec)
  %assign fcnSys = System[System[csIdx[0]].NonInlinedParentSystemIdx]
  %%
  %% RTWSystemsCode - 0 ... inlined system
  %%                  1 ... function (not reusable)
  %%                  2 ... reused function
  %%
  %if (fcnSys.RTWSystemCode == 1 || fcnSys.RTWSystemCode == 2) && ...
    !LibSystemIsRoot(System[fcnSys.FileNameOwnerIdx])
    %assert fcnSys.SystemIdx == System[csIdx[0]].NonInlinedParentSystemIdx
    %assign sysIdx = fcnSys.SystemIdx
  %endif
  %return sysIdx
%endfunction
  
%% Function FcnInitBlockIOWithExternalStorage ==================================
%% Abstract:
%%   Helper function for initializing block i/o
%%
%function FcnInitBlockIOWithExternalStorage(sc, comment, fieldsep, addressof, deref) void
  %%
  %openfile rtnBuffer 
  %foreach boIdx = BlockOutputs.NumExternalBlockOutputs
    %assign bo = BlockOutputs.ExternalBlockOutput[boIdx]
    %if FcnIsNotInterfaceableStorageClassCheck(bo)
      %continue
    %endif
    %if (SLibWriteOutInstForSignalRec(bo))
      %assign id = LibGetRecordIdentifier(bo)
      %with bo
        %%
        %% Standalone subsystems cache separately
        %assign stdSSIdx = -1
        %assign sysIdx = StandaloneParentSysIdxOfDataRec(bo)
        %if sysIdx == -1 && FcnIsFileScopeCustomStorageCheck(bo)
          %assign sysIdx = FcnGetNonRootFileFunctionOwner(bo, sysIdx)
        %endif
        %assign ppStuff = SLibDataPreprocessorStuff(bo)
        %assign ppIf = ppStuff[0]
        %assign ppFi = ppStuff[1]
        %if sysIdx != -1
          %assign stdSSIdx = sysIdx
          %assign stdSSBuffer = ""
        %endif
        %if StorageClass != sc
          %%
          %% Skip those records whose StorageClass not as specified in sc
          %%
          %continue
          %%
        %endif
        %assign initCount = LibGetRecordWidth(bo)

        %%
        %if ISEMPTY(InitialValue)
          %if (StorageClass == "Custom")

          %%
          %% do not initialize imported custom storage class signals
          %if FcnIsImportedScopeCustomStorageCheck(bo)
            %continue
          %endif

          %%
          %% If it's custom storage class without InitialValue,
          %% call "initialize" in its .tlc
          %%
          %% Note that custom storage class .tlc itself should check
          %% remove zero initialization option
          %%
          %openfile initCode
          %<SLibEmitLibCustomInitCode(bo, initCount, LibGetRecordIsComplex(bo))>
          %closefile initCode
          %if stdSSIdx != -1
            %% cache output to tmpBuffer, no %continue until %closefile
            %openfile tmpBuffer
          %endif
          %<ppIf>
          %<initCode>
          %<ppFi>
          %if stdSSIdx != -1
            %closefile tmpBuffer
            %assign stdSSBuffer = stdSSBuffer + tmpBuffer
          %endif
          %%
        %else %% StorageClass not "Custom"
          %%
          %% For any other external storage without InitialValue,
          %% use its ground value
          %%
          %if SLibRemoveZeroInitForDataDefault(bo)
            %continue
          %endif
          %if stdSSIdx != -1
            %% cache output to tmpBuffer, no %continue until %closefile
            %openfile tmpBuffer
          %endif
          %<ppIf>
          %%
          %% Warning: this will trigger the GroundUsed flag for struct data type
          %assign dataTypeId = LibGetDataTypeIdAliasedThruToFromId(LibGetRecordDataTypeId(bo))
          %if LibIsDataTypeMultiWordFixpt(dataTypeId)
            %assign defaultInitialValue = SLibGetDtGroundName(dataTypeId, ...
              LibGetRecordIsComplex(bo), tRealPart)
          %else
            %assign defaultInitialValue = SLibGetDefaultInitialValue(bo, tRealPart)
          %endif
          %%
	  %if initCount == 1
	    %% scalar case
	    %if LibGetRecordIsComplex(bo)
	      %<id>%<fieldsep>%<tRealPart> = %<defaultInitialValue>;
	      %<id>%<fieldsep>%<tImagPart> = %<defaultInitialValue>;
	    %else
	      %<deref>%<id> = %<defaultInitialValue>;
	    %endif
          %elseif initCount >= RollThreshold
	    %% vector case
	    {
	      %<SLibEmitForLoopCounterCode(initCount)>
		%if LibGetRecordIsComplex(bo)
		  %<id>[i]%<fieldsep>%<tRealPart> = %<defaultInitialValue>;
		  %<id>[i]%<fieldsep>%<tImagPart> = %<defaultInitialValue>;
		%else
		  %<deref>%<id>[i] = %<defaultInitialValue>;
		%endif
	      }
	    }
	  %else
            %foreach initIdx = initCount
              %if LibGetRecordIsComplex(bo)
		%<id>[%<initIdx>]%<fieldsep>%<tRealPart> = %<defaultInitialValue>;
		%<id>[%<initIdx>]%<fieldsep>%<tImagPart> = %<defaultInitialValue>;
              %else
		%<deref>%<id>[%<initIdx>] = %<defaultInitialValue>;
              %endif
            %endforeach
	  %endif
          %<ppFi>
          %if stdSSIdx != -1
            %closefile tmpBuffer
            %assign stdSSBuffer = stdSSBuffer + tmpBuffer
          %endif
	  %endif %% StorageClass == "Custom"
        %%
        %% If a non-empty initial value is provided for this signal then
        %% initialize it to that value. Initial values are provided for:
        %%
        %% - signals that have constant sample time but (for various reasons)
        %%   could not be declared invariant and placed in the ConstBlockIO
        %%   structure
        %%
        %% - or non-imported-storage-class signals that have signal object
        %%   InitialValue applied on them
        %%
        %else %% InitialValue not empty
          %if !FcnSkipDataInitialValueInReg(bo)
          %%
          %% For constant sample time signals, we always generate code for
          %% InitialValue regardless of remove zero initialization option.
          %% For non-constant sample time signals, we still check the option
          %%
          %if (Invariant != "yes")
            %if SLibRemoveZeroInitForData(bo, InitialValue)
              %if stdSSIdx != -1 && !WHITE_SPACE(stdSSBuffer)
                %<LibAddToSystemField(System[stdSSIdx],"TempInitBuffer",...
                  stdSSBuffer)>
              %endif
              %continue
            %endif
          %endif
          %%
          %% do not initialize imported custom storage class signals
          %if FcnIsImportedScopeCustomStorageCheck(bo)
            %continue
          %endif
          %%
          %if stdSSIdx != -1
            %% cache output to tmpBuffer, no %continue until %closefile
            %openfile tmpBuffer
          %endif
          %<ppIf>
          %<FcnInitDataInitialValue(bo, id)>
          %<ppFi>
          %if stdSSIdx != -1
            %closefile tmpBuffer
            %assign stdSSBuffer = stdSSBuffer + tmpBuffer
          %endif 
          %endif
        %endif
        %if stdSSIdx != -1 && !WHITE_SPACE(stdSSBuffer)
          %<LibAddToSystemField(System[stdSSIdx],"TempInitBuffer",...
            stdSSBuffer)>
        %endif
      %endwith
    %endif
  %endforeach
  %undef stdSSIdx
  %%
  %closefile rtnBuffer
  %% Cache standalone subsystem initialization
  %foreach sysIdx = NumSystems
    %assign sys = System[sysIdx]
    %if LibIsSystemField(sys, "TempInitBuffer")
      %assign stdSSBuffer = LibGetSystemField(sys, "TempInitBuffer")
      %if !ISEMPTY(stdSSBuffer)
        %<LibAddToSystemField(sys, "CachedInitializeDataBody", ...
          "\n" + comment + "\n" + stdSSBuffer + "\n")>
        %% Reset field for next call
        %<LibSetSystemField(sys, "TempInitBuffer", "")>
      %endif
    %endif
  %endforeach
  %% Cache root model initialization
  %if !WHITE_SPACE(rtnBuffer)
    %return "\n" + comment + "\n" + rtnBuffer
  %else
    %return ""
  %endif
%endfunction %% FcnInitBlockIOWithExternalStorage

%% Function: SLibInitBlockIOWithExternalStorage ================================
%% Abstract:
%%   Initialize the block i/o with external storage
%%
%function SLibInitBlockIOWithExternalStorage(usingStatic) Output
  %%
  %% Exported global signals
  %%
  %if !LibExportedGlobalSignalsInstanceIsEmpty()
    %<FcnInitBlockIOWithExternalStorage("ExportedGlobal", ...
      "/* exported global signals */", ".", "&", "")>
  %endif
  %%
  %% Custom signals
  %%
  %if CustomStorageClasses.NumCustomStorageClasses > 0
    %<FcnInitBlockIOWithExternalStorage("Custom", ...
      "/* custom signals */", ".", "&", "")>
  %endif
%endfunction %% SLibInitBlockIOWithExternalStorage

%% Function: SLibInitBlockIO ===================================================
%% Abstract:
%%   Initialize the block i/o structure (those with internal storage)
%%   In this function, we will cache the standalone subsystem blockIO
%%   initialization in CachedInitializeDataBody.
%%   
%%   If there is any standalone subsystem, we will go through BlockOutputs
%%   two times. In the first pass, we will cache standalone subsystem 
%%   initialization. In the second pass, we will dump initialization for the 
%%   rest of the signals.
%function SLibInitBlockIO(ptrBlockIOLabel) Output
  %assign startIdx = -1
  %assign stdSSIdx = -1
  %assign needMemsetToZero = 0
  %if  ::CompiledModel.HasStandaloneSubsystem
    %% Find the first signal that belongs to a standalone subsystem
    %foreach boIdx =  BlockOutputs.NumGlobalBlockOutputs
      %assign bo = BlockOutputs.GlobalBlockOutput[boIdx]
      %if ISEMPTY(bo.SigSrc)
        %continue
      %endif
      %assign standParent = StandaloneParentSysIdxOfDataRec(bo)
      %if standParent != -1
        %assign startIdx = boIdx
        %assign stdSSIdx = standParent
        %break
      %endif
    %endforeach

    %% If any signal belongs to a standalone subsystem, cache its initialization 
    %% in CachedInitializeDataBody.
    %if startIdx != -1
      %% We need to go through the BlockOutputs, and cache standalone subsystem 
      %% initialization. At most we may have NumSystems-1 subsystems.
      %% SLibInitBlockIOHelper will return two indices indicating
      %% - start index of blockIO in the next standalone 
      %% - next standalone subsystem index
      %foreach loopIdx =  NumSystems - 1
        %% A break will terminate the loop
        %openfile  ssInitBuf
        %assign retVal = SLibInitBlockIOHelper("",startIdx,stdSSIdx)
        %if retVal[2]
            %assign needMemsetToZero = 1
        %endif
        %closefile ssInitBuf
        
        %if !WHITE_SPACE(ssInitBuf)
          %<LibAddToSystemField(System[stdSSIdx],"CachedInitializeDataBody",ssInitBuf)>
        %endif
        %% -1 indicates, we are done and we reached to the end of blockIO
        %if retVal[0] == -1
          %break
        %else
          %% Initialize startIdx and stdSSIdx for the next iteration
          %assign stdSSIdx = retVal[0]
          %assign startIdx = retVal[1]
        %endif
      %endforeach
    %endif
  %endif
  
  %% If there is no root blockIO, then ptrBlockIOLabel will be empty
  %if !ISEMPTY(ptrBlockIOLabel)
    %assign retVal = SLibInitBlockIOHelper(ptrBlockIOLabel, 0, -1)
    %assign needMemsetToZero = retVal[2]
  %endif
  
  %return needMemsetToZero
%endfunction %%SLibInitBlockIO

%% Function: GetFinalPassAndNextTransitionIndex  ===============================
%% Abstract:
%%   This function is a helper function for SLibInitBlockIOHelper.
%%   It returns 4 integers:
%%    finalPass:  is this the last iteration
%%                (Either we reached to the end of the list, or detected a
%%                 new standalone subsystem. In this caseIf it detects a standalone
%%                 subsystem transition, it fills nextStdIdx and nextStartIdx)
%%
%%    skipRecord: skip this block output record or not
%% 
%%    nextStdIdx:   next standalone subsystem index. 
%%    nextStartIdx: next block Output index in the next standalone subsystem
%%                  
%% 
%function GetFinalPassAndNextTransitionIndex(boIdx, standaloneSSIdx)
  %% assume the following
  %assign nextStdIdx   = -1
  %assign nextStartIdx = -1
  %assign skipRecord   = TLC_FALSE
  %assign finalPass    = TLC_FALSE
  
  %assert(boIdx <= BlockOutputs.NumGlobalBlockOutputs)
  %if boIdx == BlockOutputs.NumGlobalBlockOutputs
    %assign finalPass = TLC_TRUE
  %else
    %assign bo = BlockOutputs.GlobalBlockOutput[boIdx]
    %if bo.RequiredInBlockIO[0] != 1 || bo.RequiredInBlockIO[1] != 0 || ...
      !ISFIELD(bo, "VarGroupIdx")
      %assign skipRecord = TLC_TRUE
    %elseif StandaloneParentSysIdxOfDataRec(bo) != standaloneSSIdx
      %% We detected a transition. 
      %if standaloneSSIdx == -1
        %% We need to dump
        %% initialization of all signals in non-standalone subsystems
        %% into model registration. Since these signals may not be contiguous, 
        %% we will skip standalone subsystems, and continue to find more
        %% to find all signals.
        %assign skipRecord = TLC_TRUE
      %else
        %% A new transition. Find the next standalone subsystem transition.
        %assign finalPass    = TLC_TRUE
        %assign nextStdIdx = StandaloneParentSysIdxOfDataRec(bo)
        %if nextStdIdx != -1
          %assign nextStartIdx = boIdx
        %else
          %assign nextStartIdx = -1
          %% This function should return the start of next transition.
          %% Find the start of next standalone subsystem section by 
          %% going through the rest of blockIO
          %assign numLeft = BlockOutputs.NumGlobalBlockOutputs - (boIdx+1)
          %foreach localIdx = numLeft
            %assign lIdx = (boIdx+1) + localIdx
            %assign lb = BlockOutputs.GlobalBlockOutput[lIdx]
            %if ISEMPTY(lb.SigSrc)
              %continue
            %endif
            %assign standParent = StandaloneParentSysIdxOfDataRec(lb)
            %if standParent != -1
              %% a new standalone subsystem
              %assign nextStdIdx   = standParent
              %assign nextStartIdx = lIdx
              %break
            %endif
          %endforeach
        %endif
      %endif
    %endif
  %endif  
  %%
  %return [%<finalPass>, %<skipRecord>, %<nextStdIdx>, %<nextStartIdx>]
%endfunction
  
%function SLibInitBlockIOForBufferHelper(bo, sysIdx, with_ppIf, maxctrtype, maxctrsize) void
  %assign ret = ["", "", "", 0, "", 0]
  %openfile csgInitBuffer  %% for invariant, or signal object InitialValue
  %openfile straightInitBuffer
  %openfile useLoopVarInitBuffer
  %assign memsetToZeroNeeded = 0
  %if !ISEMPTY(bo.InitialValue)
    %if !FcnSkipDataInitialValueInReg(bo)
      %%
      %% If a non-empty initial value is provided for this block output
      %% then initialize it to that value. Initial values are provided
      %% for:
      %%
      %% - block output signals that have constant sample time but (for
      %%   various reasons) could not be declared invariant and placed
      %%   in the ConstBlockIO structure
      %%
      %% - non-imported-storage-class signals that have signal object
      %%   InitialValue applied on them
      %%
      %% For constant sample time signals, we always generate code for
      %% InitialValue regardless of remove zero initialization option.
      %% For non-constant sample time signals, we still check the option
      %%
      %if bo.Invariant == "yes" || ...
        !SLibRemoveZeroInitForData(bo, bo.InitialValue)
        %assign id = SLibGetBlockOutputIdentifierFromRecord(bo,sysIdx)
        %selectfile csgInitBuffer
        %<FcnInitDataInitialValue(bo, id)>
      %endif
    %endif
  %else
    %if !SLibRemoveZeroInitForDataDefault(bo)
      %%
      %% InitialValue is empty.  Use default initial value then.
      %%
      %assign curDataTypeId = LibGetDataTypeIdAliasedThruToFromId(LibGetRecordDataTypeId(bo))
      %assign curMemsetToZeroSuffice = FcnMemsetToZeroInitSuffice(curDataTypeId)
      %%
      %if curMemsetToZeroSuffice
        %assign memsetToZeroNeeded = 1
      %else
        %assign nterms = LibGetRecordWidth(bo)
        %if LibGetRecordIsComplex(bo)
          %assign numElemInMemoryChunk  = 2*nterms
        %else
          %assign numElemInMemoryChunk = nterms
        %endif
        %%
        %% output code to initialize current chunk of memory
        %%
        %if  ( nterms > 0 )
          %assign ppIf = ""
          %assign ppFi = ""
          %if with_ppIf
            %assign ppStuff = SLibDataPreprocessorStuff(bo)
            %assign ppIf = ppStuff[0]
            %assign ppFi = ppStuff[1]
          %endif
          %%
          %%
          %assign DataTypeDefaultInitValue = SLibGetDefaultInitialValueFromId(curDataTypeId)
          %assign DataTypeName = SLibGetRecordContainerBaseTypeName(bo)
          %%
          %if FcnSuitableForMemset(DataTypeDefaultInitValue, curDataTypeId, "") && ...
            FcnPreferMemsetToAssignment(numElemInMemoryChunk, curDataTypeId)
            %%
            %% Be aware that the act of getting the address marks BlockIO as being accessed.
            %% Based on this mark, code generation will declare a BlockIO variable.
            %% We reach this code when initializing some non-zero fixed point fields as in
            %%    fixpoint/fixpt_rtw/trtw_vlogic2.m
            %%
            %assign StartAddr = SLibGetBlockOutputFromRecord(bo,sysIdx)
            %selectfile straightInitBuffer
            %assign sanitizedInitValue = ...
              FcnCastValueForMemsetUse(curDataTypeId, DataTypeDefaultInitValue)
            %<ppIf>
            (void) %<LibGenMemFcnCall("memset", StartAddr, sanitizedInitValue, ...
              "%<nterms>U*sizeof(%<DataTypeName>)")>;
            %<ppFi>
          %else
            %if LibIsDataTypeMultiWordFixpt(curDataTypeId)
              %assign initValue = SLibGetDtGroundName(curDataTypeId, ...
                LibGetRecordIsComplex(bo), tRealPart)
            %else
              %assign initValue = DataTypeDefaultInitValue
            %endif
            %assign id = SLibGetBlockOutputIdentifierFromRecord(bo, sysIdx)
            %if bo.DeclareAsPointer == "yes"
              %assign id = "(*%<id>)"
            %endif
            %if nterms > 1
              %%
              %if nterms >= RollThreshold
                %% use a loop
                %selectfile useLoopVarInitBuffer
                %assign ctrtype = SLibGetTypeForCounter(nterms)
                %% We have to maintain the maximum since we only put out one loop index var
                %if ctrtype[0] > maxctrsize
                  %assign maxctrtype = ctrtype[1]
                  %assign maxctrsize = ctrtype[0]
                %endif 
                %if maxctrtype[0] == "u"
                  %assign suffix = "U"
                %else
                  %assign suffix = ""
                %endif
                %<ppIf>
                for (i = 0%<suffix>; i < %<nterms>%<suffix>; i++) {
                  %if LibGetRecordIsComplex(bo)
                    %<id>[i].%<tRealPart> = %<initValue>;
                    %<id>[i].%<tImagPart> = %<initValue>;
                  %else
                    %<id>[i] = %<initValue>;
                  %endif
                }
                %<ppFi>
              %else
                %% do not use loop
                %selectfile straightInitBuffer
                %<ppIf>
                %foreach initIdx = nterms
                  %if LibGetRecordIsComplex(bo)
                    %<id>[%<initIdx>].%<tRealPart> = %<initValue>;
                    %<id>[%<initIdx>].%<tImagPart> = %<initValue>;
                  %else
                    %<id>[%<initIdx>] = %<initValue>;
                  %endif
                %endforeach
                %<ppFi>
              %endif
            %else
              %selectfile straightInitBuffer
              %<ppIf>
              %if LibGetRecordIsComplex(bo)
                %<id>.%<tRealPart> = %<initValue>;
                %<id>.%<tImagPart> = %<initValue>;
              %else
                %<id> = %<initValue>;
              %endif
              %<ppFi>
            %endif
          %endif
        %endif
      %endif
    %endif
  %endif
  %closefile csgInitBuffer
  %closefile straightInitBuffer
  %closefile useLoopVarInitBuffer
  %assign ret[0] = csgInitBuffer
  %assign ret[1] = straightInitBuffer
  %assign ret[2] = useLoopVarInitBuffer
  %assign ret[3] = memsetToZeroNeeded
  %assign ret[4] = maxctrtype
  %assign ret[5] = maxctrsize
  %return ret
%endfunction

%% Function: SLibInitBlockIOHelper =============================================
%% Abstract:
%%   This is a helper function for SLibInitBlockIO.
%function SLibInitBlockIOHelper(ptrBlockIOLabel, startIdx, standaloneSSIdx) Output
  %assign nextStartIdx = -2
  %assign nextStdIdx   = -2
  %assign memsetToZeroNeeded     = 0
  
  %% Choosing this option may result in code that is not MISRA-C compliant.
  %if ForceBlockIOInitOptimize
    %assign unusedVar = SLibInitBlockIOHelperOld(ptrBlockIOLabel, startIdx, standaloneSSIdx)
    %return [%<nextStdIdx>, %<nextStartIdx>, %<memsetToZeroNeeded>]
  %endif
  %assign blkioIsEmpty = ::CompiledModel.DWorkAndBlockIOCombined ? ...
    SLibModelDWorkStructIsEmpty() : SLibModelBlockIOStructIsEmpty()
    
  %if !blkioIsEmpty
    %%
    %assign csgInitBuffer = ""  %% for invariant, or signal object InitialValue
    %assign straightInitBuffer = ""
    %assign useLoopVarInitBuffer = ""
    %assign maxctrtype = "int_T"
    %assign maxctrsize = 0
    %%
    %assign baseSystemIdx = GetBaseSystemIdx()
    %assign numOutputsPlusOne = BlockOutputs.NumGlobalBlockOutputs + 1
    %%
    %foreach loopIdx = (numOutputsPlusOne - startIdx)
      %assign boIdx = loopIdx + startIdx
      %if boIdx != BlockOutputs.NumGlobalBlockOutputs && ...
        ISEMPTY(BlockOutputs.GlobalBlockOutput[boIdx].SigSrc)
         %continue
      %endif
      %% 
      %assign fInfo = GetFinalPassAndNextTransitionIndex(boIdx, standaloneSSIdx)
      %assign finalPass    = fInfo[0]
      %assign skipRecord   = fInfo[1]
      %assign nextStdIdx   = fInfo[2]
      %assign nextStartIdx = fInfo[3] 
      %%
      %if skipRecord
        %continue
      %endif
      %if finalPass
        %break
      %endif
      %%
      %%
      %assign bo = BlockOutputs.GlobalBlockOutput[boIdx]
      %%
      %assign ret = SLibInitBlockIOForBufferHelper(bo, baseSystemIdx, TLC_TRUE, maxctrtype, maxctrsize)
      %if !bo.InitInStart
        %% Take the init code only for buffers not initialized in start function
        %assign csgInitBuffer = csgInitBuffer + ret[0]
        %assign straightInitBuffer = straightInitBuffer + ret[1]
        %assign useLoopVarInitBuffer = useLoopVarInitBuffer + ret[2]
        %assign maxctrtype = ret[4]
        %assign maxctrsize = ret[5]
      %endif
      %if ret[3]
        %% If memset flag is set for any buffer, do memset
        %assign memsetToZeroNeeded = ret[3]
      %endif
    %%
    %endforeach  %% for each boIdx
    %%
    %if memsetToZeroNeeded && !::CompiledModel.DWorkAndBlockIOCombined
      %if standaloneSSIdx == -1
        %assign blockIOType = IsModelReferenceTarget() && !GenerateClassInterface ...
          ? ...
          FcnSysVarGroupType(System[NumSystems-2],"BlockIO") : tBlockIOType
        (void) %<LibGenMemFcnCall("memset", ptrBlockIOLabel, "0", ...
          "sizeof(%<blockIOType>)")>;
        %<SLibAccessArgHelper(System[baseSystemIdx].Interface.BlockIOArgDef,"","")>
      %else
        %assign type = FcnSysVarGroupType(System[standaloneSSIdx],"BlockIO")
        %assign var = "(void *) &" + ...
          FcnSysVarGroupNonreusedName(System[standaloneSSIdx],"BlockIO")
 
        (void) %<LibGenMemFcnCall("memset", var, "0", "sizeof(%<type>)")>;
      %endif
    %endif
    %%
    %if  !WHITE_SPACE(csgInitBuffer) ...
      || !WHITE_SPACE(straightInitBuffer) ...
      || !WHITE_SPACE(useLoopVarInitBuffer)
      %% SLibGetBlockOutputFromRecord above took care of LibAccessArg
      {
        %if  !WHITE_SPACE(useLoopVarInitBuffer)
          %<maxctrtype> i;
          %<useLoopVarInitBuffer>\
        %endif
        %<straightInitBuffer>\
        %<csgInitBuffer>\
      }
    %endif
  %endif
  %assign needMemsetForCombinedDWorkAndBlockIO = memsetToZeroNeeded ...
                                   && ::CompiledModel.DWorkAndBlockIOCombined
  %return [%<nextStdIdx>, %<nextStartIdx>, %<needMemsetForCombinedDWorkAndBlockIO>]
%endfunction %% SLibInitBlockIOHelper

%% Function: SLibInitExternalInputs ============================================
%% Abstract:
%%   Initialize the external inputs structure and with external storage
%%
%function SLibInitExternalInputs(usingStatic, localIn, fromSFcn) Output
  %if ((NumModelInputs > 0) && ...
       (!IsModelReferenceTarget()) && ...
       !SLibAutosarActive())
    %openfile NonMemsetBuffer
    %assign memsetToZeroNeeded = 0
      %% We never call memset unless it is a RootIO structure with more than
      %% one field or it's an input argument that points to a whole structure
    %assign memsetMightBeNeeded = (!localIn && ExternalInputs.NumExternalInputs > 1) ...
              && (!MultiInstanceERTCode || RootIOStructures)
    %foreach idx = ExternalInputs.NumExternalInputs
      %assign extInp  = ExternalInputs.ExternalInput[idx]
      %assign dataTypeEnum = LibGetDataTypeEnumFromId(SLibGetRecordDataTypeId(extInp))
      %if dataTypeEnum == "SS_FCN_CALL" || ...
        (SLibFcnProtoCtrlActive() && extInp.RequiresGlobalAccess == "no" && !localIn)
        %continue
      %endif
      %%
      %% do not initialize imported custom storage class signals
      %if FcnIsImportedScopeCustomStorageCheck(extInp)
        %continue
      %endif
      %%
      %% Streamline code based on storage class
      %if extInp.StorageClass == "ImportedExtern" || ...
	  extInp.StorageClass == "ImportedExternPointer"
	%continue
      %%
      %elseif extInp.StorageClass == "Auto" || ...
	      extInp.StorageClass == "ExportedGlobal"
	%assign AutoOrExportedGlobal = TLC_TRUE
      %%
      %else
        %% Must be "Custom"
	%assign AutoOrExportedGlobal = TLC_FALSE
      %endif
      %%
      %assign dTypeId = LibGetDataTypeIdAliasedThruToFromId(...
	                SLibGetRecordDataTypeId(extInp))
      %assign width   = LibGetRecordWidth(extInp)
      %%
      %if localIn
        %assign varName = "localIn%<idx>"
      %elseif extInp.StorageClass == "Auto"
        %assign varName = "%<LibGetExternalInputStruct()>%<UQualifier>%<LibGetRecordIdentifier(extInp)>"
        %if PassExtInpByRef(extInp)
          %assign varName = "(*%<varName>)"
        %endif
      %elseif extInp.StorageClass == "ExportedGlobal"
        %assign varName = LibGetRecordIdentifier(extInp)
      %else
        %assign varName = ""  %% will be ignored by "Custom" anyway
      %endif
      %%
      %if !ISEMPTY(extInp.InitialValue)
        %if !FcnSkipDataInitialValueInReg(extInp)
          %%
          %% InitialValue are provided for non-imported-storage-class
          %% signals that have signal object InitialValue applied on them
          %%
          %assign initValue = extInp.InitialValue
          %if SLibRemoveZeroInitForData(extInp, initValue)
            %continue
          %endif
          %%
          %if extInp.StorageClass == "Auto"
            %% Make sure the extInp is marked as accessed
            %<SLibAccessArgHelper(extInp,"","")>
          %endif
          %%
          %<FcnInitDataInitialValue(extInp, varName)>
        %endif
      %else
        %% InitialValue not provided.  Use default initial value then.
        %%
        %if AutoOrExportedGlobal
          %%
          %% Always assign initial value for SFcn wrapper for local vars
          %% since even if we can optimize away zeros on the target, we may
          %% not be able to on the host
          %if !localIn && SLibRemoveZeroInitForDataDefault(extInp) && ...
              !(fromSFcn && SLibCPPClassNeedERTSfcnZeroIOMemory())
            %continue
          %endif
          %if extInp.IsEliminated == "true"
            %continue
          %endif
          %%
          %% Warning: this will trigger the GroundUsed flag for struct data type
          %if LibIsDataTypeMultiWordFixpt(dTypeId)
            %assign initValue = SLibGetDtGroundName(dTypeId, ...
              LibGetRecordIsComplex(extInp), tRealPart)
          %else
            %assign initValue = SLibGetDefaultInitialValue(extInp,tRealPart)
          %endif
          %%
          %if extInp.StorageClass == "Auto"
            %% Make sure the extInp is marked as accessed
            %<SLibAccessArgHelper(extInp,"","")>
            %%
            %% The memsetToZero optimization cannot be used for ExportedGlobals
            %% so we only check Inputs that are StorageClass Auto
            %if memsetMightBeNeeded
              %if FcnMemsetToZeroInitSuffice(dTypeId)
                %assign memsetToZeroNeeded = 1
                %continue
              %endif
            %endif
          %endif

          %if width == 1
            %if LibGetRecordIsComplex(extInp)
              %<varName>.%<tRealPart> = %<initValue>;
              %<varName>.%<tImagPart> = %<initValue>;
            %else
              %<varName> = %<initValue>;
            %endif
          %else
            %% Because SLibValueIsAllZeroBitsCrudeCheck interogates a string for '0', 
            %% or '0.0', it is OK to memset multiword as long as initValue is 0. 
            %% To be conservative, since multiword's ground value is '{0}' at its 
            %% closest, not '0', it is actually never memset. 
            %assign memsetSuitable = ...
              FcnSuitableForMemset(initValue, dTypeId, extInp.StorageClass)
            %%
            %if !memsetSuitable
              %%
              %if width >= RollThreshold
                {
                  %<SLibEmitForLoopCounterCode(width)>
                    %if LibGetRecordIsComplex(extInp)
                      %<varName>[i].%<tRealPart> = %<initValue>;
                      %<varName>[i].%<tImagPart> = %<initValue>;
                    %else
                      %<varName>[i] = %<initValue>;
                    %endif
                  }
                }
              %else
                %foreach initIdx = width
                %if LibGetRecordIsComplex(extInp)
                    %<varName>[%<initIdx>].%<tRealPart> = %<initValue>;
                    %<varName>[%<initIdx>].%<tImagPart> = %<initValue>;
                %else
                    %<varName>[%<initIdx>] = %<initValue>;
                %endif
                %endforeach
              %endif
            %else
              %assign dTypeName = SLibGetRecordContainerBaseTypeName(extInp)
              %if LibGetRecordIsComplex(extInp)
                %assign width = 2*width
              %endif
              %assign sanitizedInitValue = ...
                FcnCastValueForMemsetUse(dTypeId, initValue)
              (void) %<LibGenMemFcnCall("memset", varName, sanitizedInitValue, ...
                "%<width>U*sizeof(%<dTypeName>)")>;
            %endif
          %endif
          %%
        %else
          %% Not AutoOrExportedGlobal, must be "Custom"
          %%
          %<SLibEmitLibCustomInitCode(extInp, width, LibGetRecordIsComplex(extInp))>
        %endif  %% AutoOrExportedGlobal or Custom, default initial value
        %%
        %if extInp.Padding > 0
          %if extInp.Padding > 1
            %assign addrOf = ""
          %else
            %assign addrOf = "&"
          %endif
          (void) %<LibGenMemFcnCall("memset", ...
            "%<addrOf>%<LibGetExternalInputStruct()>%<UQualifier>pad_%<LibGetRecordIdentifier(extInp)>", ...
            "'a'", "%<extInp.Padding>U*sizeof(char)")>;
        %endif
      %endif  %% InitialValue
    %endforeach
    %closefile NonMemsetBuffer

    %if memsetToZeroNeeded
      %assign initAddr = (UQualifier == "." ? "&" : "") + ...
        LibGetExternalInputStruct()
      (void) %<LibGenMemFcnCall("memset", "(void *)" + initAddr, ...
                                " 0", " sizeof(%<tInputType>)")>;
    %endif
    %%
    %if  !WHITE_SPACE(NonMemsetBuffer)
      %<NonMemsetBuffer>
    %endif

  %endif
%endfunction  %% SLibInitExternalInputs

%function SLibInitExternalInputSizes() Output
  %with ::CompiledModel.System[NumSystems-1]
  %if ((::CompiledModel.NumModelInputs > 0) && ...
    (!IsModelReferenceTarget()) && ...
    !SLibAutosarActive())
    %% initialize root inport sizes for auto and exported global.
    %foreach idx  = ::CompiledModel.ExternalInputs.NumExternalInputs
      %assign extInp  = ::CompiledModel.ExternalInputs.ExternalInput[idx]
      %if ISFIELD(extInp, "HasVarDims")
        %if ISFIELD(extInp, "SizeVarGroupIdx")
          %assert extInp.StorageClass == "Auto"
          %assign sizeTypeIdx = SLibCGVarGroupMemberCGTypeIdx(...
            extInp.SizeVarGroupIdx[0], ...
            extInp.SizeVarGroupIdx[1])
          %assign sizeVecLen = LibCGTypeWidth(sizeTypeIdx)
          %foreach dimIdx = sizeVecLen
            %<SLibGetInportSize(idx, sizeVecLen, "", -1, "", dimIdx)> = ...
              %<SLibGetDefaultInitialValue(...
              SLibVarGroupMember(extInp.SizeVarGroupIdx[0], ...
              extInp.SizeVarGroupIdx[1]), tRealPart)>;
          %endforeach
        %elseif ISFIELD(extInp, "DimSizeDWork")
          %assert extInp.StorageClass == "ExportedGlobal"
          %assign dworkRec = ::CompiledModel.DWorks.DWork[extInp.DimSizeDWork]
          %assign sizeVecLen = LibCGTypeWidth(LibGetRecordCGTypeIdx(dworkRec))
          %foreach dimIdx = sizeVecLen
            %<SLibCG_V(LibGetRecordIdentifier(dworkRec), TLC_FALSE, sizeVecLen, ...
              "", -1, "", dimIdx)> = ...
              %<SLibGetDefaultInitialValue(dworkRec, ...
              tRealPart)>;
          %endforeach
        %endif
      %endif
    %endforeach
  %endif
  %endwith
%endfunction  %% SLibInitExternalInputSizes

%% Function: SLibInitExternalOutputs ===========================================
%% Abstract:
%%   Initialize the external outputs structure (ie. with internal storage, not
%%   including external outputs with external storage, which should be covered
%%   by Block IO)
%%
%function SLibInitExternalOutputs(usingStatic,localOut, fromSFcn) Output
  %with ::CompiledModel.System[NumSystems-1]
  %if ::CompiledModel.NumModelOutputs > 0 && ...
    !SLibAutosarActive()
    %openfile NonMemsetBuffer
    %assign memsetToZeroNeeded = 0
    %assign memsetMightBeNeeded = (!localOut && ExternalOutputs.NumExternalOutputs > 1) ...
            && (!MultiInstanceERTCode || RootIOStructures)
    %foreach idx = ::CompiledModel.ExternalOutputs.NumExternalOutputs
      %assign extOut       = ::CompiledModel.ExternalOutputs.ExternalOutput[idx]
      %assign sysIdx       = extOut.Block[0]
      %assign blkIdx       = extOut.Block[1]
      %assign outportBlock = System[sysIdx].Block[blkIdx]
      %with outportBlock
      %% This would skip any ExternalOutput of external storage (which is
      %% covered by SLibInitBlockIOWithExternalStorage)
      %if !SLibExternalOutputIsVirtual(outportBlock) && ...
        (!SLibFcnProtoCtrlActive() || extOut.RequiresGlobalAccess == "yes" || localOut)
	%assign rPart   = "%<tRealPart>0"
	%assign iPart   = "%<tImagPart>0"
	%assign width   = LibGetRecordWidth(extOut)
	%assign dTypeId = ...
          LibGetDataTypeIdAliasedThruToFromId(LibGetRecordDataTypeId(extOut))
        %assign uIsComplex = LibGetRecordIsComplex(extOut)
        %%
        %% Always assign initial value for SFcn wrapper for local vars
        %% since even if we can optimize away zeros on the target, we may
        %% not be able to on the host
        %if !localOut && SLibRemoveZeroInitForDataDefault(extOut) && ...
            !(fromSFcn && SLibCPPClassNeedERTSfcnZeroIOMemory())
          %continue
        %endif
        %%
        %% Make sure the extInp is marked as accessed
        %<SLibAccessArgHelper(extOut,"","")>
        %%
        %if LibIsDataTypeMultiWordFixpt(dTypeId)
          %assign defaultInitialValue = SLibGetDtGroundName(dTypeId, ...
            LibGetRecordIsComplex(DataInputPort), tRealPart)
        %else
          %assign defaultInitialValue = SLibGetDefaultInitialValue(DataInputPort, tRealPart)          
        %endif
        %% If the memset optimization is possible, check this Output
        %if memsetMightBeNeeded
          %if FcnMemsetToZeroInitSuffice(dTypeId)
            %assign memsetToZeroNeeded = 1
            %% We know we can ignore this one.  Memset has taken care of it.
            %continue
          %endif
        %endif

        %%
	%if width == 1
          %% LibBlockDstSiganlLocation would take care of LibAccessArg
          %if localOut
            %assign lhs = "localOut%<idx>"
            %if uIsComplex 
              %assign lhs = lhs + "." + tRealPart
            %endif
            %<lhs> = %<defaultInitialValue>;
            %if uIsComplex
              %assign lhs = "localOut%<idx>" + "." + tImagPart
              %<lhs> = %<defaultInitialValue>;
            %endif
          %else
            %<LibBlockDstSignalLocation("outportblk","","",rPart)> = %<defaultInitialValue>;
            %if uIsComplex
              %<LibBlockDstSignalLocation("outportblk","","",iPart)> = %<defaultInitialValue>;
            %endif
	  %endif
	%else
           %% Because SLibValueIsAllZeroBitsCrudeCheck interogates a string for '0', 
           %% or '0.0', it is OK to memset multiword as long as initValue is 0. 
           %% To be conservative, since multiword's ground value is '{0}' at the 
           %% closest, not '0', it is never memset.
           %assign memsetSuitable = !localOut && ...
                FcnSuitableForMemset(defaultInitialValue, dTypeId, "")
           %if !memsetSuitable
             %%
             %if width >= RollThreshold
	     {
	        %<SLibEmitForLoopCounterCode(width)>
                %if localOut
                  %assign sigIndexer = SLibGet1DArrayIndexer(width, "i", "", 0)
                  %assign lhs = "localOut%<idx>" + sigIndexer
                  %if uIsComplex 
                    %assign lhs = lhs + "." + tRealPart
                  %endif
                  %<lhs> = %<defaultInitialValue>;
                  %if uIsComplex
                    %assign lhs = "localOut%<idx>" + sigIndexer + "." + tImagPart
                    %<lhs> = %<defaultInitialValue>;
                  %endif
                %else
                  %<LibBlockDstSignalLocation("outportblk","i","",rPart)> = %<defaultInitialValue>;
                  %if uIsComplex
                    %<LibBlockDstSignalLocation("outportblk","i","",iPart)> = %<defaultInitialValue>;
                  %endif
                %endif
	        }
	      }
	    %else
              %foreach initIdx = width
              %if localOut
                %assign sigIndexer = SLibGet1DArrayIndexer(width, "%<initIdx>", "", 0)
                %assign lhs = "localOut%<idx>" + sigIndexer
                %if uIsComplex 
                  %assign lhs = lhs + "." + tRealPart
                %endif
                %<lhs> = %<defaultInitialValue>;
                %if uIsComplex
                  %assign lhs = "localOut%<idx>" + sigIndexer + "." + tImagPart
                  %<lhs> = %<defaultInitialValue>;
                %endif
              %else
                %<LibBlockDstSignalLocation("outportblk","%<initIdx>","",rPart)> = %<defaultInitialValue>;
                %if uIsComplex
                  %<LibBlockDstSignalLocation("outportblk","%<initIdx>","",iPart)> = %<defaultInitialValue>;
                %endif
              %endif
              %endforeach
	    %endif
	  %else
	    %assign dtName = SLibGetRecordContainerBaseTypeName(extOut)
	    %assign srcLoc = LibBlockDstSignalLocation("outportblk","","",0)
	    %if uIsComplex
	      %assign width = 2*width
	    %endif
            %assign sanitizedInitValue = ...
	      FcnCastValueForMemsetUse(dTypeId, defaultInitialValue)
	    (void) %<LibGenMemFcnCall("memset", "&%<srcLoc>", sanitizedInitValue, ...
	      "%<width>U*sizeof(%<dtName>)")>;
	  %endif
	%endif
      %endif
      %endwith %% outportBlock
    %endforeach
    %closefile NonMemsetBuffer

    %if memsetToZeroNeeded
      %assign initAddr = (YQualifier == "." ? "&" : "") +...
           LibGetExternalOutputStruct()
      (void) %<LibGenMemFcnCall("memset", "(void *)" + initAddr, ...
                                " 0", " sizeof(%<tOutputType>)")>;
    %endif
    %%
    %if  !WHITE_SPACE(NonMemsetBuffer)
      %<NonMemsetBuffer>
    %endif
  %endif
  %endwith %% System[NumSystems-1]
%endfunction  %% SLibInitExternalOutputs

%% It is simpler than SLibInitExternalOutputs because
%% - External outport cannot have storage class.
%% - FcnConditionRootOutputsAsSeparateArgs cannot be true
%%   for VarDims (FPC is not supported yet)
%%   thus there is no need to consider localOut
%function SLibInitExternalOutputSizes() Output
  %with ::CompiledModel.System[NumSystems-1]
  %if ::CompiledModel.NumModelOutputs > 0 && ...
    !SLibAutosarActive()
    %% initialize root outport for auto.
    %foreach idx = ::CompiledModel.ExternalOutputs.NumExternalOutputs
      %assign extOut  = ::CompiledModel.ExternalOutputs.ExternalOutput[idx]
      %if ISFIELD(extOut, "SizeVarGroupIdx")
        %assert ISFIELD(extOut, "HasVarDims")
        %assign sizeTypeIdx = SLibCGVarGroupMemberCGTypeIdx(...
          extOut.SizeVarGroupIdx[0], ...
          extOut.SizeVarGroupIdx[1])
        %assign sizeVecLen = LibCGTypeWidth(sizeTypeIdx)
        %foreach dimIdx = sizeVecLen
          %<SLibGetOutportSize(idx, sizeVecLen, "", -1, "", dimIdx)> = ...
            %<SLibGetDefaultInitialValue(...
            SLibVarGroupMember(extOut.SizeVarGroupIdx[0], ...
            extOut.SizeVarGroupIdx[1]), tRealPart)>;
        %endforeach
      %endif
    %endforeach
  %endif
  %endwith %% System[NumSystems-1]
%endfunction

%% Function: FcnInitStatesWithExternalStorage ==================================
%% Abstract:
%%   Helper function to Initialize the states with external storage class
%%
%function FcnInitStatesWithExternalStorage(sc, comment, fieldsep, addressof, deref) void
  %openfile rtnBuffer
  %foreach dwIdx = DWorks.NumDWorks
    %assign dwRec  = DWorks.DWork[dwIdx]
    %assign id     = LibGetRecordIdentifier(dwRec)
    %if FcnIsNotInterfaceableStorageClassCheck(dwRec)
      %continue
    %endif
    %if IsModelReferenceTarget() && dwRec.GlobalDSM
      %continue
    %endif
    %with dwRec
      %assign ppStuff = SLibDataPreprocessorStuff(dwRec)
      %assign ppIf = ppStuff[0]
      %assign ppFi = ppStuff[1]
      %%
      %% Standalone subsystems cache separately
      %assign stdSSIdx = -1
      %assign sysIdx = StandaloneParentSysIdxOfDataRec(dwRec)
      %if sysIdx == -1 && FcnIsFileScopeCustomStorageCheck(dwRec)
        %assign sysIdx = FcnGetNonRootFileFunctionOwner(dwRec, sysIdx)
      %endif
      %if sysIdx != -1
        %assign stdSSIdx = sysIdx
        %assign stdSSBuffer = ""
      %endif
      %if StorageClass != sc
        %%
        %% Skip those records whose StorageClass not as specified in sc
        %%
        %continue
        %%
      %endif
      %%
      %if StorageClass == "Custom"
        %%
        %% For custom storage class, call "initialize" in its .tlc
        %%
        %% Note that custom storage class .tlc itself should check
        %% remove zero initialization option
        %%
        %assign initCount = SLibDWorkWidth(dwRec)
        %openfile initCode
        %<SLibEmitLibCustomInitCode(dwRec, initCount, SLibDWorkIsComplex(dwRec))>
        %closefile initCode
        
        %if stdSSIdx != -1
          %% cache output to tmpBuffer, no %continue until %closefile
          %openfile tmpBuffer
        %endif
        %<ppIf>
        %<initCode>
        %<ppFi>
        %if stdSSIdx != -1
          %closefile tmpBuffer
          %assign stdSSBuffer = stdSSBuffer + tmpBuffer
        %endif
      %else
        %%
        %% For any other external storage, use its default initial value
        %%
        %assign dTypeId = SLibDWorkDataTypeId(dwRec)
        %%
        %% Check remove zero initialization option
        %if SLibRemoveZeroInitForDataDefault(dwRec)
          %continue
        %endif
        %%
        %if stdSSIdx != -1
          %% cache output to tmpBuffer, no %continue until %closefile
          %openfile tmpBuffer
        %endif
        %<ppIf>
        %if LibIsDataTypeMultiWordFixpt(dTypeId)
          %assign defaultInitialValue = LibGetGroundName(dwRec, tRealPart)
        %else
          %assign defaultInitialValue = SLibGetDefaultInitialValue(dwRec, tRealPart)
        %endif
        %assign width = SLibDWorkWidth(dwRec)
        %if width == 1
          %% scalar case
          %if SLibDWorkIsComplex(dwRec)
            %<id>%<fieldsep>%<tRealPart> = %<defaultInitialValue>;
            %<id>%<fieldsep>%<tImagPart> = %<defaultInitialValue>;
          %else
            %<deref>%<id> = %<defaultInitialValue>;
          %endif
        %else
          %%
          %assign memsetSuitable = FcnSuitableForMemset(defaultInitialValue, dTypeId, "")
          %%
          %if !memsetSuitable
            %%
            %if width >= RollThreshold
              {
                  %<SLibEmitForLoopCounterCode(width)>
                  %if SLibDWorkIsComplex(dwRec)
                    %<id>[i]%<fieldsep>%<tRealPart> = %<defaultInitialValue>;
                    %<id>[i]%<fieldsep>%<tImagPart> = %<defaultInitialValue>;
                  %else
                    %<deref>%<id>[i] = %<defaultInitialValue>;
                  %endif
                }
              }
            %else
              %foreach initIdx = width
                %if SLibDWorkIsComplex(dwRec)
                  %<id>[%<initIdx>]%<fieldsep>%<tRealPart> = %<defaultInitialValue>;
                  %<id>[%<initIdx>]%<fieldsep>%<tImagPart> = %<defaultInitialValue>;
                %else
                  %<deref>%<id>[%<initIdx>] = %<defaultInitialValue>;
                %endif
              %endforeach
            %endif
          %else
            %% non-float vector case
            %if SLibDWorkIsComplex(dwRec)
              %assign width = 2*width
            %endif
            %assign dtName = SLibGetRecordContainerBaseTypeName(dwRec)
            %assign sanitizedInitValue = ...
	      FcnCastValueForMemsetUse(dTypeId, defaultInitialValue)
	    (void) %<LibGenMemFcnCall("memset", "%<addressof>%<id>", ...
	      sanitizedInitValue, "%<width>U*sizeof(%<dtName>)")>;
          %endif
        %endif
        %<ppFi>
        %if stdSSIdx != -1
          %closefile tmpBuffer
          %assign stdSSBuffer = stdSSBuffer + tmpBuffer
        %endif
      %endif
      %if stdSSIdx != -1 && !WHITE_SPACE(stdSSBuffer)
        %<LibAddToSystemField(System[stdSSIdx],"TempInitBuffer",...
          stdSSBuffer)>
      %endif
    %endwith
  %endforeach
  %closefile rtnBuffer
  
  %% Cache standalone subsystem initialization
  %foreach sysIdx = NumSystems
    %assign sys = System[sysIdx]
    %if LibIsSystemField(sys, "TempInitBuffer")
      %assign stdSSBuffer = LibGetSystemField(sys, "TempInitBuffer")
      %if !ISEMPTY(stdSSBuffer)
        %<LibAddToSystemField(sys, "CachedInitializeDataBody", ...
          "\n" + comment + "\n" + stdSSBuffer + "\n")>
        %% Reset field for next call
        %<LibSetSystemField(sys, "TempInitBuffer", "")>
      %endif
    %endif
  %endforeach
  %% Cache root model initialization
  %if !WHITE_SPACE(rtnBuffer)
    %return "\n" + comment + "\n" + rtnBuffer
  %else
    %return ""
  %endif
%endfunction %% FcnInitStatesWithExternalStorage

%% Function: SLibInitStatesWithExternalStorage =================================
%% Abstract:
%%   Initialize the states with external storage class
%%
%function SLibInitStatesWithExternalStorage(usingStatic) Output
  %%
  %% Exported global states
  %%
  %if !SLibExportedGlobalDWorkIsEmpty()
    %<FcnInitStatesWithExternalStorage("ExportedGlobal", ...
      "/* exported global states */", ".", "&", "")>
  %endif
  %%
  %% Custom states
  %%
  %if !SLibCustomDataBufferIsEmpty("Definitions")
    %<FcnInitStatesWithExternalStorage("Custom", ...
      "/* custom states */", ".", "&", "")>
  %endif
%endfunction  %% SLibInitStatesWithExternalStorage


%% Function:CacheStandaloneSystemDWorkInfo =====================================
%% Abstract:
%%   This is a helper function for dumping dwork initialization.
%%   This function returns a record. The record consists of an array of records.
%%   The root system and each standalone subsystem has an entry in this record.
%%   While looping through the Systems, we will add
%%   IndexInStandaloneSubsystemArray to the root system and each standalone
%%   system. Root system has 0-th index. 
%%
%%   Note that the record is partially populated. 
%%
%function CacheStandaloneSystemDWorkInfo()
  %assign counter     = 0
  %assign rootSSIdx   = GetBaseSystemIdx()
  %assign totalNumSys = GetNumSystemsForCodeGen()
  
  %% standalone subsystem buffer
  %createrecord stdSSBuf {}
 
  %foreach sysIdx = totalNumSys
    %% Root or standalone subsystem (root will have 0th group index)
    %assign thisIdx = totalNumSys - 1 - sysIdx
    
    %if thisIdx  == rootSSIdx || System[thisIdx].StandaloneSubsystem 
      %if !(ISFIELD(System[thisIdx], "IndexInStandaloneSubsystemArray"))
        %addtorecord  System[thisIdx] IndexInStandaloneSubsystemArray counter
      %endif
      %addtorecord stdSSBuf DWorkBuff { ...
        SystemIdx  %<thisIdx>; ...
        DWorkType  ""; ...
        DWorkVar   ""; ...
        haveFloat  0;  ...
        needMemset 0;  ...
        initBuffer ""  ...
      }
      
      %if IsModelReferenceTarget() && (! GenerateClassInterface)
        %assign sysIdx = GetBaseSystemIdx()
        %assign varGroupType = FcnSysVarGroupType(System[sysIdx],"DWork")
        %assign stdSSBuf.DWorkBuff[counter].DWorkType = varGroupType
        %assign stdSSBuf.DWorkBuff[counter].DWorkVar  = "localDW"
      %elseif IsModelReferenceTarget() && GenerateClassInterface
        %assign stdSSBuf.DWorkBuff[counter].DWorkType = "%<tDWorkType>"
        %assign stdSSBuf.DWorkBuff[counter].DWorkVar  = "%<tDWork>"
      %elseif thisIdx == rootSSIdx
        %assign stdSSBuf.DWorkBuff[counter].DWorkType = "%<tDWorkType>"
        %assign stdSSBuf.DWorkBuff[counter].DWorkVar  = "%<LibGetDWorkStruct()>"
      %else 
        %assign varGroupType = FcnSysVarGroupType(System[thisIdx],"DWork")
        %assign stdSSBuf.DWorkBuff[counter].DWorkType = varGroupType
        %assign stdSSBuf.DWorkBuff[counter].DWorkVar = ...
          FcnSysVarGroupNonreusedName(System[thisIdx],"DWork")
      %endif
      %assign counter = counter+1
    %endif
  %endforeach
  
  %% If this is a model reference, then counter should be 1
  %%    A -> B is equivalent to (!A) || B
  %assert((! IsModelReferenceTarget()) || (counter == 1))
  
  %return stdSSBuf
%endfunction


%% Function SLibGetExtUIdentifier(extInpRec, idx, reim)
%% Abstract:
%%   Get inport variable name 
%%   
%function SLibGetExtUIdentifier(extInp, idx,  reim)
  %%
  %if extInp.StorageClass == "Auto"
    %assign varName = "%<LibGetExternalInputStruct()>%<UQualifier>%<LibGetRecordIdentifier(extInp)>"
  %elseif extInp.StorageClass == "ExportedGlobal" || extInp.StorageClass == "ImportedExtern"
    %assign varName = LibGetRecordIdentifier(extInp)
  %elseif extInp.StorageClass == "ImportedExternPointer"
    %assign varName =  "(*%<LibGetRecordIdentifier(extInp)>)"
  %endif
  %%
  %assign width   = LibGetRecordWidth(extInp)
  %if width != 1
    %assign varName = "%<varName>[%<idx>]"
  %endif
  %if LibGetRecordIsComplex(extInp)
    %assign varName = "%<varName>."
  %elseif reim == "im"
    %assign errTxt = "Try to generate complex variable name but Inport block is set to accept real signal"
    %<LibReportFatalError(errTxt)>
  %else
    %assign reim =""
  %endif
  %assign varName = "%<varName>%<reim>"
  %return varName
%endfunction  %% SLibGetExtUIdentifier


%% Function: LocalInitDworkVector ==============================================
%% Abstract:
%%   Does not check remove zero initialization option.  Caller should do that.
%%
%function LocalInitDworkVector(stdSSBuf, stdIdx, ...
  initCount, name, initValue, isComplex, ppIf, ppFi) void
  
  %openfile tmpBuf
  %<ppIf>
  %if initCount == 1
    %if %<isComplex>
      %<name>.%<tRealPart> = %<initValue>;
      %<name>.%<tImagPart> = %<initValue>;
    %else
      %<name> = %<initValue>;
    %endif
  %elseif initCount >= RollThreshold
    %% use a loop
    {
      %<SLibEmitForLoopCounterCode(initCount)>
      %if %<isComplex>
        %<name>[i].%<tRealPart> = %<initValue>;
        %<name>[i].%<tImagPart> = %<initValue>;
      %else
        %<name>[i] = %<initValue>;
      %endif
      }
    }
  %else
    %% do not use loop
    %foreach initIdx = initCount
      %if %<isComplex>
        %<name>[%<initIdx>].%<tRealPart> = %<initValue>;
        %<name>[%<initIdx>].%<tImagPart> = %<initValue>;
      %else
        %<name>[%<initIdx>] = %<initValue>;
      %endif
    %endforeach
  %endif
  %<ppFi>
  %closefile tmpBuf

  %% Add the initialization code to the right buffer
  %assign stdSSBuf.DWorkBuff[stdIdx].initBuffer = ...
    stdSSBuf.DWorkBuff[stdIdx].initBuffer + tmpBuf
  
  %return stdSSBuf
%endfunction

%function SLibInitDWorkHelper(stdSSBuf, stdIdx, sysIdx, cross, dwRec, ignoreInitInStart, ppIf, ppFi) void
  %%
  %if dwRec.StorageClass != "Auto" || dwRec.OptimizedAwayInTLC
    %return stdSSBuf
  %endif
    
  %% InitialValue is not provided.  Use default initial value then.
  %if SLibRemoveZeroInitForDataDefault(dwRec)
    %return stdSSBuf
  %endif
  %%
  %assign DataTypeIdx  = SLibDWorkDataTypeId(dwRec)
  %assign curDataTypeId = LibGetDataTypeIdAliasedThruToFromId(DataTypeIdx)
  %assign curMemsetToZeroSuffice = FcnMemsetToZeroInitSuffice(curDataTypeId)
  %%
  %if curMemsetToZeroSuffice
    %if SLibZeroMemory("DWork")
      %assign stdSSBuf.DWorkBuff[stdIdx].needMemset = 1
    %endif
    %% We know we can ignore this one.  Memset has taken care of it.  Go get next one.
    %return stdSSBuf
  %endif
    
  %if (curDataTypeId == tSS_DOUBLE || curDataTypeId == tSS_SINGLE)
    %if InitFltsAndDblsToZero 
      %if ignoreInitInStart || !dwRec.InitInStart
        %% Need to set floating-point dworks explicitly to 0.0
        %% Lifted from FcnGetDWorkIdentifier
        %assign name   = SLibCG_GetVarGroupElementPath(dwRec.VarGroupIdx, ...
          sysIdx, cross)
        %assign initCount = SLibDWorkWidth(dwRec)
        %assign isComplex = SLibDWorkIsComplex(dwRec)
        %assign defaultInitialValue = SLibGetDefaultInitialValueFromId(DataTypeIdx)
        %%
        %assign stdSSBuf.DWorkBuff[stdIdx].haveFloat = 1
        
        %% Need to see if this is an RWORK substructure, in which case we need an inner loop
        %assign block  = System[dwRec.SigSrc[0]].Block[dwRec.SigSrc[2]]
        %with block
          %if (dwRec.Origin == "RWORK") && (NumRWorkDefines > 0)
            %foreach initIdx = NumRWorkDefines
              %assign fieldname = name + ".%<RWorkDefine[initIdx].Name>"
              %assign initCount = RWorkDefine[initIdx].Width
              %assign stdSSBuf = LocalInitDworkVector(stdSSBuf, stdIdx, ...
                initCount, fieldname, defaultInitialValue, isComplex, ...
                ppIf, ppFi)
            %endforeach
            %return stdSSBuf
          %endif
        %endwith
        
        %assign stdSSBuf = LocalInitDworkVector(stdSSBuf, stdIdx, ...
          initCount, name, defaultInitialValue, isComplex, ppIf, ppFi)
      %endif
    %elseif SLibZeroMemory("DWork")
      %assign stdSSBuf.DWorkBuff[stdIdx].needMemset = 1
    %endif
  %elseif SLibZeroMemory("DWork")
    %assign stdSSBuf.DWorkBuff[stdIdx].needMemset = 1
  %endif
  
  %return stdSSBuf
%endfunction
%% Function: SLibInitDWork =====================================================
%% Abstract:
%%   Initialize DWork structure (ie. those with internal storage) to zero
%%   Memset entire DWork structure to 0 if non-floating elements exist.
%%   Assign double and single floating-point elements to 0.0
%%
%%   This function returns vector with three values [numeric, numeric, string]:
%%     haveFloat  - found at least one floating-point region
%%     needMemset - found at least one non-floating-point region
%%     initBuffer - buffer with floating-point assignments to 0.0
%%
%function SLibInitDWork(stdSSBuf) void
  %if ForceBlockIOInitOptimize
    %% Choosing this option may result in code that is not MISRA-C compliant.
    %assert(!IsModelReferenceTarget())
    %assign stdSSBuf = SLibInitDWorkOld(stdSSBuf)
    %return stdSSBuf
  %endif
  %foreach dwIdx = DWorks.NumNonLocalDWorks
    %assign dwRec  = DWorks.DWork[dwIdx]
    
    %assign idx = SLibGetSystemAndCallSideIndex(dwRec)
    %if SigSrcLivesInStandaloneSS(idx)
      %assign baseSystemIdx = StandaloneParentSysIdxOfDataRec(dwRec)
    %else
      %assign baseSystemIdx = GetBaseSystemIdx()
    %endif
    %assign cross  = System[baseSystemIdx].CrossNoArgFcnBound
    
    %assign ppStuff = SLibDataPreprocessorStuff(dwRec)
    %assign ppIf = ppStuff[0]
    %assign ppFi = ppStuff[1]
    
    %assign stdIdx = System[baseSystemIdx].IndexInStandaloneSubsystemArray
    
    %assign stdSSBuf = SLibInitDWorkHelper(stdSSBuf, stdIdx, baseSystemIdx, cross, dwRec, TLC_FALSE, ppIf, ppFi)
  %endforeach
  
  %if stdSSBuf.DWorkBuff[0].needMemset
    %assign baseSystemIdx = GetBaseSystemIdx()
    %<SLibAccessArgHelper(System[baseSystemIdx].Interface.DWorkArgDef,"","")>
  %endif
  %% SLibGetDataLayout above took care of LibAccessArg for what's in initBuffer
  %return stdSSBuf

%endfunction  %% SLibInitDWork


%% Function: SLibDumpModelDataInitialization ===================================
%% Abstract:
%%   Dump all data initialization for model.
%%
%function SLibDumpModelDataInitialization() Output
  %%
  %% Combine DWork and BlockIO is a Embedded Coder feature and not expected to
  %% be enabled for Simstruct based targets (such as RSIM and Accelerator).
  %%
  %assert !::CompiledModel.DWorkAndBlockIOCombined
  %%  
  %assert(!UsingMalloc)
  /*
   * initialize model vectors and cache them in SimStruct
   */
  %%
  %% Block I/O
  %%
  %assign ptrBlockIOLabel = "#error no valid pointer to BlockIO because it is empty"
  %openfile tmpBuf
  %if !LibBlockIOStructIsEmpty()
    %assign ptrBlockIOLabel = "((void *) &%<LibGetBlockIOStruct()>)"
    %if ::CompiledModel.HasSimStructVars == 0
      %<RTMSet("BlockIO", ptrBlockIOLabel)>;
    %endif
  %endif

  %% Find out whether a memset is needed for combined Dwork and Block IO
  %assign needMemsetForCombinedDWorkAndBlockIO = SLibInitBlockIO(ptrBlockIOLabel)
  %closefile tmpBuf
  %if !WHITE_SPACE(tmpBuf)

    /* block I/O */
    {
      %<tmpBuf>
    }
  %endif
  %%
  %% U
  %%
  %openfile tmpBuf
  %if !LibExternalInputsStructIsEmpty()
    %<RTMSet("U", "((void*) &%<LibGetExternalInputStruct()>)")>;
  %endif
  %<SLibInitExternalInputs(TLC_TRUE,0, 0)>\
  %closefile tmpBuf
  %if !WHITE_SPACE(tmpBuf)

    /* external inputs */
    {
      %<tmpBuf>\
    }
  %endif
  %%
  %% Y
  %%
  %if !LibExternalOutputsStructIsEmpty()

    /* external outputs */
    {
      %<RTMSet("Y", "&%<LibGetExternalOutputStruct()>")>;
      %<SLibInitExternalOutputs(1,0,0)>\
    }
  %endif
  %%
  %% Parameters
  %%
  %if !LibParametersStructIsEmpty()

    /* parameters */
    %<RTMSet("DefaultParam", "(real_T *) &%<LibGetParametersStruct()>")>;
   
  %endif
  %%
  %% States
  %%
  %if (NumContStates) > 0

    /* states (continuous)*/
    {
      real_T *x = (real_T *) &%<LibGetContinuousStateStruct()>;
      
      %% Always setup continuous states so ssGetX in logging code works
      %<RTMSet("ContStates", "x")>;
      (void) %<LibGenMemFcnCall("memset", "(void *)x", "0", ...
	"sizeof(%<tContStateType>)")>;
    }
  %endif
  %%
  %% DWork
  %%
  %if !LibDWorkStructIsEmpty()
    %assign stdSSBuf = CacheStandaloneSystemDWorkInfo()

    %% This is a non-ert target. Root system should be the only system in
    %% stdSSBuf
    %assert(SIZE(stdSSBuf.DWorkBuff, 1) == 1)
    /* states (dwork) */
    {
      %assign stdSSBuf = SLibInitDWork(stdSSBuf)
      void *dwork = (void *) &%<LibGetDWorkStruct()>;
     
      %<RTMSet("RootDWork", "dwork")>;
      %if stdSSBuf.DWorkBuff[0].needMemset ...
          || needMemsetForCombinedDWorkAndBlockIO == 1
        (void) %<LibGenMemFcnCall("memset", "dwork", " 0", ...
          " sizeof(%<tDWorkType>)")>;
        %assign baseSystemIdx = GetBaseSystemIdx()
        %<SLibAccessArgHelper(System[baseSystemIdx].Interface.DWorkArgDef,"","")>
      %endif
      %if stdSSBuf.DWorkBuff[0].haveFloat
        %<stdSSBuf.DWorkBuff[0].initBuffer>\
      %endif
    }

  %endif
  %openfile tmpBuf
  %<SLibInitStatesWithExternalStorage(TLC_TRUE)>\
  %closefile tmpBuf
  %if !WHITE_SPACE(tmpBuf)
    %<tmpBuf>\
  %endif

  %%    
  %%
  %% Initialize MassMatrix-related DWorks in Registration function.
  %% This function is calledfor non-ERT-based targets (Rsim, GRT_malloc, Generated Sfcn).
  %% We need to configure Pr-s for Rsim here.
  %%
  %if (ModelIsLinearlyImplicit == "yes")     
    %assert( !IsModelReferenceTarget() )    
    %<FcnGenInitMassMatrixPrInRoot()>                  
  %endif  
    
  %%
  %% Multi-Instance Stateflow chart initialization
  %%
  %% dboissy & vijay say:
  %% Don't need this
  %%<SLibDumpSFLibraryBlockInitialization()>\
  %%
%endfunction %% SLibDumpModelDataInitialization


%% Function: SLibDumpTimingInfoRegistration ====================================
%% Abstract:
%%   Dump all timing info
%%
%function SLibDumpTimingInfoRegistration() Output
  %%
  %% Timing Info.  Supports these code formats
  %%     o RealTime using SimStruc
  %assert(!UsingMalloc)
  /* timing info */
  {
    %assign nTs = "NSAMPLE_TIMES"
    %assign nTs = SLibIsERTCodeFormat() ? NumSynchronousSampleTimes : "NSAMPLE_TIMES"
    static time_T mdlPeriod[%<nTs>];
    static time_T mdlOffset[%<nTs>];
    static time_T mdlTaskTimes[%<nTs>];
    static int_T  mdlTsMap[%<nTs>];
    static int_T  mdlSampleHits[%<nTs>];
    %if isRSimWithSolverModule %% assert !IsModelReferenceTarget
      static boolean_T  mdlTNextWasAdjustedPtr[%<nTs>];
      static int_T mdlPerTaskSampleHits[%<nTs> * %<nTs>];
      static time_T mdlTimeOfNextSampleHit[%<nTs>];
    %endif
    
    {
      int_T i;

      for (i = 0; i < %<nTs>; i++) {
	mdlPeriod[i] = 0.0;
	mdlOffset[i] = 0.0;
	mdlTaskTimes[i] = 0.0;
	mdlTsMap[i] = i;
        %if SLibSingleTasking()
	  mdlSampleHits[i] = 1;
	%endif
      }
    }
    %if !SLibSingleTasking()
      mdlSampleHits[0] = 1;
    %endif

    %<RTMSet("SampleTimePtr",       "&mdlPeriod[0]")>;
    %<RTMSet("OffsetTimePtr",       "&mdlOffset[0]")>;
    %<RTMSet("SampleTimeTaskIDPtr", "&mdlTsMap[0]")>;
    %<RTMSet("TPtr",                "&mdlTaskTimes[0]")>;
    %<RTMSet("SampleHitPtr",        "&mdlSampleHits[0]")>;
    %if isRSimWithSolverModule %% assert !IsModelReferenceTarget
      %<RTMSet("TNextWasAdjustedPtr", "&mdlTNextWasAdjustedPtr[0]")>;
      %<RTMSet("PerTaskSampleHitsPtr", "&mdlPerTaskSampleHits[0]")>;
      %<RTMSet("TimeOfNextSampleHitPtr", "&mdlTimeOfNextSampleHit[0]")>;
    %endif
  }
  %if ::CompiledModel.SolverType == "FixedStep"
    %if ::CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
      {
        static int_T mdlPerTaskSampleHits[%<nTs> * %<nTs>];
	
        (void) %<LibGenMemFcnCall("memset", "(void *)&mdlPerTaskSampleHits[0]", "0", ...
	  "%<NumSynchronousSampleTimes> * %<NumSynchronousSampleTimes> * sizeof(int_T)")>;
        %<RTMSet("PerTaskSampleHitsPtr", "&mdlPerTaskSampleHits[0]")>;
      }
      %<RTMSolverSet("SolverMode", "SOLVER_MODE_MULTITASKING")>;
    %else
      %<RTMSolverSet("SolverMode", "SOLVER_MODE_SINGLETASKING")>;
    %endif
  %else  %% Variable-Step solver
    %<RTMSolverSet("SolverMode", "SOLVER_MODE_SINGLETASKING")>;
  %endif
%endfunction %% SLibDumpTimingInfoRegistration


%% Function: genAbsTolControlSetup =========================================
%% Abstract:
%%   Absolute tolerance control vector set up in model registration
%%
%function genAbsTolControlSetup() void
  
  %assign zeroArray = FEVAL("zeros", 1, NumContStates)
  %assign absTolControl = FEVAL("uint8", zeroArray)
  %assign mdlAbsTolControl = ::CompiledModel.VariableStepOpts.AbsTolControl
  
  %% Copy top model absolute tolerance control first
  %if NumContStates > 1
    %foreach ix = NumContStates
      %assign absTolControl[ix] = mdlAbsTolControl[ix]      
    %endforeach
  %else
    %% TLC loops do not like size-1 arrays 
    %assign absTolControl = mdlAbsTolControl
  %endif
  
  %% Now handle model reference case by looping over all cstate records
  %foreach csIdx = ::CompiledModel.ContStates.NumContStates
    %assign cs = ::CompiledModel.ContStates.ContState[csIdx]
    %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"

    %% Global setting ok if no model reference.
    %if !isMdlRef
      %continue
    %endif

    %assert(isMdlRef)

    %% If model reference : Look at interface data for model reference 
    %assign blk = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
    %assign intrf = GetModelrefInterface(blk)

    %% If abstol control is available 
    %% (it might not be if referenced model was built with fixed-step settings)
    %% Prefer global settings in such case.
    %if !EXISTS(intrf.refAbsTolControl)
      %continue
    %endif
    
    %assert(EXISTS(intrf.refAbsTolControl))
    
    
    %assign refAbsTolControl = intrf.refAbsTolControl
    %assign csparts = cs.Partitions
    %% Loop over cstate partition 
    %foreach csp = csparts.NumPartitions
      %assign cstateIndices = csparts.Partition[csp].CStateIndices
      %assign nci = SIZE(cstateIndices)[1]
      %assign pwidth = csparts.Partition[csp].Width
      %% For a plain model ref niter is equal to one, 
      %% i.e. number of indices is equal to partition width 
      %% For For-each subsystem niter > 1
      %assign niter = nci/pwidth
      %% This is the offset over model reference states
      %% We increment it by width of each partition in the
      %% outer niter loop
      %assign refOffset = 0
      %% Now loop over the iterations
      %foreach i_iter = niter 
        %% over partition width for this record
        %foreach i_x = pwidth
          %% Compute the index for indexing cstatesIndices
          %% Essentially we are processing chunks of cstateIndices equal to
          %% pwidth
          %assign csiIndex = (i_iter*pwidth) + i_x 
          %% If the control on referenced model refers to local setting 
          %% Prefer the local otherwise prefer the top model setting
          %if refAbsTolControl[refOffset+i_x] == 1
            %assign absTolControl[cstateIndices[csiIndex] ] = FEVAL("uint8", 1)
          %endif %% if control is local
        %endforeach %% width of cstate partition
      %endforeach %% For number of iteration (for-each) or 1 (for normal cases)
      %% Move the referenced model state offset by the partition width
      %assign refOffset = refOffset + pwidth
    %endforeach %% for each partition
  %endforeach %% for each cstate record

  %assign absTolControlStr = "static uint8_T absTolControl[%<NumContStates>] = {"
  %assign comma = ""
  %foreach i_x = NumContStates
    %assign absTolControlStr =  "%<absTolControlStr>%<comma> %<absTolControl[i_x]>"
    %assign comma = ", "
  %endforeach
  %% Close the array in C with };
  %assign absTolControlStr = "%<absTolControlStr> };"
  
  %return absTolControlStr
  
%endfunction

%% Function: SLibDumpModelRegRSimSetup =========================================
%% Abstract:
%%   Registration code need for the RSim target.
%%
%function SLibDumpModelRegRSimSetup() Output
  {
    static ssSolverInfo slvrInfo;

    %if NumContStates > 0
      %if (ModelHasProjections == "yes") || (ModelIsLinearlyImplicit == "yes")
        static struct _ssSFcnModelMethods3 mdlMethods3;
        static struct _ssSFcnModelMethods2 mdlMethods2;
      %endif
      static boolean_T contStatesDisabled[%<NumContStates>];

    %endif    
    %if SolverType == "VariableStep"
      %assign nOutTimes = SIZE(VariableStepOpts.OutputTimes,1)
      %assign outTimes  = (nOutTimes == 0) ? SLibGetNullDefinitionFromTfl() : "outputTimes"
      %assign nDU       = SolverResetInfo.NumNonContDerivSignals
      %assign dU        = (nDU == 0) ? SLibGetNullDefinitionFromTfl() : "nonContDerivSigInfo"
      
      %if NumContStates > 0
        static real_T absTol[%<NumContStates>] = {\
        %assign comma = ""
        %foreach idx = NumContStates
          %<comma>%<VariableStepOpts.AbsTol[idx]>\
          %assign comma = ", "
        %endforeach
      };
      
      %% Generate the Absolute tolerance control setup
      %<genAbsTolControlSetup()>
      
    %endif
      %%adzc
      %if NumNonsampledZCs > 0
        %assign zcVectorLen = CompiledModel.ZCVectorlength
        %assign zcAttributes = FEVAL("zeros", 1, zcVectorLen)
	%foreach idx = ZcRec. NumBlkZcRecs
	  %assign blkZcRec = ZcRec.BlkZcRec[idx]
	  %foreach zcsIdx  = blkZcRec.NumZcSignalInfos
	    %assign zcs    = blkZcRec.ZcSignalInfo[zcsIdx]
            %assign needEvent = zcs.NeedsEvent
            %assign zcDir   = zcs.ZcEventType
            %assign zcVectorIndices = zcs.ZcVectorIndices
            %assign zcWidth = zcs.Width
            %assign jdx = 0
            %foreach zcVectorIdx = SIZE(zcVectorIndices)[1]
              %if jdx == zcWidth
                %assign jdx = 0
              %endif
              %if zcs.ZcSignalType == "Hybrid"
                %assign isDisc = zcs.IsElementDisc[jdx]
              %elseif zcs.ZcSignalType == "Continuous"
                %assign isDisc = 0              
              %else
                %assign isDisc = 1
              %endif
              %if zcVectorLen == 1
                %assign zcAttributes = "%<SLibGetZCAttributes(isDisc, needEvent, zcDir)>"
              %else
                %assign zcAttributes[zcVectorIndices[zcVectorIdx]] = SLibGetZCAttributes(isDisc, needEvent, zcDir)
              %endif
              %assign jdx = jdx + 1
            %endforeach
	  %endforeach
	%endforeach
	%assign comma = ""
	static uint8_T zcAttributes[%<zcVectorLen>] = {\
        %if zcVectorLen == 1
          %<zcAttributes>\
        %else
          %foreach idx = zcVectorLen
            %<comma>%<zcAttributes[idx]>\
            %assign comma = ", "
          %endforeach
        %endif
        };      
        %%adzc
    %endif
    
      %if nOutTimes > 0
	static real_T %<outTimes>[%<nOutTimes>] = {\
	  %assign comma = ""
	  %foreach idx = nOutTimes
	    %<comma>%<VariableStepOpts.OutputTimes[idx]>\
	    %assign comma = ", "
	  %endforeach
	};
      %endif

      %if nDU > 0
        %assign codebuf = ""
	static ssNonContDerivSigInfo %<dU>[%<nDU>] = {
	  %assign comma = ""
          %assign numSigs = SIZE(SolverResetInfo.NonContDerivSignal,1)
          %assign arrayIdx = 0
	  %foreach idx = numSigs
	    %assign nonContSig = SolverResetInfo.NonContDerivSignal[idx]
            %if ISFIELD(nonContSig,"MdlRefInfo")
              %assign mdlRefInfo = nonContSig.MdlRefInfo
              %assign mSysIdx = mdlRefInfo[0][0]
              %assign bIdx    = mdlRefInfo[0][1]
              %assign instIdx = mdlRefInfo[0][2]
              %assign port    = mdlRefInfo[0][3]
              %assign blk = System[mSysIdx].Block[bIdx]
              %assign name = blk.ParamSettings.ReferencedModelName
              %assign mangleName = FcnGetNoncontMangledName(name, mSysIdx, ...
                bIdx, instIdx)
              %foreach subIdx = nonContSig.NumMdlRefNonContSigs
                %<comma>{0, %<SLibGetNullDefinitionFromTfl()>, %<SLibGetNullDefinitionFromTfl()>}
                %openfile declbuf
                %<dU>[%<arrayIdx>].sizeInBytes = ...
                  mr_%<mangleName>nonContOutputArray[%<port>][%<subIdx>].sizeInBytes;
                %<dU>[%<arrayIdx>].pCurrVal = ...
                  (char *)mr_%<mangleName>nonContOutputArray[%<port>][%<subIdx>].currVal;
                %closefile declbuf
                %assign codebuf = codebuf + declbuf
                %assign comma = ", "
                %assign arrayIdx = arrayIdx + 1
              %endforeach
            %else
              %assign sigSrc = nonContSig.SigSrc
              %assign startEl = nonContSig.StartEl
              %assign regLen = nonContSig.RegionLen
              %%
              %assign idNum = IDNUM(sigSrc)
              %assert (idNum[0] == "B")
              %assign bo = BlockOutputs.GlobalBlockOutput[idNum[1]]
              %assert (LibGetRecordWidth(bo) >= regLen)
              %assert (LibGetRecordWidth(bo) > startEl)
              %assert (bo.Invariant == "no")
              %% For NonContDerivSignal inside For Each subsystem, we need to
              %% index each For Each vargroup level by right index
              %if ISFIELD(nonContSig, "ForEachSSIterIndices")
                %assign ::UseConstantForVarGroupIdx = TLC_TRUE
                %assign ::VarGroupIndexVector = nonContSig.ForEachSSIterIndices
                %assign ::VarGroupIndexVectorSize = SIZE(::VarGroupIndexVector, 1)
                %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
              %endif
              %assign name = SLibGetBlockOutputIdentifierFromRecord(bo,NumSystems-1)
              %if ISFIELD(nonContSig, "ForEachSSIterIndices")
                %assign ::UseConstantForVarGroupIdx = TLC_FALSE
                %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
              %endif
              %assign opW  = (LibGetRecordWidth(bo) == 1) ? "" : "[%<startEl>]"
              %assign addr = "&%<name>%<opW>"
              %%
              %assign dType = SLibGetRecordContainerTypeName(bo)
              %assign sizeInBytes = "%<regLen>*sizeof(%<dType>)"
              %%
              %<comma>{ %<sizeInBytes>, (char*)(%<addr>), %<SLibGetNullDefinitionFromTfl()> }
              %assign comma = ", "
              %assign arrayIdx = arrayIdx + 1
            %endif
	  %endforeach
	};
        
        %<codebuf>
      %endif

      %% Do not put any more declarations after this line.      
      %if NumContStates > 0
	%<RTMSolverSet("SolverRelTol", "%<VariableStepOpts.RelTol>")>;       
      %endif
      %<RTMSet("StepSize", "%<VariableStepOpts.InitialStep>")>;
      %<RTMSolverSet("MinStepSize", "%<VariableStepOpts.MinStep>")>;
      %<RTMSolverSet("MaxNumMinSteps", "%<VariableStepOpts.MaxNumMinSteps>")>;
      %assign minStepErr = ISEQUAL(VariableStepOpts.MinStepViolatedError,"yes")
      %<RTMSolverSet("MinStepViolatedError", "%<minStepErr>")>;
      %<RTMSolverSet("MaxStepSize", "%<VariableStepOpts.MaxStep>")>;
      %<RTMSolverSet("SolverMaxOrder", "%<VariableStepOpts.MaxOrder>")>;

      %<RTMSolverSet("SolverRefineFactor", "%<VariableStepOpts.Refine>")>;
      %<RTMSet("OutputTimes", "%<outTimes>")>;
      %<RTMSet("NumOutputTimes", "%<nOutTimes>")>;
      %if VariableStepOpts.OutputTimesOption == "specified"
	%<RTMSet("OutputTimesOnly", "1")>;
      %else
	%<RTMSet("OutputTimesOnly", "0")>;
      %endif
      %<RTMSet("OutputTimesIndex", "0")>;
      %%
      %<RTMSet("ZCCacheNeedsReset", "%<SolverResetInfo.ZCCacheNeedsReset>")>;
      %<RTMSet("DerivCacheNeedsReset", "%<SolverResetInfo.DerivCacheNeedsReset>")>;
      %<RTMSet("NumNonContDerivSigInfos", "%<nDU>")>;
      %<RTMSet("NonContDerivSigInfos", "%<dU>")>;
      %%
    %endif %% SolverType == VariableStep
    %%
    %<RTMSet("SolverInfo", "&slvrInfo")>;
    %<RTMSolverSet("SolverName", "\"%<Solver>\"")>;
    %assign isVarStepSolver = ISEQUAL(SolverType,"VariableStep")
    %<RTMSolverSet("VariableStepSolver", "%<isVarStepSolver>")>;
    %assign consCheck = ISEQUAL(SolverConsistencyChecking,"yes")
    %<RTMSet("SolverConsistencyChecking", "%<consCheck>")>;
    %assign adapZc = ISEQUAL(SolverZeroCrossDetection,"Adaptive")
    %<RTMSet("SolverAdaptiveZcDetection", "%<adapZc>")>;
    %%	
    %assign robustReset = ISEQUAL(SolverResetMethod,"robust")
    %<RTMSet("SolverRobustResetMethod", "%<robustReset>")>;
    %assign updateJacobianAtReset = ISEQUAL(SolverUpdateJacobianAtReset,"yes")
    %if updateJacobianAtReset
      %<RTMuSet("SolverUpdateJacobianAtReset", "%<updateJacobianAtReset>")>;
    %endif %% _ssSetSolverUpdateJacobianAtReset(S,true)
    %%    
   %if SolverType == "VariableStep" && NumContStates > 0
     %<RTMSolverSet("AbsTolVector", "absTol")>;
     %<RTMSolverSet("AbsTolControlVector", "absTolControl")>;
     %<RTMSolverSet("SolverAbsTol_Obsolete", "absTol")>;
     %<RTMSolverSet("SolverAbsTolControl_Obsolete", "absTolControl")>;
   %endif
    
    %assign hasProj = ISEQUAL(ModelHasProjections, "yes") && (NumContStates > 0)	
    %assign isLinearlyImplicit = ISEQUAL(ModelIsLinearlyImplicit, "yes")	    
    %<RTMSet("SolverStateProjection", "%<hasProj>")>;
    %if hasProj || isLinearlyImplicit
      (void) %<LibGenMemFcnCall("memset", "(void *)&mdlMethods2", "0", ...
	"sizeof(mdlMethods2)")>;
      %<RTMSet("ModelMethods2", "&mdlMethods2")>;
      (void) %<LibGenMemFcnCall("memset", "(void *)&mdlMethods3", "0", ...
	"sizeof(mdlMethods3)")>;
      %<RTMSet("ModelMethods3", "&mdlMethods3")>;
      %if hasProj
        %<RTMSet("ModelProjection", "MdlProjection")>;
      %endif
      %if isLinearlyImplicit            
        %<RTMSet("MassMatrixType", "(ssMatrixType)%<ModelMassMatrixType>")>;
        %<RTMSet("MassMatrixNzMax", "%<ModelMassMatrixNzMax>")>;
        %<RTMSet("ModelMassMatrix", "MdlMassMatrix")>;
        %<RTMSet("ModelForcingFunction", "MdlForcingFunction")>;               
      %endif
      
    %endif
    %% 
    %<RTMSolverSet("SolverMassMatrixType", "(ssMatrixType)%<ModelMassMatrixType>")>;
    %<RTMSolverSet("SolverMassMatrixNzMax", "%<ModelMassMatrixNzMax>")>;       
    %%		
    %<RTMSet("ModelOutputs", "MdlOutputs")>;
    %<RTMSet("ModelLogData", "rt_UpdateTXYLogVars")>;
    %<RTMSet("ModelUpdate", "MdlUpdate")>;
    %if NumContStates > 0
      %%even for linearly-implicit systems, mdlDerivatives is required. 
      %<RTMSet("ModelDerivatives", "MdlDerivatives")>;
    %endif
    %if NumNonsampledZCs > 0      
      %<RTMSet("SolverZcSignalAttrib", "zcAttributes")>;
      %<RTMSet("SolverNumZcSignals", "%<ZCVectorlength>")>; 
      %<RTMSet("ModelZeroCrossings", "MdlZeroCrossings")>;
    %%solver diagnostic controls must be written after ssSetSolverInfo
      %<RTMSolverSet("SolverConsecutiveZCsStepRelTol", "%<VariableStepOpts.ConsecutiveZCsStepRelTol>")>;
      %<RTMSolverSet("SolverMaxConsecutiveZCs", "%<VariableStepOpts.MaxConsecutiveZCs>")>;     
      %<RTMSolverSet("SolverConsecutiveZCsError", "%<VariableStepOpts.ConsecutiveZCsError>")>;
      %<RTMSolverSet("SolverMaskedZcDiagnostic", "%<VariableStepOpts.MaskedZcDiagnostic>")>;
      %<RTMSolverSet("SolverIgnoredZcDiagnostic", "%<VariableStepOpts.IgnoredZcDiagnostic>")>;
      
      %if adapZc
        %<RTMSolverSet("SolverZcThreshold","%<VariableStepOpts.ZcThreshold>")>;
      %endif
    %endif
    
    %if NumContStates > 0 && isVarStepSolver
    %<RTMSolverSet("SolverMaxConsecutiveMinStep", "%<VariableStepOpts.MaxConsecutiveMinStep>")>;
    %<RTMSolverSet("SolverShapePreserveControl", "%<VariableStepOpts.ShapePreserveCtl>")>;
    %endif
    
    %<RTMSet("TNextTid","INT_MIN")>;
    %<RTMSet("TNext", LibRealNonFinite("-inf"))>;
    %<RTMSetSolverNeedsReset()>;
    %<RTMSet("NumNonsampledZCs", "%<NumNonsampledZCs>")>;
    %if NumContStates > 0
      %<RTMSet("ContStateDisabled", "contStatesDisabled")>;
    %endif
    
    %if NumContStates > 0 && isVarStepSolver
    %<RTMSolverSet("SolverMaxConsecutiveMinStep", "%<VariableStepOpts.MaxConsecutiveMinStep>")>;
    %endif
    
    %if isLinearlyImplicit
      /* global mass matrix */
      {
        int_T *ir = %<LibGetMassMatrixGlobalIr()>;
        int_T *jc = %<LibGetMassMatrixGlobalJc()>;
        real_T *pr = %<LibGetMassMatrixGlobalPr()>;
        %<RTMSet("MassMatrixIr", "ir")>;
        %<RTMSet("MassMatrixJc", "jc")>;
        %<RTMSet("MassMatrixPr", "pr")>;
        (void) %<LibGenMemFcnCall("memset", "(void *)ir", "0", ...
          "%<ModelMassMatrixNzMax>*sizeof(int_T)")>;
        (void) %<LibGenMemFcnCall("memset", "(void *)jc", "0", ...
          "(%<NumContStates>+1)*sizeof(int_T)")>;
        (void) %<LibGenMemFcnCall("memset", "(void *)pr", "0", ...
          "%<ModelMassMatrixNzMax>*sizeof(real_T)")>;      
      }
      %endif
  }

%endfunction %% SLibDumpModelRegRSimSetup


%% Function: SLibGetSysRanBCDWork ==============================================
%% Abstract:
%%   Returns the dwork entry for the system ran breadcrumb, given the dwork
%% index 
%%
%function SLibGetSysRanBCDWork(dwIdx) void
  %assign dwRec = ::CompiledModel.DWorks.DWork[dwIdx]
  %assign block = System[dwRec.SigSrc[0]].Block[dwRec.SigSrc[2]]
  
  %assert (block.Type == "SubSystem")

  %% Update FcnNonRollingDWork
  %createrecord optionalArgs { ...
    IsMode   TLC_FALSE ...
    StartIdx 0         ...
    DotName  ""        ...
    Name     SLibGetNameOfSubsysRanBCDWork() ...
  }
  %with FcnLoopInfo("", "", 0)
    %assign dwork = FcnNonRollingDWork(dwRec, dwIdx, SLibDWorkWidth(dwRec), optionalArgs)
  %endwith
  %return dwork
%endfunction %% SLibGetSysRanBCDWork


%% Function: SLibDumpExtModeReg ================================================
%% Abstract:
%%   Dump external mode registration:
%%    - Create the RTWExtModeInfo object
%%    - Initialize its fields
%%    - Put RTWExtModeInfo into the rtModel/SimStruct
%%
%function SLibDumpExtModeReg(bEmitReg, bEmitInit) Output
  %%
  %% Loop through all the systems and cache the active vector locations
  %% so that updown.c can determine if a given system is enabled.
  %%
  %if EXISTS("ExtMode") && ExtMode == 1
    {
      %% rtAlwaysEnabled is int8_T because the extmode active dwork is int8_T.
      %if bEmitInit
      static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE;
      %endif %% bEmitInit
      %assign sysRanDWorkLen  = SIZE(SubsystemRanBC.SysRanDWork, 1)
      
      %openfile buf      
      %% Populate the system ran breadcrumb pointers
      %assign contextSysVector = ::CompiledModel.SubsystemRanBC.ContextSysIdx
      %assign sysRanDWork      = SubsystemRanBC.SysRanDWork
      
      %% This is similar to what we do for the C-API (see capi.tlc)
      %foreach i = sysRanDWorkLen
	%assign dwIdx = sysRanDWork[contextSysVector[i]]
	%if (dwIdx > -1)
	  %assign dwRec = ::CompiledModel.DWorks.DWork[dwIdx]
	  %with System[GetBaseSystemIdx()]
	    %assign sysDWork = SLibGetSysRanBCDWork(dwIdx)
	  %endwith
	  %assert (dwRec.Name == "SubsysRanBC")
	  %assign  sigAddr = "&"+ sysDWork
          %if UsingMalloc
            ((const sysRanDType**)rteiGetSubSystemActiveVectorAddresses(%<RTMGet("RTWExtModeInfo")>))[%<i>] = (sysRanDType *)%<sigAddr>;
          %else
	    systemRan[%<i>] = (sysRanDType *)%<sigAddr>;
          %endif
	%else
          %if UsingMalloc
            ((const sysRanDType**)rteiGetSubSystemActiveVectorAddresses(%<RTMGet("RTWExtModeInfo")>))[%<i>] =  &rtAlwaysEnabled;
          %else
            systemRan[%<i>] = &rtAlwaysEnabled;
          %endif
	%endif
      %endforeach
      %closefile buf
      %if bEmitReg
      %if UsingMalloc
	RTWExtModeInfo *rt_ExtModeInfo = ...
	  (RTWExtModeInfo *) malloc(sizeof(RTWExtModeInfo));
	
	const sysRanDType **systemRan = (const sysRanDType **)malloc( %<sysRanDWorkLen> * sizeof(sysRanDType *) );
	
	%<RTMChkMemAndReturnIfErr("rt_ExtModeInfo")>;
	%<RTMChkMemAndReturnIfErr("systemRan")>;
	
      %else
	static RTWExtModeInfo rt_ExtModeInfo;
	static const sysRanDType *systemRan[%<sysRanDWorkLen>];
      %endif
      
      %assign amps  = UsingMalloc ? "" : "&"
      %assign rteiO = "%<amps>rt_ExtModeInfo"
      %<RTMSet("RTWExtModeInfo", "%<rteiO>")>;
      rteiSetSubSystemActiveVectorAddresses(%<rteiO>, systemRan);
      %endif %% bEmitReg
      %if bEmitInit
      %<buf>
      %endif %% bEmitInit

      %if bEmitInit
      %assign amps  = UsingMalloc ? "" : "&"
      %assign rteiO = "%<amps>rt_ExtModeInfo"
      rteiSetModelMappingInfoPtr(%<RTMGet("RTWExtModeInfo")>, ...
	&%<RTMGet("ModelMappingInfo")>);

      rteiSetChecksumsPtr(%<RTMGet("RTWExtModeInfo")>, ...
	%<RTMGet("Checksums")>);

      rteiSetTPtr(%<RTMGet("RTWExtModeInfo")>, %<RTMGet("TPtr")>);
      %endif %% bEmitInit
    }
  %endif
%endfunction %% SLibDumpExtModeReg


%% Function: SLibDumpModelChecksumReg ==========================================
%% Abstract:
%%   Dump the regisration of the model checksums.
%%
%function SLibDumpModelChecksumReg () Output
  %%
  %% Initialize Model checksum in sizes.
  %%
  %<RTMSetIdxed("ChecksumVal", 0, ModelChecksum[0])>;
  %<RTMSetIdxed("ChecksumVal", 1, ModelChecksum[1])>;
  %<RTMSetIdxed("ChecksumVal", 2, ModelChecksum[2])>;
  %<RTMSetIdxed("ChecksumVal", 3, ModelChecksum[3])>;
%endfunction


%% Function: FcnDumpSolverInfoObjectCreation ===================================
%% Abstract:
%%   Dump the creation of the solver info object that lives in the rtModel.
%%
%function FcnDumpSolverInfoObjectCreation(bEmitReg, bEmitInit) Output
  
  %if GenRTModel
    {
      /* Setup solver object */
      %if UsingMalloc
	RTWSolverInfo *rt_SolverInfo = ...
	  (RTWSolverInfo *) malloc(sizeof(RTWSolverInfo));

	%<RTMChkMemAndReturnIfErr("rt_SolverInfo")>;
      %else
        %%TCW: eventually migrate SolverInfo into rtModel for all formats
        %if !SLibIsERTCodeFormat()
          static RTWSolverInfo rt_SolverInfo;
        %endif
      %endif
      %assign amps = UsingMalloc ? "" : "&"
      %if !SLibIsERTCodeFormat() || UsingMalloc
        %<RTMSet("RTWSolverInfo", "%<amps>rt_SolverInfo")>;
      %endif

      %assign stptr = "&%<RTMGet("SimTimeStep")>"
      %<RTMSolverSet("SimTimeStepPtr", stptr)>;
      %assign tptr = "&%<RTMGet("TPtr")>"
      %<RTMSolverSet("TPtr", tptr)>;
      %if RTMStepSizeForTIDIsReqFcn(0)
        %assign sptr = "&%<RTMGet("StepSize0")>"
        %<RTMSolverSet("StepSizePtr", sptr)>;
      %elseif RTMStepSizeIsReqFcn()
        %assign sptr = "&%<RTMGet("StepSize")>"
        %<RTMSolverSet("StepSizePtr", sptr)>;
      %endif
      %if !SLibIsERTCodeFormat() || NumContStates > 0
        %assign dxptr = "&%<RTMGet("dX")>"
        %<RTMSolverSet("dXPtr", dxptr)>;
        %assign csptr = "&%<RTMGet("ContStates")>"
        %<RTMSolverSet("ContStatesPtr", csptr)>;
        %assign ncsptr = "&%<RTMGet("NumContStates")>"
        %<RTMSolverSet("NumContStatesPtr", ncsptr)>;
      %endif 
      %<RTMSolverSet("ErrorStatusPtr", GetRTMErrorStatusPtr())>;
      %if UsingMalloc
        %assign mmptr = "&%<RTMGet("RTWRTModelMethodsInfo")>"
        %<RTMSolverSet("ModelMethodsPtr", mmptr)>;
      %endif

      %if ModelIsLinearlyImplicit == "yes"
        %% Cannot get these from RTM -- not set, yet.
        %assign ir = "%<LibGetMassMatrixGlobalIr()>"  
        %assign jc = "%<LibGetMassMatrixGlobalJc()>"
        %assign pr = "%<LibGetMassMatrixGlobalPr()>"
        
        %<RTMSolverSet("SolverMassMatrixIr", ir)>;
        %<RTMSolverSet("SolverMassMatrixJc", jc)>;
        %<RTMSolverSet("SolverMassMatrixPr", pr)>;
      %endif
        
      %<RTMSolverSet("RTModelPtr", tSimStruct)>;
    }
  %endif
%endfunction %% FcnDumpSolverInfoObjectCreation


%% Function: LibCacheModelRegistration =========================================
%% Abstract:
%%   Cache the model registration code.  Supports these code formats
%%     o RealTime using SimStruc
%%
%function LibDumpModelRegistration(usingStatic) Output

  %assert(!UsingMalloc)
  %assert(!IsModelReferenceTarget())
  %%
  %% Solver info
  %%
  %<FcnDumpSolverInfoObjectCreation(usingStatic, TLC_TRUE)>\
  %%
  %% Timing engine
  %%
  %<SLibDumpTimingInfoRegistration()>\
  %%
  %% Initialize internal data
  %%
  %<SLibDumpModelDataInitialization()>\
  %%
  %%
  %% Model mapping info
  %%
  %<SLibDumpModelMappingInfo()>\
  
  %%
  %%
  %% Dump calls to model reference registration functions.
  %%
  %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
    ::CompiledModel.ModelReferenceBlocks : []
  %<CallModelrefBlockRegFcns(mdlRefBlks)>
  %%
  %% Model specifics
  %%

  /* Model specific registration */
  %assign rootSSreg = RTMSet("RootSS", RTMGetModelSS())
  %if !WHITE_SPACE(rootSSreg)
    %<rootSSreg>;
  %endif

  %assign verStr = RTMSet("Version", "SIMSTRUCT_VERSION_LEVEL2")
  %if !WHITE_SPACE(verStr)
    %<verStr>;
  %endif
  %<RTMSet("ModelName", "\"%<Name>\"")>;
  %<RTMSet("Path",      "\"%<Name>\"")>;
  
  %if isRSim && !isRSimWithSolverModule && StartTime < 0
    %assign errTxt = "Start time must be non-negative number: %<StartTime>"
    %<LibReportFatalError(errTxt)>    
  %endif
  %<RTMSet("TStart", StartTime)>;
  
  %if isRSimWithSolverModule %%assert !IsModelReferenceTarget
    %assign stopTime = StopTime
  %else
    %if ISINF(StopTime)
      %assign stopTime = "-1"
    %elseif !ISFINITE(StopTime)
      %assign errTxt = "Stop time must be 0.0, inf, or finite: %<StopTime>"
      %<LibReportFatalError(errTxt)>
    %else
      %if isRSim && StopTime < 0
        %assign errTxt = "Stop time must be non-negative number: %<StopTime>"
        %<LibReportFatalError(errTxt)>    
      %endif
      %assign stopTime = StopTime
    %endif
  %endif
  %<RTMSet("TFinal", stopTime)>;
  
  %if ::CompiledModel.SolverType == "FixedStep"
    %<RTMSet("StepSize", FixedStepOpts.FixedStep)>;
    %<RTMSolverSet("FixedStepSize", FixedStepOpts.FixedStep)>;
  %endif
  %%
  %if Solver == "ode14x"
    %<RTMSolverSet("SolverExtrapolationOrder", ...
      "%<FixedStepOpts.ExtrapolationOrder>")>;
    %<RTMSolverSet("SolverNumberNewtonIterations", ...
      "%<FixedStepOpts.NumberNewtonIterations>")>;

        %% dummy calls to TFL query to invoke proper rt_ function to be included
        %% rt_lu_real(W,nx,pivots);
        %createrecord FcnRec{Name "rt_lu"; NumArgs 3}
        %addtorecord FcnRec ArgList{Expr "W"; TypeId tSS_DOUBLE; IsPtr 1; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "nx"; TypeId tSS_INTEGER; IsPtr 0; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "pivots"; TypeId tSS_INT32; IsPtr 1; IsCplx 0; IsConst 0}
        %assign dummy_rt_lu = LibGenFcnCall(FcnRec, 0)

        %% rt_ForwardSubstitutionRR_Dbl(W,Delta,f1,nx,1,pivots,1);
        %createrecord FcnRec{Name "rt_ForwardSubstitution"; NumArgs 7}
        %addtorecord FcnRec ArgList{Expr "W"; TypeId tSS_DOUBLE; IsPtr 1; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "Delta"; TypeId tSS_DOUBLE; IsPtr 1; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "f1"; TypeId tSS_DOUBLE; IsPtr 1; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "nx"; TypeId tSS_INTEGER; IsPtr 0; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "1"; TypeId tSS_INTEGER; IsPtr 0; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "pivots"; TypeId tSS_INT32; IsPtr 1; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "1"; TypeId tSS_BOOLEAN; IsPtr 0; IsCplx 0; IsConst 0}
        %assign dummy_fs = LibGenFcnCall(FcnRec, 0)

        %% rt_BackwardSubstitutionRR_Dbl(W+nx*nx-1,f1+nx-1,Delta,nx,1,0);
        %createrecord FcnRec{Name "rt_BackwardSubstitution"; NumArgs 6}
        %addtorecord FcnRec ArgList{Expr "W+nx*nx-1"; TypeId tSS_DOUBLE; IsPtr 1; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "f1+nx-1"; TypeId tSS_DOUBLE; IsPtr 1; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "Delta"; TypeId tSS_DOUBLE; IsPtr 1; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "nx"; TypeId tSS_INTEGER; IsPtr 0; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "1"; TypeId tSS_INTEGER; IsPtr 0; IsCplx 0; IsConst 0}
        %addtorecord FcnRec ArgList{Expr "0"; TypeId tSS_BOOLEAN; IsPtr 0; IsCplx 0; IsConst 0}
        %assign dummy_bs = LibGenFcnCall(FcnRec, 0)

  %endif
  %%
  %% Data logging setup (tell rtwlog or any other entity what we need)
  %%
  %if MatFileLogging
    %<SLibDumpModelRegDataLoggingSetup(TLC_TRUE, TLC_TRUE)>
  %endif

  %if NumContStates > 0 || NumZCEvents > 0
    {
      static struct _ssStatesInfo2 statesInfo2;
      %<RTMSolverSet("StatesInfo2", "&statesInfo2")>;
    }  
  %endif
  
  %%
  %% Setup code for the RSim target.
  %%
  %if isRSimWithSolverModule %%assert !IsModelReferenceTarget
    %<SLibDumpModelRegRSimSetup()>
  %endif

  %% PrevZcSigState
  %if NumZCEvents > 0 && !LibPrevZCStatesStructIsEmpty()
    %<LibDumpModelInitializePrevZCStates(TLC_TRUE, TLC_TRUE)>
  %endif

  %<SLibDumpModelChecksumReg()>
  %%
  %% Dump external mode registration
  %%
  %<SLibDumpExtModeReg(TLC_TRUE, TLC_TRUE)>
  %%
  %% Cache function pointers, if necessary
  %%
  %if UsingMalloc

    %<RTMModelMthsSet("mdlInitializeSizes",       "MdlInitializeSizes")>;
    %<RTMModelMthsSet("mdlInitializeSampleTimes", "MdlInitializeSampleTimes")>;
    %<RTMModelMthsSet("mdlStart",                 "MdlStart")>;
    %<RTMModelMthsSet("mdlOutputs",               "MdlOutputs")>;
    %<RTMModelMthsSet("mdlUpdate",                "MdlUpdate")>;
    %if NumContStates > 0
      %<RTMModelMthsSet("mdlDerivatives", "MdlDerivatives")>;
      %<RTMModelMthsSet("mdlProjection",  "MdlProjection")>;
      %if ModelIsLinearlyImplicit == "yes"
        %<RTMModelMthsSet("mdlMassMatrix",      "MdlMassMatrix")>;
        %<RTMModelMthsSet("mdlForcingFunction", "MdlForcingFunction")>;
      %else           
        %<RTMModelMthsSet("mdlMassMatrix",      SLibGetNullDefinitionFromTfl())>;
        %<RTMModelMthsSet("mdlForcingFunction", SLibGetNullDefinitionFromTfl())>;
      %endif        
    %else
      %<RTMModelMthsSet("mdlDerivatives", SLibGetNullDefinitionFromTfl())>;
      %<RTMModelMthsSet("mdlProjection",  SLibGetNullDefinitionFromTfl())>;
      %<RTMModelMthsSet("mdlMassMatrix",      SLibGetNullDefinitionFromTfl())>;
      %<RTMModelMthsSet("mdlForcingFunction", SLibGetNullDefinitionFromTfl())>;
    %endif
    %<RTMModelMthsSet("mdlTerminate", "MdlTerminate")>;
    %if GenRTModel
      %<RTMModelMthsSet("RTModelPtr", tSimStruct)>;
    %endif
  %endif
%endfunction %% LibDumpModelRegistration

%% Function: FcnNeedsToSetBlkInfo2Ptr
%% Abstract:
%%   returns true if a SimStruct needs ssBlkInfo2, which currently holds
%%   rtwSfcnInfo and portInfo2
%%
%function FcnNeedsToSetBlkInfo2Ptr() void
  %return FcnNeedsToSetRTWSfcnInfo() || FcnNeedsToSetPortInfo2Ptr()
%endfunction

%function FcnNeedsToSetPortInfo2Ptr() void
  %return FcnBlockHasVarDimsInput() || FcnBlockHasVarDimsOutput()
%endfunction

%function FcnNeedsToSetRTWSfcnInfo() void
  %return (CodeFormat == "S-Function") || GenRTModel
%endfunction

%% Function: FcnSetBlkInfo2
%% Abstract:
%%   declare/allocate blkInfo2, and hook it up with the SimStruct.
%%
%function FcnSetBlkInfo2(childSS, childIdx) void
  %openfile  tmpBuffer
  {
  %if !UsingMalloc || SLibIsERTCodeFormat()
    %if !SLibIsERTCodeFormat()
      static struct _ssBlkInfo2 _blkInfo2;
      struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
      ssSetBlkInfo2Ptr(%<childSS>, blkInfo2);
    %else
      %assign nonInlSfcns = "%<RTMGet("NonInlinedSFcns")>"
      ssSetBlkInfo2Ptr(%<childSS>, &%<nonInlSfcns>.blkInfo2[%<childIdx>]);
    %endif
  %else
    struct _ssBlkInfo2 *blkInfo2 = ...
      (struct _ssBlkInfo2 *) malloc(sizeof(struct _ssBlkInfo2));
    %<RTMChkMemAndReturnIfErr("blkInfo2")>;
    ssSetBlkInfo2Ptr(%<childSS>, blkInfo2);
  %endif
  }
  %closefile tmpBuffer
  
  %return tmpBuffer
%endfunction

%% Function: FcnSetPortInfo2
%% Abstract:
%%   declare/allocate portInfo2, and hook it up with the SimStruct.
%%
%function FcnSetPortInfo2(childSS, childIdx) void
  %openfile  tmpBuffer
  %if !UsingMalloc
    %if !SLibIsERTCodeFormat()
      {
        static struct _ssPortInfo2 _portInfo2;
        struct _ssPortInfo2 *portInfo2 = &_portInfo2;
        _ssSetBlkInfo2PortInfo2Ptr(%<childSS>, portInfo2);
      }
    %else
      %assign nonInlSfcns = "%<RTMGet("NonInlinedSFcns")>"
      _ssSetBlkInfo2PortInfo2Ptr(%<childSS>, &%<nonInlSfcns>.inputOutputPortInfo2[%<childIdx>]);
    %endif
  %else
    {
      struct _ssPortInfo2 *portInfo2 = ...
        (struct _ssPortInfo2 *) malloc(sizeof(struct _ssPortInfo2));
      %<RTMChkMemAndReturnIfErr("portInfo2")>;
      _ssSetBlkInfo2PortInfo2Ptr(%<childSS>, portInfo2);
    }
  %endif
  %closefile tmpBuffer
  
  %return tmpBuffer
%endfunction

%% Function: FcnSetupSFcnRTWInfo ===============================================
%% Abstract:
%%
%function FcnSetupSFcnRTWInfo() Output
  {  
    %if UsingMalloc && !SLibIsERTCodeFormat()
      RTWSfcnInfo *sfcnInfo = (RTWSfcnInfo *) ...
	malloc(sizeof(RTWSfcnInfo));
      %<RTMChkMemAndReturnIfErr("sfcnInfo")>;
    %else
      %if SLibIsERTCodeFormat()
        RTWSfcnInfo *sfcnInfo = &%<RTMGet("NonInlinedSFcns")>.sfcnInfo;
      %else
        static RTWSfcnInfo _sfcnInfo;
        RTWSfcnInfo *sfcnInfo = &_sfcnInfo;
      %endif
    %endif

    %<RTMSet("RTWSfcnInfo", "sfcnInfo")>;

    rtssSetErrorStatusPtr(sfcnInfo, %<GetRTMErrorStatusPtr()>);
    rtssSetNumRootSampTimesPtr(sfcnInfo, &%<RTMGet("NumSampleTimes")>);
    %foreach idx = NumSampleTimes 
      %<RTMGet("NonInlinedSFcns")>.taskTimePtrs[%<idx>] = &(%<RTMGet("TPtr")>[%<idx>]);
    %endforeach
    rtssSetTPtrPtr(sfcnInfo,%<RTMGet("NonInlinedSFcns")>.taskTimePtrs);
    rtssSetTStartPtr(sfcnInfo,        &%<RTMGet("TStart")>);
    %if RTMTFinalIsReqFcn()
      rtssSetTFinalPtr(sfcnInfo,        &%<RTMGet("TFinal")>);
    %endif
    rtssSetTimeOfLastOutputPtr(sfcnInfo, ...
      &%<RTMGet("TimeOfLastOutput")>);
    rtssSetStepSizePtr(sfcnInfo,      &%<RTMGet("StepSize")>);
    rtssSetStopRequestedPtr(sfcnInfo, &%<RTMGetStopRequested()>);
    rtssSetDerivCacheNeedsResetPtr(sfcnInfo, ...
      &%<RTMGet("DerivCacheNeedsReset")>);
    rtssSetZCCacheNeedsResetPtr(sfcnInfo, ...
      &%<RTMGet("ZCCacheNeedsReset")>);
    rtssSetBlkStateChangePtr(sfcnInfo, ...
      &%<RTMGet("BlkStateChangeFlag")>);
    rtssSetSampleHitsPtr(sfcnInfo,    &%<RTMGet("SampleHitPtr")>);
    rtssSetPerTaskSampleHitsPtr(sfcnInfo, ...
      &%<RTMGet("PerTaskSampleHitsPtr")>);
    rtssSetSimModePtr(sfcnInfo,  &%<RTMGet("SimMode")>);
    %if SLibIsERTCodeFormat()
      rtssSetSolverInfoPtr(sfcnInfo,  &%<RTMGet("RTWSolverInfoPtr")>);
    %else
      rtssSetSolverInfoPtr(sfcnInfo,  &%<RTMGet("RTWSolverInfo")>);
    %endif
  }
%endfunction %% FcnSetupSFcnRTWInfo

%% Function: SLibSetupTimingInfoForChildSfcn() =================================
%%
%function SLibSetupTimingInfoForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %openfile retBuf
  /* timing info */
  %assign numSfcnSampleTimes = SIZE(TID, 1)
  %if usingStatic
    static time_T sfcnPeriod[%<numSfcnSampleTimes>];
    static time_T sfcnOffset[%<numSfcnSampleTimes>];
    static int_T  sfcnTsMap[%<numSfcnSampleTimes>];
  %elseif SLibIsERTCodeFormat()
    %assign SfcnIdx = "%<nonInlSfcns>.Sfcn%<childIdx>"
    time_T *sfcnPeriod = %<SfcnIdx>.sfcnPeriod;
    time_T *sfcnOffset = %<SfcnIdx>.sfcnOffset;
    int_T *sfcnTsMap = %<SfcnIdx>.sfcnTsMap;
  %else
    time_T *sfcnPeriod;
    time_T *sfcnOffset;
    int_T *sfcnTsMap;
    
    sfcnPeriod = (time_T *) ...
      malloc(%<numSfcnSampleTimes> * sizeof(time_T));
    %<RTMChkMemAndReturnIfErr("sfcnPeriod")>;
    sfcnOffset = (time_T *) ...
      malloc(%<numSfcnSampleTimes> * sizeof(time_T));
    %<RTMChkMemAndReturnIfErr("sfcnOffset")>;
    sfcnTsMap = (int_T  *) ...
      malloc(%<numSfcnSampleTimes> * sizeof(int_T ));
    %<RTMChkMemAndReturnIfErr("sfcnTsMap")>;
  %endif
  
  (void) %<LibGenMemFcnCall("memset", "(void*)sfcnPeriod", "0", ...
    "sizeof(time_T)*%<numSfcnSampleTimes>")>;
  (void) %<LibGenMemFcnCall("memset", "(void*)sfcnOffset", "0", ...
    "sizeof(time_T)*%<numSfcnSampleTimes>")>;
  %%
  ssSetSampleTimePtr(%<s>, &sfcnPeriod[0]);
  ssSetOffsetTimePtr(%<s>, &sfcnOffset[0]);
  %<underScore>ssSetSampleTimeTaskIDPtr(%<s>, sfcnTsMap);
  %closefile retBuf

  %return retBuf
%endfunction

%% Function: SLibSetupMdlInfoForChildSfcn() ====================================
%%
%function SLibSetupMdlInfoForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) void

  %assign prefix = "/* Set up the mdlInfo pointer */\n"
  %assign postfix = ""
    
  %if (CodeFormat == "S-Function")
    %assign prefix = prefix + "# ifdef USE_RTMODEL\n"
    %assign postfix = "# else\n" + ...
      "%<underScore>ssSetMdlInfoPtr(%<s>, %<RTMGet("MdlInfoPtr")>);\n" + ...
      "# endif /* USE_RTMODEL */\n"
  %else
    %if GenRTModel
      %if IsModelReferenceForASimstructBasedTarget()
        %assign postfix = ...
          "%<underScore>ssSetMdlInfoPtr(%<s>, ssGetMdlInfoPtr(%<tMdlRefSfcnS>));\n"
      %endif
    %else
      %assign postfix = ...
        "%<underScore>ssSetMdlInfoPtr(%<s>, %<RTMGet("MdlInfoPtr")>);\n"
    %endif
  %endif

  %assign setBlkInfo2Str = ""
  %assign setPortInfo2Str = ""
  %assign setSfcnInfoStr = ""
  %%%
  %%% these three strings set up all the fields that bridge the
  %%% gap between a child S-function's SimStruct and the rtModel.

  %if FcnNeedsToSetBlkInfo2Ptr()
    
    %assign setBlkInfo2Str = FcnSetBlkInfo2(s, childIdx)
    
    %if FcnNeedsToSetPortInfo2Ptr()
      %assign setPortInfo2Str = FcnSetPortInfo2(s, childIdx)
    %endif
    
    %if FcnNeedsToSetRTWSfcnInfo()
      %assign setSfcnInfoStr = "ssSetRTWSfcnInfo(%<s>, %<RTMGet("RTWSfcnInfo")>);\n"
    %endif
    
  %endif

  %return prefix + setBlkInfo2Str + setPortInfo2Str + ...
    setSfcnInfoStr + postfix
%endfunction
%% Function: SLibAllocateStatesInfo2MemForChildSfcn ===============================
%%
%function SLibAllocateStatesInfo2MemForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %openfile retBuf  
  %assign numContStates = ContStates[0]
  %if ParamSettings.FunctionLevel == 2
    /* Allocate memory for states auxilliary information */
    {
      %if usingStatic
	static struct _ssStatesInfo2 statesInfo2;
	ssSetStatesInfo2(%<s>, &statesInfo2);
        %if SolverType == "VariableStep" && numContStates > 0
          ssSetAbsTolVector(%<s>, %<RTMGet("AbsTolVector")> + %<ContStates[2]>);                    
          ssSetAbsTolControlVector(%<s>, %<RTMGet("AbsTolControlVector")> + %<ContStates[2]>);
        %endif
      %elseif SLibIsERTCodeFormat()
	ssSetStatesInfo2(%<s>, &%<nonInlSfcns>.statesInfo2[%<childIdx>]);
      %else
	struct _ssStatesInfo2 *statesInfo2 = ...
	  (struct _ssStatesInfo2 *) ...
	  malloc(sizeof(struct _ssStatesInfo2));
	%<RTMChkMemAndReturnIfErr("statesInfo2")>;
	ssSetStatesInfo2(%<s>, statesInfo2);
        %if SolverType == "VariableStep" && numContStates > 0
          ssSetAbsTolVector(%<s>, %<RTMGet("AbsTolVector")> + %<ContStates[2]>);                    
          ssSetAbsTolControlVector(%<s>, %<RTMGet("AbsTolControlVector")> + %<ContStates[2]>);
        %endif
      %endif
    }
  %endif
  %closefile retBuf
  %return retBuf
%endfunction

%% Function: SLibAllocateMethods2MemForChildSfcn ===============================
%%
%function SLibAllocateMethods2MemForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %openfile retBuf
  %if ParamSettings.FunctionLevel == 2
    /* Allocate memory of model methods 2 */
    {
      %if usingStatic
	static struct _ssSFcnModelMethods2 methods2;
	ssSetModelMethods2(%<s>, &methods2);
      %elseif SLibIsERTCodeFormat()
	ssSetModelMethods2(%<s>, &%<nonInlSfcns>.methods2[%<childIdx>]);
      %else
	struct _ssSFcnModelMethods2 *methods2 = ...
	  (struct _ssSFcnModelMethods2 *) ...
	  malloc(sizeof(struct _ssSFcnModelMethods2));
	%<RTMChkMemAndReturnIfErr("methods2")>;
	ssSetModelMethods2(%<s>, methods2);
      %endif
    }
    /* Allocate memory of model methods 3 */
    {
      %if usingStatic
	static struct _ssSFcnModelMethods3 methods3;
	ssSetModelMethods3(%<s>, &methods3);
      %elseif SLibIsERTCodeFormat()
	ssSetModelMethods3(%<s>, &%<nonInlSfcns>.methods3[%<childIdx>]);
      %else
	struct _ssSFcnModelMethods3 *methods3 = ...
	  (struct _ssSFcnModelMethods3 *) ...
	  malloc(sizeof(struct _ssSFcnModelMethods3));
	%<RTMChkMemAndReturnIfErr("methods3")>;
	ssSetModelMethods3(%<s>, methods3);
      %endif
    }    
  %endif
  %closefile retBuf
  %return retBuf
%endfunction

%% Function: SLibSetupInputsForChildSfcn  ======================================
%%
%function SLibSetupInputsForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %assign thisBlock = ChildSFunctionList[childIdx]
  %openfile retBuf
  %if (CodeFormat == "S-Function" && UsingMalloc && ...
    ParamSettings.FunctionLevel == 2) ||            ...
    IsModelReferenceSimTarget()
    %% Always setup function pointer for _mid.h since level 2
    %% child s-f dll will use it.
    ssSetRegNumInputPortsFcn(%<s>, ...
      (_ssRegNumInputPortsFcn)RegNumInputPorts);
    ssSetRegNumInputPortsFcnArg(%<s>,%<s>);
  %endif
  %if NumDataInputPorts > 0
    %assign SfcnIdx = "%<nonInlSfcns>.Sfcn%<childIdx>"

    /* inputs */
    %switch ParamSettings.FunctionLevel
      %case 1
	%%
	%% Level 1 S-function
	%%
	%assign uWidth = LibGetRecordWidth(DataInputPort)
	%assign inputsContiguous = ...
	  (ParamSettings.InputContiguous == "yes")
	%assign usingUPtrs = (ParamSettings.UsingUPtrs == "yes")
	%if usingUPtrs
	  {
	    %%
	    %% Using UPtrs
	    %%
	    %if usingStatic
	      static real_T const *sfcnUPtrs[%<uWidth>];
	    %elseif SLibIsERTCodeFormat()
	      real_T const **sfcnUPtrs = \
	      (real_T const **) &%<SfcnIdx>.UPtrs;
	    %else
	      real_T const **sfcnUPtrs =
	      (real_T const **) malloc(%<uWidth> * sizeof(real_T *));
	      %<RTMChkMemAndReturnIfErr("sfcnUPtrs")>;
	    %endif
	    %assign rollVars = ["U"]
	    %roll idx = RollRegions, lcv = RollThreshold, thisBlock, ...
	      "Roller", rollVars
	      %assign lhs = LibGetIndexedElement("sfcnUPtrs", ...
		uWidth, lcv, idx)
	      %<lhs> = %<LibBlockInputSignalAddr(0, "", lcv, idx)>;
	    %endroll
	    %<underScore>ssSetUPtrs(%<s>, &sfcnUPtrs[0]);
	  }
	%elseif !inputsContiguous
	  %assign errTxt = "Level 1 S-function not using uPtrs and " ...
	    "inputs are not contiguous"
	  %<LibBlockReportFatalError(thisBlock,errTxt)>
	%else
	  %%
	  %% Not using uPtrs and inputs are contiguous.
	  %% Set pointer to start of input signal.
	  %%
	  %<underScore>ssSetU(%<s>, (void *)...
	    %<LibBlockInputSignalAddr(0,"","",0)>);
	%endif
	%break
      %case 2
	%%
	%% Level 2 S-Function
	%%
	{
	  %%
	  %% InputPortInfo
	  %%
	  %if usingStatic
	    static struct _ssPortInputs inputPortInfo[%<NumDataInputPorts>];
	    _ssSetNumInputPorts(%<s>, %<NumDataInputPorts>);
	    ssSetPortInfoForInputs(%<s>, &inputPortInfo[0]);
	  %elseif SLibIsERTCodeFormat()
	    _ssSetNumInputPorts(%<s>, %<NumDataInputPorts>);
	    ssSetPortInfoForInputs(%<s>, &%<SfcnIdx>.inputPortInfo[0]);
	  %else
	    struct _ssPortInputs *inputPortInfo =
	    (struct _ssPortInputs *) calloc(%<NumDataInputPorts>, ...
	      sizeof(struct _ssPortInputs));
	    %<RTMChkMemAndReturnIfErr("inputPortInfo")>;
	    _ssSetNumInputPorts(%<s>, %<NumDataInputPorts>);
	    ssSetPortInfoForInputs(%<s>, &inputPortInfo[0]);
	  %endif
	  %%
	  %% Setup the following for each input port:
	  %%
	  %%   o) InputSignal or
	  %%      InputSignalPtrs
	  %%
	  %%   o) InputPortRequiredContiguous
	  %%
	  %%   o) InputPort dimensional data memory and one of
	  %%      InputPortVectorDimension (info) or
	  %%      InputPortMatrixDimensions (info)
	  %%
          %if FcnBlockHasVarDimsInput()
            %assign num_vardims_input = FcnBlockNumVarDimsInput()
            %if usingStatic
              {
                static struct _ssInPortVarDims inputPortCurrentDims[%<num_vardims_input>];
                _ssSetPortInfo2ForInputs(%<s>, &inputPortCurrentDims[0]);
              }
            %elseif SLibIsERTCodeFormat()
                _ssSetPortInfo2ForInputs(%<s>, &%<SfcnIdx>.inputPortCurrentDims[0]);                
            %else
              {
                struct _ssInPortVarDims *inputPortCurrentDims =
                (struct _ssInPortVarDims *) calloc(%<num_vardims_input>, ...
                  sizeof(struct _ssInPortVarDims));
                %<RTMChkMemAndReturnIfErr("inputPortCurrentDims")>;
                _ssSetPortInfo2ForInputs(%<s>, &inputPortCurrentDims[0]);
              }
            %endif
          %endif
          
          %assign vipIdx = 0
          %% vipIdx == 0 means the first variable-dimension input port
          %% vipIdx == 1 means the second variable-dimension input port
          %% ....
            
          %foreach ipIdx = NumDataInputPorts
	    
	    /* port %<ipIdx> */
	    {
	      %assign ip    = DataInputPort[ipIdx]
	      %assign dtype = SLibGetRecordDataTypeName(ip,"")
	      %assign width = LibBlockInputSignalWidth(ipIdx)
	      %assign dims  = LibBlockInputSignalDimensions(ipIdx)
	      %assign nDims = LibBlockInputSignalNumDimensions(ipIdx)
	      %if ParamSettings.UsingUPtrs[ipIdx] == "yes"
		%if usingStatic
		  static %<dtype> const *sfcnUPtrs[%<width>];
		  %if %<nDims> >= matrixDimensionThreshhold
		    static int_T dimensions[%<nDims>];
		  %endif
		%elseif SLibIsERTCodeFormat()
		  %<dtype> const **sfcnUPtrs = \
		  (%<dtype> const **) &%<SfcnIdx>.UPtrs%<ipIdx>;
		  %if nDims >= matrixDimensionThreshhold
		    int_T *dimensions = (int_T *)  &%<SfcnIdx>.iDims%<ipIdx>;
		  %endif
		%else
		  %if %<nDims> >= matrixDimensionThreshhold
		    %if CodeFormat == "S-Function"
		      #if defined(MATLAB_MEX_FILE)
		      /* If the child S-function defines its port dimensions
		      * as DYNAMIC_DIMENSION Simlulink will free this memory
		      * and reallocate it. Therefore it must be allocated
		      * using utMalloc .
		      */
		      int_T *dimensions = (int_T *) ...
			utMalloc(%<nDims> * sizeof(int_T));
		      #else
		      int_T *dimensions = (int_T *) ...
			malloc(%<nDims> * sizeof(int_T));
		      #endif
		    %else
		      int_T *dimensions = (int_T *) ...
			malloc(%<nDims> * sizeof(int_T));
		    %endif %% CodeFormat == "S-Function"
		  %endif %% nDims >= matrixDimensionThreshhold
		  %<dtype> const **sfcnUPtrs = (%<dtype> const **)
		  malloc(%<width> * sizeof(%<dtype> *));
		  %if %<nDims> >= matrixDimensionThreshhold
		    %<RTMChkMemAndReturnIfErr("dimensions")>;
		  %endif
		  %<RTMChkMemAndReturnIfErr("sfcnUPtrs")>;
		%endif
		%if CodeFormat == "S-Function"
		  %foreach sigIdx = width
		    %assign rec = SLibGetSourceMapInfo(ip, sigIdx)
		    %if rec.mapSrc == "U"
		      %% When setting up Input Pointers for child
		      %% s-functions of a parent model being generated as
		      %% an s-function,
		      %% need to use the Input Ptrs already
		      %% setup for the parent.  Otherwise, they will get
		      %% setup by getting the address of the first Input
		      %% Ptr of the parent using
		      %% using the External Inputs structure names(via
		      %% LibBlockInputSignal) to walk through the
		      %% ptrs for
		      %% all the child s-functions.  That is incorrect
		      %% since the inputs ptrs are NOT contiguous in
		      %% memory for the parent model, but are setup
		      %% according to their ports.
		      %assign u = RTMGetIdxed("InputPortSignalPtrs", ...
			rec.mapIdx) + "[%<rec.signalOffset>]"
		      sfcnUPtrs[%<sigIdx>] = (%<dtype> const *) %<u>;
		    %else
		      %assign u = ...
			LibBlockInputSignalAddr(ipIdx, "", "", sigIdx)
		      sfcnUPtrs[%<sigIdx>] = (%<dtype> const *) %<u>;
		    %endif
		  %endforeach %% sigIdx = width
		%else
		  %assign rollVars = ["u%<ipIdx>"]
		  %with ip
		    %assign rollRegion = RollRegions
		  %endwith
		  %roll idx = rollRegion, lcv = RollThreshold, ...
		    thisBlock, "Roller", rollVars
		    %assign lhs = LibGetIndexedElement("sfcnUPtrs", ...
		      width,lcv,idx)
		    %<lhs> = %<LibBlockInputSignalAddr(ipIdx,"",lcv,idx)>;
		  %endroll
		%endif
		%<underScore>ssSetInputPortSignalPtrs(%<s>, %<ipIdx>, ...
		  (InputPtrsType)&sfcnUPtrs[0]);
	      %else %% Level 2, not using uPtrs
		%if ParamSettings.InputContiguous[ipIdx] == "yes"
		  %if %<nDims> >= matrixDimensionThreshhold
		    %if usingStatic
		      %if %<nDims> >= matrixDimensionThreshhold
			static int_T dimensions[%<nDims>];
		      %endif
		    %elseif SLibIsERTCodeFormat()
		      %if nDims >= matrixDimensionThreshhold
			int_T *dimensions = \
			(int_T *)  &%<SfcnIdx>.iDims%<ipIdx>;
		      %endif
		    %else
		      %if CodeFormat == "S-Function"
			#if defined(MATLAB_MEX_FILE)
			/* If the child S-function defines its port dimensions
			* as DYNAMIC_DIMENSION Simlulink will free this memory
			* and reallocate it. Therefore it must be allocated
			* using utMalloc.
			*/
			int_T *dimensions = (int_T *) ...
			  utMalloc(%<nDims> * sizeof(int_T));
			#else
			int_T *dimensions = (int_T *) ...
			  malloc(%<nDims> * sizeof(int_T));
			#endif
		      %else
			int_T *dimensions = (int_T *) ...
			  malloc(%<nDims> * sizeof(int_T));
		      %endif
		      %<RTMChkMemAndReturnIfErr("dimensions")>;
		    %endif
		  %endif
		  %assign sigAddr = LibBlockInputSignalAddr(ipIdx,"","",0)
		  ssSetInputPortRequiredContiguous(%<s>, %<ipIdx>, 1);
		  %<underScore>ssSetInputPortSignal(%<s>, %<ipIdx>, ...
		    %<sigAddr>);
		%else
		  %assign errTxt = "Level 2 S-function not using " ...
		    "uPtrs and inputs are not contiguous"
		  %<LibBlockReportFatalError(thisBlock,errTxt)>
		%endif
	      %endif
	      %% Set dimensional info values
	      %if %<nDims> >= matrixDimensionThreshhold
		%if %<nDims> >= matrixDimensionThreshhold
                  %foreach Idx = nDims
                    dimensions[%<Idx>] = %<dims[Idx]>;
                  %endforeach
		%endif
		_ssSetInputPortDimensionsPtr(%<s>, %<ipIdx>, dimensions);
	      %endif
	      _ssSetInputPortNumDimensions(%<s>, %<ipIdx>, %<nDims>);
	      ssSetInputPortWidth(%<s>, %<ipIdx>, %<width>);
              %if LibGetIsInputPortVarDims(ipIdx)
                %assign dwork_var = SLibGetCurrentInputPortDimensions(ipIdx, 0)
                _ssSetInputPortVariableDimsPtr(%<s>, ...
                  %<vipIdx>, &%<dwork_var>);
                %assign vipIdx = vipIdx + 1
              %endif
	    }
	  %endforeach
	}
	%break
    %endswitch
  %endif  %% NumDataInputPorts > 0
  
  %closefile retBuf
  %return retBuf
%endfunction

%% Function: SLibSetupOutputsForChildSfcn ======================================
%%
%function SLibSetupOutputsForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %assign thisBlock = ChildSFunctionList[childIdx]

  %openfile retBuf
  %if (CodeFormat == "S-Function" && UsingMalloc && ...
    ParamSettings.FunctionLevel == 2) ||            ...
    IsModelReferenceSimTarget()
    %% Always setup function pointer for _mid.h since level 2
    %% child s-f dll will use it.
    ssSetRegNumOutputPortsFcn(%<s>, ...
      (_ssRegNumOutputPortsFcn)RegNumOutputPorts);
    ssSetRegNumOutputPortsFcnArg(%<s>,%<s>);
  %endif
  
  %if NumDataOutputPorts > 0
    %assign SfcnIdx = "%<nonInlSfcns>.Sfcn%<childIdx>"

    /* outputs */
    %switch ParamSettings.FunctionLevel
      %case 1
	%assign op = FcnGetOutputPortRecord(0)
	%assign idNum = IDNUM(op.SignalSrc[0])
	%if idNum[0] == "F" %%FcnCall
	  %<underScore>ssSetY(%<s>, %<SLibGetNullDefinitionFromTfl()>);
	%else
	  %assign dt = LibBlockOutputSignalDataTypeName(0, "")
	  %<underScore>ssSetY(%<s>, ...
	    ((%<dt> *) %<LibBlockOutputSignalAddr(0,"","",0)>));
	%endif
	%break
	
      %case 2
	{
	  %if usingStatic
	    static struct _ssPortOutputs outputPortInfo[%<NumDataOutputPorts>];
	    ssSetPortInfoForOutputs(%<s>, &outputPortInfo[0]);
	  %elseif SLibIsERTCodeFormat()
	    ssSetPortInfoForOutputs(%<s>, &%<SfcnIdx>.outputPortInfo[0]);
	  %else
	    struct _ssPortOutputs *outputPortInfo = ...
	      (struct _ssPortOutputs *)
	    calloc(%<NumDataOutputPorts>, ...
	      sizeof(struct _ssPortOutputs));
	    %<RTMChkMemAndReturnIfErr("outputPortInfo")>;
	    ssSetPortInfoForOutputs(%<s>, &outputPortInfo[0]);
	  %endif
	  _ssSetNumOutputPorts(%<s>, %<NumDataOutputPorts>);

          %if FcnBlockHasVarDimsOutput()
            %assign num_vardims_output = FcnBlockNumVarDimsOutput()
            %if usingStatic
              {
                static struct _ssOutPortVarDims outputPortCurrentDims[%<num_vardims_output>];
                _ssSetPortInfo2ForOutputs(%<s>, &outputPortCurrentDims[0]);
              }
            %elseif SLibIsERTCodeFormat()
                _ssSetPortInfo2ForOutputs(%<s>, &%<SfcnIdx>.outputPortCurrentDims[0]);                
            %else
              {
                struct _ssOutPortVarDims*   outputPortCurrentDims =
                (struct _ssOutPortVarDims *) calloc(%<num_vardims_output>,
                sizeof(struct _ssOutPortVarDims));
                %<RTMChkMemAndReturnIfErr("outputPortCurrentDims")>;
                _ssSetPortInfo2ForOutputs(%<s>, &outputPortCurrentDims[0]);
              }
            %endif
          %endif
          
          %assign vopIdx = 0
          %% vopIdx tells that this output port is the n'th variable-dimension
          %% output port
          
	  %foreach opIdx = NumDataOutputPorts
	    /* port %<opIdx> */
	    {
	      %assign oWidth = LibBlockOutputSignalWidth(opIdx)
	      %assign oNumDims = LibBlockOutputSignalNumDimensions(opIdx)
	      %assign oDims    = LibBlockOutputSignalDimensions(opIdx)
	      %if %<oNumDims> >= matrixDimensionThreshhold
		%if usingStatic
		  %if %<oNumDims> >= matrixDimensionThreshhold
		    static int_T dimensions[%<oNumDims>];
		  %endif
		%elseif SLibIsERTCodeFormat()
		  %if oNumDims >= matrixDimensionThreshhold
		    int_T *dimensions = (int_T *)  &%<SfcnIdx>.oDims%<opIdx>;
		  %endif
		%else
		  %if CodeFormat == "S-Function"
		    #if defined(MATLAB_MEX_FILE)
		    /* If the child S-function defines its dimensions as
		    * DYNAMIC_DIMENSION Simlulink will free this memory
		    * and reallocate it. Therefor it must be allocated
		    * using utMalloc .
		    */
		    int_T *dimensions = (int_T *) ...
		      utMalloc(%<oNumDims> * sizeof(int_T));
		    #else
		    int_T *dimensions = (int_T *) ...
		      malloc(%<oNumDims> * sizeof(int_T));
		    #endif
		  %else
		    int_T *dimensions = (int_T *) ...
		      malloc(%<oNumDims> * sizeof(int_T));
		  %endif
		%endif
                %foreach Idx = oNumDims
                  dimensions[%<Idx>] = %<oDims[Idx]>;
                %endforeach
		_ssSetOutputPortDimensionsPtr(%<s>, %<opIdx>, dimensions);
	      %endif
	      _ssSetOutputPortNumDimensions(%<s>, %<opIdx>, %<oNumDims>);
	      ssSetOutputPortWidth(%<s>, %<opIdx>, %<oWidth>);
	      %assign op = FcnGetOutputPortRecord(opIdx)
	      %assign idNum = IDNUM(op.SignalSrc[0])
	      %if idNum[0] == "F" %%FcnCall
		%<underScore>ssSetOutputPortSignal(%<s>, %<opIdx>, %<SLibGetNullDefinitionFromTfl()>);
	      %else
		%assign dt = LibBlockOutputSignalDataTypeName(opIdx, "")
		%assign yAddr = LibBlockOutputSignalAddr(opIdx, "", "", 0)
		%<underScore>ssSetOutputPortSignal(%<s>, ...
		  %<opIdx>, ((%<dt> *) %<yAddr>));
	      %endif
              
              %if LibGetIsOutputPortVarDims(opIdx)
                %assign dwork_var = SLibGetCurrentOutputPortDimensions(opIdx, 0)
                _ssSetOutputPortVariableDimsPtr(%<s>, ...
                  %<vopIdx>, &%<dwork_var>);
                %assign vopIdx = vopIdx + 1
              %endif
	    }
	  %endforeach
	}
	%break
    %endswitch
  %endif  %% NumDataOutputPorts
  %closefile retBuf
  
  %return retBuf
%endfunction


%% Function: SLibSetupStatesForChildSfcn =======================================
%%
%function SLibSetupStatesForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %openfile retBuf
  %assign numDiscStates = DiscStates[0]
  %assign numContStates = ContStates[0]
  %assign nStates = numDiscStates + numContStates
  %if nStates > 0
    %assign SfcnIdx = "%<nonInlSfcns>.Sfcn%<childIdx>"

    /* states */
    %switch ParamSettings.FunctionLevel
      %case 1
	%%
	%% Level 1 S-Function
	%%
	%if StatesDiscontiguous == 1
	  %% states are discontiguous
	  {
	    %if usingStatic
	      static real_T sfcnX[%<nStates>];
	    %elseif SLibIsERTCodeFormat()
	      real_T *sfcnX = (real_T *) &%<SfcnIdx>.X[0];
	    %else
	      real_T *sfcnX = (real_T *) ...
		malloc(%<nStates> * sizeof(real_T));
	      %<RTMChkMemAndReturnIfErr("sfcnX")>;
	    %endif
	    (void) %<LibGenMemFcnCall("memset", "(void*)sfcnX", "0", ...
	      "sizeof(real_T)*%<nStates>")>;
	    %<underScore>ssSetContStates(%<s>, &sfcnX[0]);
	  }
	%elseif numContStates > 0
	  %% s-function has only continuous states
	  %<underScore>ssSetContStates(%<s>, ...
	    &%<LibBlockContinuousState("", "", 0)>);
	%else
	  %% s-function has only discrete states
	  %<underScore>ssSetContStates(%<s>, ...
	    &%<LibBlockDiscreteState("", "", 0)>);
	%endif
	%break
	
      %case 2
	%%
	%% Level 2 S-Function
	%%
	%if numContStates > 0
	  %% s-function has only continuous states
	  %<underScore>ssSetContStates(%<s>, ...
	    &%<LibBlockContinuousState("", "", 0)>);
	%endif
	%if numDiscStates > 0
	  %% s-function has only discrete states
	  %<underScore>ssSetDiscStates(%<s>, ...
	    (real_T *) &%<LibBlockDiscreteState("", "", 0)>);
	%endif
	%break
    %endswitch
  %endif  %% nStates > 0
  %closefile retBuf
  
  %return retBuf
%endfunction


%% Function: SLibSetupPathInfoForChildSfcn =====================================
%%
%function SLibSetupPathInfoForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %assign thisBlock = ChildSFunctionList[childIdx]

  %openfile retBuf
  /* path info */
  %if CodeFormat == "S-Function" || IsModelReferenceSimTarget()
    %<underScore>ssSetModelName(%<s>, ...
      "%<thisBlock.ParamSettings.FunctionName>");
  %else
    %if ISFIELD(thisBlock,"SLName")
      %assign sysName = SYSNAME(SLName)
    %else
      %assign sysName = SYSNAME(Name)
    %endif
    %<underScore>ssSetModelName(%<s>, "%<STRING(sysName[1])>");
  %endif
  %assign pathName = LibGetFormattedBlockPath(thisBlock)
  %<underScore>ssSetPath(%<s>, "%<pathName>");
  %if GenRTModel
    %if !IsModelReferenceSimTarget()
      %%
      %% There is no root SimStruct
      %%
      ssSetRTModel(%<s>,%<tSimStruct>);
      %<underScore>ssSetParentSS(%<s>, %<SLibGetNullDefinitionFromTfl()>);
      %<underScore>ssSetRootSS(%<s>, %<s>);
    %else
      ssSetRTModel(%<s>,%<tSimStruct>);
      %<underScore>ssSetParentSS(%<s>, %<tMdlRefSfcnS>);
      %<underScore>ssSetRootSS(%<s>, ssGetRootSS(%<tMdlRefSfcnS>));
    %endif
  %else
    if (ssGetRTModel(%<tSimStruct>) == %<SLibGetNullDefinitionFromTfl()>) {
      %<underScore>ssSetParentSS(%<s>, %<RTMGetModelSS()>);
      %<underScore>ssSetRootSS(%<s>, %<RTMGet("RootSS")>);
    } else {
      ssSetRTModel(%<s>,ssGetRTModel(%<tSimStruct>));
      %<underScore>ssSetParentSS(%<s>, %<SLibGetNullDefinitionFromTfl()>);
      %<underScore>ssSetRootSS(%<s>, %<s>);
    }
  %endif
  %if ParamSettings.FunctionLevel == 1
    ssSetVersion(%<s>, SIMSTRUCT_VERSION_LEVEL1);
  %else
    ssSetVersion(%<s>, SIMSTRUCT_VERSION_LEVEL2);
  %endif
  %closefile retBuf
  
  %return retBuf
%endfunction

%% Function: SLibSetupSfcnParamsForChildSfcn  ==================================
%%
%function SLibSetupSfcnParamsForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %openfile retBuf
  %%
  %% S-Function parameters
  %%	
  %assign numArgs = Parameters[0] / 2
  %if numArgs > 0
    %assign SfcnIdx = "%<nonInlSfcns>.Sfcn%<childIdx>"
    %%
    %% Set S-function parameters to point to model rtP / rtcP parameters
    %%
    %openfile tmpBuffer
    %foreach argIdx = numArgs
      %assign paramIdx  = argIdx + 1
      %assign paramName = "P%<paramIdx>Size"
      %assign paramAddr = LibBlockParameterAddr(%<paramName>,"","",0)
      %<underScore>ssSetSFcnParam(%<s>, %<argIdx>, (mxArray*)%<paramAddr>);
    %endforeach
    %closefile tmpBuffer
    %%
    %%
    
    /* parameters */
    {
      %if usingStatic
	static mxArray *sfcnParams[%<numArgs>];
      %elseif SLibIsERTCodeFormat()
	mxArray **sfcnParams = \
	(mxArray **) &%<SfcnIdx>.params;
      %else
	mxArray **sfcnParams = (mxArray **) malloc(%<numArgs> * sizeof(mxArray *));
	%<RTMChkMemAndReturnIfErr("sfcnParams")>;
      %endif
      
      %<underScore>ssSetSFcnParamsCount(%<s>, %<numArgs>);
      %<underScore>ssSetSFcnParamsPtr(%<s>, &sfcnParams[0]);
      
      %if CodeFormat == "S-Function" || IsModelReferenceSimTarget()
	%%
	%% This is a non-inlined user (hand-written) S-Function that
	%% is being embedded into an generated S-Function.
	%%
	%% Need to setup the support structure _ssSFcnParams
	%% so that the underlying (level 2) S-functions can make
	%% calls to ssSetSFcnParamNotTunable, etc.
	%%
	%if LibSFunctionLevel() == "Level2"
	  #if defined(MATLAB_MEX_FILE)
	  {
	    %if usingStatic
	      static uint_T attribs[%<numArgs>];
	    %elseif SLibIsERTCodeFormat()
	      uint_T *attribs = (uint_T *) &%<SfcnIdx>.attribs;
	    %else
	      uint_T *attribs;
	      attribs = (uint_T *) ...
		mxCalloc(%<numArgs>, sizeof(uint_T));
	      mexMakeMemoryPersistent(attribs);
	    %endif
	    
	    ssSetSFcnParamAttribsPtr(%<s>, &attribs[0]);
	    (void) %<LibGenMemFcnCall("memset", "(void *)&attribs[0]", ...
	      " 0", " %<numArgs> * sizeof(uint_T)")>;
	  }
	  #endif
	%endif
	%%
	%% For non-inlined user s-functions need to make pararmeters an
	%% MATLAB mxArray, not the simplified mxArray version of used in
	%% code generation. Only when MATLAB_MEX_FILE since the dll has
	%% been compiled for the MATLAB version of an mxArray.
	%%
	#if defined(MATLAB_MEX_FILE)
	{
	  mxArray *param;
	  int_T i;
	  real_T *vals;
	  
	  %foreach argIdx = numArgs
	    %assign paramIdx = argIdx + 1
	    %assign paramVal  = "P%<paramIdx>"
	    %assign mSize = CAST("Number", Parameter[argIdx*2].Value[0])
	    %assign nSize = CAST("Number", Parameter[argIdx*2].Value[1])
	    %if LibGetRecordIsComplex(Parameter[argIdx*2+1])
	      %assign nSize = 2*nSize
	    %endif
	    
	    %assign data = ...
	      LibBlockMatrixParameterAddr(%<paramVal>, "", "", ...
	      0, "", "", 0)
	    %if SLibGetBlockParameterStorageClass(%<paramVal>) == "Auto_SFCN"
	      %% Point this childs parameter to the tunable parameter
	      %% directly.  This is only when the child s-function in not
	      %% an expression.
	      %assign tunableParam = ...
		SLibGetBlockParameterIdentifier(%<paramVal>)
	      %<underScore>ssSetSFcnParam(%<s>, %<argIdx>, \
	      %<tunableParam>(%<RTMGetModelSS()>));
	    %else
	      param = mxCreateDoubleMatrix(%<mSize>,%<nSize>,mxREAL);
	      mexMakeArrayPersistent(param);
	      %if mSize*nSize > 0
		vals = (real_T *) %<data>;
		for (i=0;i< %<mSize> * %<nSize>;i++) {
		  mxGetPr(param)[i] = vals[i];
		}
	      %endif
	      %<underScore>ssSetSFcnParam(%<s>, %<argIdx>, param);
	    %endif
	    
	  %endforeach
	}
	#else
	%<tmpBuffer>\
	#endif
      %else
	%%
	%% Not S-Function code format
	%%
	%<tmpBuffer>\
      %endif
    }
  %endif  %% numArgs > 0
  %closefile retBuf
  
  %return retBuf
%endfunction

%% Function: SLibSetupWorksForChildSfcn  =======================================
%%
%function SLibSetupWorksForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %%
  %% RWork, IWork, PWork, DWork and Mode
  %%
  %assign thisBlock = ChildSFunctionList[childIdx]
  %assign numRWorks = RWork[0]
  %assign numIWorks = IWork[0]
  %assign numPWorks = PWork[0]
  %assign numDWorks = thisBlock.NumDWork
  %assign numModes  = ModeVector[0]
  %openfile tmpBuffer
  %if numRWorks > 0
    %<underScore>ssSetRWork(%<s>, (real_T *) ...
      &%<LibBlockRWork(RWork, "", "", 0)>);
  %endif
  %if numIWorks > 0
    %<underScore>ssSetIWork(%<s>, (int_T *) ...
      &%<LibBlockIWork(IWork, "", "", 0)>);
  %endif
  %if numPWorks > 0
    %<underScore>ssSetPWork(%<s>, (void **) ...
      &%<LibBlockPWork(PWork, "", "", 0)>);
  %endif
  %if numDWorks > 0
    {
      %assign SfcnIdx = "%<nonInlSfcns>.Sfcn%<childIdx>"

      %if usingStatic
	static struct _ssDWorkRecord dWorkRecord[%<numDWorks>];
	static struct _ssDWorkAuxRecord dWorkAuxRecord[%<numDWorks>];
      %elseif SLibIsERTCodeFormat()
	struct _ssDWorkRecord *dWorkRecord = \
	(struct _ssDWorkRecord *) &%<SfcnIdx>.dWork;
	struct _ssDWorkAuxRecord *dWorkAuxRecord = \
	(struct _ssDWorkAuxRecord *) &%<SfcnIdx>.dWorkAux;
      %else
	struct _ssDWorkRecord *dWorkRecord = ...
	  (struct _ssDWorkRecord *) malloc(%<numDWorks> * sizeof(struct _ssDWorkRecord));
	struct _ssDWorkAuxRecord *dWorkAuxRecord = ...
	  (struct _ssDWorkAuxRecord *) calloc(%<numDWorks>, sizeof(struct _ssDWorkAuxRecord));
	%<RTMChkMemAndReturnIfErr("dWorkRecord")>;
	%<RTMChkMemAndReturnIfErr("dWorkAuxRecord")>;
      %endif
      
      ssSetSFcnDWork(%<s>, dWorkRecord);
      ssSetSFcnDWorkAux(%<s>, dWorkAuxRecord);
      _ssSetNumDWork(%<s>, %<numDWorks>);
      
      %foreach idx = numDWorks
	%assign dwork = DWork[idx]
	%assign dtIdCurDWork = LibGetDataTypeIdAliasedThruToFromId(...
	  LibBlockDWorkDataTypeId(dwork))
	%assign dwRec = ::CompiledModel.DWorks.DWork[dwork.FirstRootIdx]
	
	/* %<dwork.Name> */
	ssSetDWorkWidth(%<s>, %<idx>, ...
	  %<LibBlockDWorkWidth(dwork)>);
	%%
	%if LibIsBuiltInDataType(dtIdCurDWork)
	  %assign dtEnum = LibGetDataTypeEnumFromId(dtIdCurDWork)
	  ssSetDWorkDataType(%<s>, %<idx>,%<dtEnum>);
	%else
	  %%
	  %assign curDT = FixPt_GetDataTypeFromIndex(dtIdCurDWork)
	  %%
	  %if curDT.IsFixedPoint
	    {
	      DTypeId dataTypeIdReg =
	      %if FixPt_DataTypeIsFloat(curDT)
		ssRegisterDataTypeFxpScaledDouble(
	      %else
		ssRegisterDataTypeFxpFSlopeFixExpBias(
	      %endif
	      %<s>,
	      %<curDT.IsSigned>,
	      %<curDT.RequiredBits>,
	      %<curDT.FracSlope>,
	      %<curDT.FixedExp>,
	      %<curDT.Bias>,
	      0 /* false means do NOT obey data type override setting for this subsystem */ );
	      
	      ssSetDWorkDataType( %<s>, %<idx>, dataTypeIdReg );
	    }
	  %else
	    %assign dtEnum = LibGetDataTypeEnumFromId(dtIdCurDWork)
	    %%
	    %if dtEnum == "SS_POINTER" || dtEnum == "SS_INTEGER"
	      ssSetDWorkDataType(%<s>, %<idx>,%<dtEnum>);
	    %elseif LibSFunctionLevel() != "RTWLevel2"
              %assign errTxt = "User-defined data type " ...
                "%<LibGetDataTypeNameFromId(dtIdCurDWork)> is required " ...
                "for DWork %<idx>, but the information needed to define this " ...
                "data type is unknown.  The generated code that normally " ...
                "specifies the data type of this DWork is being omitted. " ...
                "If additional custom code does not register this user-define data type " ...
                "and set the data type of this DWork, then the generated code " ...
                "will be incomplete."
              %<LibBlockReportWarning(thisBlock, errTxt)>
            %endif
          %endif
        %endif
	ssSetDWorkComplexSignal(%<s>, %<idx>, ...
	  %<LibBlockDWorkIsComplex(dwork)>);
	%if dwRec.UsedAs == "DSTATE"
	  ssSetDWorkUsedAsDState(%<s>, %<idx>, 1);
	%endif
	%<underScore>ssSetDWork(%<s>, %<idx>, ...
	  %<LibBlockDWorkAddr(dwork, "", "", 0)>);
      %endforeach
    }
  %endif
  %if numModes > 0
    %<underScore>ssSetModeVector(%<s>, (int_T *) ...
      &%<LibBlockMode("", "", 0)>);
  %endif
  %closefile tmpBuffer
  %openfile retBuf
  %if !WHITE_SPACE(tmpBuffer)
    
    /* work vectors */
    %<tmpBuffer>\
  %endif
  %closefile retBuf
  
  %return retBuf
%endfunction

%% Function: SLibSetupCallSysForChildSfcn ======================================
%%
%function SLibSetupCallSysForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %openfile retBuf
  %%
  %%  Function calls
  %%	
  %if NumSFcnSysOutputCalls > 0
    %assign SfcnIdx = "%<nonInlSfcns>.Sfcn%<childIdx>"

    /* register function-calls */
    {
      %assign pZeroWidth = LibBlockOutputSignalWidth(0)
      %if usingStatic
	static int_T callSysOutputs[%<pZeroWidth>];
	static void *callSysArgs1[%<pZeroWidth>];
	static int_T callSysArgs2[%<pZeroWidth>];
	static SysOutputFcn callSysFcns[%<4*pZeroWidth>];
      %elseif SLibIsERTCodeFormat()
	int_T *callSysOutputs = (int_T *) &%<SfcnIdx>.callSysOutputs;
	void **callSysArgs1 = (void **) &%<SfcnIdx>.callSysArgs1;
	int_T *callSysArgs2 = (int_T *) &%<SfcnIdx>.callSysArgs2;
	SysOutputFcn *callSysFcns = (SysOutputFcn *) &%<SfcnIdx>.callSysFcns;
      %else
	int_T        *callSysOutputs;
	void         **callSysArgs1;
	int_T        *callSysArgs2;
	SysOutputFcn *callSysFcns;
	
	callSysOutputs = (int_T *) ...
	  malloc(%<LibBlockOutputSignalWidth(0)> ...
	  * sizeof(int_T));
	%<RTMChkMemAndReturnIfErr("callSysOutputs")>;
	
	callSysArgs1 = (void **) ...
	  malloc(%<pZeroWidth> * sizeof(void *));
	%<RTMChkMemAndReturnIfErr("callSysArgs1")>;
	
	callSysArgs2 = (int_T *) ...
	  malloc(%<pZeroWidth> * sizeof(int_T));
	%<RTMChkMemAndReturnIfErr("callSysArgs2")>;
	
	callSysFcns = (SysOutputFcn *) ...
	  malloc(%<4*pZeroWidth> * sizeof(SysOutputFcn));
	%<RTMChkMemAndReturnIfErr("callSysFcns")>;
	
      %endif
      
      {
        %<SLibEmitForLoopCounterCode(pZeroWidth)>
	  callSysOutputs[i] = 0;
	  callSysFcns[i]                 = (SysOutputFcn) %<SLibGetNullDefinitionFromTfl()>;
	  callSysFcns[%<pZeroWidth>+i]   = (SysOutputFcn) %<SLibGetNullDefinitionFromTfl()>;
	  callSysFcns[2*%<pZeroWidth>+i] = (SysOutputFcn) %<SLibGetNullDefinitionFromTfl()>;
	  %if IsModelReferenceSimTarget()
	    %% The Model Reference Simulation Target doesn't support
	    %% Initialization function pointers
	    %assign enableFcnIdx = 1
	    %assign disableFcnIdx = 2
	  %else
	    %assign enableFcnIdx = 2
	    %assign disableFcnIdx = 3
	    callSysFcns[3*%<pZeroWidth>+i] = (SysOutputFcn) %<SLibGetNullDefinitionFromTfl()>;
	  %endif
	}
      }
      %<underScore>ssSetCallSystemOutputPtr(%<s>, &callSysOutputs[0]);
      %<underScore>ssSetCallSystemOutputArg1List(%<s>, ...
	&callSysArgs1[0]);
      %<underScore>ssSetCallSystemOutputArg2List(%<s>, ...
	&callSysArgs2[0]);
      %<underScore>ssSetCallSystemOutputFcnList(%<s>, ...
	&callSysFcns[0]);
      %assign portEl = -1
      %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
        %if portEl == SFcnSystemOutputCall[fcnCallIdx].OutputElement
          %continue
        %else
          %assign portEl = SFcnSystemOutputCall[fcnCallIdx].OutputElement
        %endif  
        %with SFcnSystemOutputCall[fcnCallIdx]
	  %if STRING(BlockToCall) != "unconnected"
	    %assign  sysIdx = BlockToCall[0]
	    %assign  blkIdx = BlockToCall[1]
	    %assign ssBlock = ::CompiledModel.System[sysIdx].Block[blkIdx]
	    %assign  tidVal = ParamSettings.SampleTimesToSet[0][1]
	    callSysArgs1[%<OutputElement>] = (void *)%<RTMGetModelSS()>;
	    callSysArgs2[%<OutputElement>] = %<FcnPortElement>;
	    %assign fcnCallFNI = LibGetFcnCallFNI(ssBlock,FcnPortElement,tidVal)
	    %assign fcnInitializeFNI = LibGetFcnInitializeFNI(ssBlock,FcnPortElement,tidVal)
	    %assign fcnEnableFNI = LibGetFcnEnableFNI(ssBlock,FcnPortElement,tidVal)
	    %assign fcnDisableFNI = LibGetFcnDisableFNI(ssBlock,FcnPortElement,tidVal)
	    %assert fcnCallFNI != ""
	    callSysFcns[%<OutputElement>]  = (SysOutputFcn) %<fcnCallFNI>;
	    %if !IsModelReferenceSimTarget()
	      %if fcnInitializeFNI != ""
		callSysFcns[%<pZeroWidth>+%<OutputElement>]  = (SysOutputFcn) \
		%<fcnInitializeFNI>;
	      %else
		callSysFcns[%<pZeroWidth>+%<OutputElement>]  = (SysOutputFcn) %<SLibGetNullDefinitionFromTfl()>;
	      %endif
	    %endif
	    %if fcnEnableFNI != ""
	      callSysFcns[%<enableFcnIdx*pZeroWidth>+%<OutputElement>]  = (SysOutputFcn) \
	      %<fcnEnableFNI>;
	    %else
	      callSysFcns[%<enableFcnIdx*pZeroWidth>+%<OutputElement>]  = (SysOutputFcn) %<SLibGetNullDefinitionFromTfl()>;
	    %endif
	    %if fcnDisableFNI != ""
	      callSysFcns[%<disableFcnIdx*pZeroWidth>+%<OutputElement>]  = (SysOutputFcn) \
	      %<fcnDisableFNI>;
	    %else
	      callSysFcns[%<disableFcnIdx*pZeroWidth>+%<OutputElement>]  = (SysOutputFcn) %<SLibGetNullDefinitionFromTfl()>;
	    %endif
	    callSysOutputs[%<OutputElement>] = 1;
	  %else
	    /* Unconnected function-call */
	    callSysArgs1[%<OutputElement>] = (void *)%<SLibGetNullDefinitionFromTfl()>;
	    callSysArgs2[%<OutputElement>] = 0;
	    callSysFcns[%<OutputElement>]  = (SysOutputFcn) %<SLibGetNullDefinitionFromTfl()>;
	    callSysFcns[%<pZeroWidth>+%<OutputElement>]  = (SysOutputFcn) %<SLibGetNullDefinitionFromTfl()>;
	    callSysFcns[2*%<pZeroWidth>+%<OutputElement>]  = (SysOutputFcn) %<SLibGetNullDefinitionFromTfl()>;
	    %if !IsModelReferenceSimTarget()
	      callSysFcns[3*%<pZeroWidth>+%<OutputElement>]  = (SysOutputFcn) %<SLibGetNullDefinitionFromTfl()>;
	    %endif
	  %endif
	%endwith
      %endforeach
      %undef sysIdx, blkIdx, ssIdx
    }
  %endif  %% NumSFcnSysOutputCalls > 0
  %closefile retBuf
  
  %return retBuf
%endfunction

%% Function: SLibAdjustStInfoForChildSfcn  =====================================
%%
%function SLibAdjustStInfoForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %%
  %% May need to adjust the sample times
  %%
  %openfile tempBuffer
  %foreach idx = SIZE(ParamSettings.SampleTimesToSet, 0)
    %assign sfcnTID = ParamSettings.SampleTimesToSet[idx][0]
    %assign mdlTID = ParamSettings.SampleTimesToSet[idx][1]
    %if mdlTID < 0
      %assign period = LibRealNonFinite(inf)
      %assign offset = 0
    %else 
      %assign period = ...
        CAST("Real",::CompiledModel.SampleTime[mdlTID].PeriodAndOffset[0])
      %assign offset = ...
        CAST("Real",::CompiledModel.SampleTime[mdlTID].PeriodAndOffset[1])
    %endif
    ssSetSampleTime(%<s>, %<sfcnTID>, %<period>);
    ssSetOffsetTime(%<s>, %<sfcnTID>, %<offset>);
  %endforeach
  %foreach idx = SIZE(ParamSettings.SampleTimesToSet, 0)
    %assign sfcnTID = ParamSettings.SampleTimesToSet[idx][0]
    %assign mdlTID = ParamSettings.SampleTimesToSet[idx][1]
    %if mdlTID <0
      sfcnTsMap[%<sfcnTID>] = %<mdlTID>;
    %else
      %% If this is model reference, we need to get the global
      %% TID from a parent model, which is passed in to the reg
      %if IsModelReferenceTarget()
        %% Guard against using the mdlref_TID when its not defined
        %if !MdlRefIsConstSampleBlock() && ...
          MdlRefDisallowSampleTimeInheritance()
          sfcnTsMap[%<sfcnTID>] = mdlref_TID%<mdlTID>;
        %else
          %assert SIZE(ParamSettings.SampleTimesToSet, 0) == 1
          sfcnTsMap[%<sfcnTID>] = 0;
        %endif
        %% If this is sfcn target, we need to get the 
        %% TID from the SampleTimeTaskIDPtr of its parent model.
        %% TID at root model will be passed in throught SampleTimeTaskIDPtr
        %% of each sfcn simstruct. 
      %elseif CodeFormat == "S-Function" || GenerateErtSFunction
        %% SampleTimeTaskIDPtr doesn't include asyncTid yet. 
        %% Non-inlined sfcn can not get correct TID value in 
        %% parent model through SampleTimeTaskIDPtr. However, 
        %% since we only support single rate non-inlined sfcn running
        %% at async rate, any async task always get task time from base rate
        %% in Sfcn target, it's okay to force map async ts to TaskIdx 0 in 
        %% parent model. 
        %%
        %if LibAsynchronousTriggeredTID(mdlTID)
          sfcnTsMap[%<sfcnTID>] = 0;
          %assert (SIZE(ParamSettings.SampleTimesToSet, 0) == 1)
        %else
          sfcnTsMap[%<sfcnTID>] = %<RTMGet("SampleTimeTaskIDPtr")>[%<mdlTID>];
        %endif
      %else
        sfcnTsMap[%<sfcnTID>] = %<mdlTID>;
      %endif
    %endif
  %endforeach
  %closefile tempBuffer
  
  %openfile retBuf
  %if !WHITE_SPACE(tempBuffer)
    
    /* adjust sample time */
    %<tempBuffer>\
  %endif
  %closefile retBuf
  
  %return retBuf
%endfunction


%% Function: SLibCallChildSfcnInitializationFcn  ===============================
%%
%function SLibCallChildSfcnInitializationFcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %assign sfuncName = ParamSettings.FunctionName

  %openfile retBuf
  %%
  %% Call child's initialization routines
  %%
  /* registration */
  %if (CodeFormat == "S-Function" && !usingStatic) || ...
    IsModelReferenceSimTarget()
    
    #if defined(MATLAB_MEX_FILE)
    {
      int_T i;
      mxArray *plhs[1];
      mxArray *prhs[4];
      double *pr;
      int_T *intS   = (int_T *)&%<s>;
      int_T addrlen = sizeof(SimStruct *);
      int_T m       = addrlen/sizeof(int_T) + 1;
      
      prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
      prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
      
      pr = mxGetPr(prhs[1]);
      for (i = 0; i < m - 1; i++) {
	pr[i] = (double)intS[i];
      }
      pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
      
      prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
      prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);
      
      /* Reset port dimensions info functions because the S-function
      * and accelerator mex-files explicitly set their dimensions,
      * i.e., they are not dynamically sized. For this case, the
      * mex-file is responsible for the dimensions info memory
      * and Simulink should not free it. This is achieved by
      * setting the following two methods to NULL.
      */
      
      ssSetRegInputPortDimensionInfoFcn(%<s>, %<SLibGetNullDefinitionFromTfl()>);
      ssSetRegOutputPortDimensionInfoFcn(%<s>, %<SLibGetNullDefinitionFromTfl()>);
      
      /*
      * Setup function pointers and call mdlInitializeSizes via
      * simulink.c
      */
      
      mexCallMATLAB(1, plhs, 4, prhs, "%<sfuncName>");
      
      mxDestroyArray(plhs[0]);
      mxDestroyArray(prhs[0]);
      mxDestroyArray(prhs[1]);
      mxDestroyArray(prhs[2]);
      mxDestroyArray(prhs[3]);
      
    }
    #else
    %<sfuncName>(%<s>);
    sfcnInitializeSizes(%<s>);
    #endif
    
    %if PortBasedSampleTimes == "no"
      sfcnInitializeSampleTimes(%<s>);
    %endif
  %else
    %<sfuncName>(%<s>);
    
    sfcnInitializeSizes(%<s>);
    %if PortBasedSampleTimes == "no"
      sfcnInitializeSampleTimes(%<s>);
    %endif
  %endif
  %closefile retBuf
  
  %return retBuf
%endfunction

%% Function: SLibResetDynSizedFieldsForChildSfcn  ==============================
%%
%function SLibResetDynSizedFieldsForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns)
  %assign thisBlock = ChildSFunctionList[childIdx]
  %assign numDiscStates = DiscStates[0]
  %assign numContStates = ContStates[0]
   
  %openfile retBuf
  %%
  %% Need to explicitly reset anything that was dynamically sized
  %%
  %assign dsSize = SIZE(ParamSettings.DynamicallySizedVectors,1)
  %if dsSize > 0

    /* set compiled values of dynamic vector attributes */
    %if ParamSettings.FunctionLevel == 1
      %foreach idx = dsSize
	%assign dsVar = ParamSettings.DynamicallySizedVectors[idx]
	%switch dsVar
	  %case "U"
	    %if isRSimWithSolverModule %% assert !IsModelReferenceTarget()
	      ssSetNumU(%<s>, %<LibBlockInputSignalWidth(0)>);
	    %else
	      ssSetNumInputs(%<s>, %<LibBlockInputSignalWidth(0)>);
	    %endif
	    %break
	  %case "Y"
	    %if isRSimWithSolverModule %% assert !IsModelReferenceTarget()
	      ssSetNumY(%<s>, %<LibBlockOutputSignalWidth(0)>);
	    %else
	      ssSetNumOutputs(%<s>, %<LibBlockOutputSignalWidth(0)>);
	    %endif
	    %break
	  %case "Xc"
	    ssSetNumContStates(%<s>, %<numContStates>);
	    %break
	  %case "Xd"
	    ssSetNumDiscStates(%<s>, %<numDiscStates>);
	    %break
	  %case "RWork"
	    ssSetNumRWork(%<s>, %<RWork[0]>);
	    %break
	  %case "IWork"
	    ssSetNumIWork(%<s>, %<IWork[0]>);
	    %break
	  %case "PWork"
	    ssSetNumPWork(%<s>, %<PWork[0]>);
	    %break
	  %case "Modes"
	    ssSetNumModes(%<s>, %<ModeVector[0]>);
	    %break
	  %case "NonsampledZCs"
	    ssSetNumNonsampledZCs(%<s>, %<NumNonsampledZCs>);
	    %break
	  %default
	    %assign errTxt = "No case for dynamically sizing: %<dsVar>"
	    %<LibReportFatalError(errTxt)>
	%endswitch
      %endforeach
    %else
      %foreach idx = dsSize
	%assign dsVar = ParamSettings.DynamicallySizedVectors[idx]
	%assign idNum = IDNUM(dsVar)
	%assign num = idNum[1]
	
	%switch idNum[0]
	  %case "U"
	    %assign u = DataInputPort[num]
	    ssSetInputPortWidth(%<s>, %<num>, %<LibGetRecordWidth(u)>);
	    %%
	    %assign dtIdCurInput = LibGetDataTypeIdAliasedThruToFromId(...
	      SLibGetRecordDataTypeId(u))
	    %%
	    %if LibIsBuiltInDataType(dtIdCurInput)
	      %assign dtEnum = LibGetDataTypeEnumFromId(dtIdCurInput)
	      ssSetInputPortDataType(%<s>, %<num>, %<dtEnum>);
	    %else
	      %%
	      %assign curDT = FixPt_GetDataTypeFromIndex(dtIdCurInput)
	      %%
	      %if curDT.IsFixedPoint
		{
		  DTypeId dataTypeIdReg =
		  %if FixPt_DataTypeIsFloat(curDT)
		    ssRegisterDataTypeFxpScaledDouble(
		  %else
		    ssRegisterDataTypeFxpFSlopeFixExpBias(
		  %endif
		  %<s>,
		  %<curDT.IsSigned>,
		  %<curDT.RequiredBits>,
		  %<curDT.FracSlope>,
		  %<curDT.FixedExp>,
		  %<curDT.Bias>,
		  0 /* false means do NOT obey data type override setting for this subsystem */ );
		  
		  ssSetInputPortDataType(%<s>, %<num>, dataTypeIdReg );
		}
	      %else
		%assign dtEnum = LibGetDataTypeEnumFromId(dtIdCurInput)
		%%
		%if dtEnum == "SS_POINTER" || dtEnum == "SS_INTEGER"
		  ssSetInputPortDataType(%<s>, %<num>, %<dtEnum>);
		%else
		  %assign errTxt = "User-defined data type " ...
		    "%<LibGetDataTypeNameFromId(dtIdCurInput)> is required " ...
		    "for Root Level Input %<num>, but the information needed to define this " ...
		    "data type in the generated S-Function code format is unknown."
		  %<LibBlockReportError(thisBlock, errTxt)>
		%endif
	      %endif
	    %endif
	    %%
	    ssSetInputPortComplexSignal(%<s>, %<num>, ...
	      %<SLibGetRecordIsComplex(u)>);
	    ssSetInputPortFrameData(%<s>, %<num>, ...
	      %<LibBlockInputSignalIsFrameData(num)>);
	    %break
	  %case "Y"
	    %assign yWidth = LibBlockOutputSignalWidth(num)
	    %assign op = FcnGetOutputPortRecord(num)
	    %assign sigRec = SLibGetSourceRecord(op, 0)
	    ssSetOutputPortWidth(%<s>, %<num>, %<yWidth>);
	    %if !ISEMPTY(sigRec)
	      %%
	      %assign dtIdCurOutput = LibGetDataTypeIdAliasedThruToFromId(...
		SLibGetRecordDataTypeId(sigRec))
	      %%
	      %if LibIsBuiltInDataType(dtIdCurOutput)
		%assign dtEnum = LibGetDataTypeEnumFromId(dtIdCurOutput)
		ssSetOutputPortDataType(%<s>, %<num>, %<dtEnum>);
	      %else
		%%
		%assign curDT = FixPt_GetDataTypeFromIndex(dtIdCurOutput)
		%%
		%if curDT.IsFixedPoint
		  {
		    DTypeId dataTypeIdReg =
		    %if FixPt_DataTypeIsFloat(curDT)
		      ssRegisterDataTypeFxpScaledDouble(
		    %else
		      ssRegisterDataTypeFxpFSlopeFixExpBias(
		    %endif
		    %<s>,
		    %<curDT.IsSigned>,
		    %<curDT.RequiredBits>,
		    %<curDT.FracSlope>,
		    %<curDT.FixedExp>,
		    %<curDT.Bias>,
		    0 /* false means do NOT obey data type override setting for this subsystem */ );
		    
		    ssSetOutputPortDataType(%<s>, %<num>, dataTypeIdReg );
		  }
		%else
		  %assign dtEnum = LibGetDataTypeEnumFromId(dtIdCurOutput)
		  %%
		  %if dtEnum == "SS_POINTER" || dtEnum == "SS_INTEGER"
		    ssSetOutputPortDataType(%<s>, %<num>,%<dtEnum>);
		  %else
		    %assign errTxt = "User-defined data type " ...
		      "%<LibGetDataTypeNameFromId(dtIdCurOutput)> is required " ...
		      "for Root Level Output %<num>, but the information needed to define this " ...
		      "data type in the generated S-Function code format is unknown."
		    %<LibBlockReportError(thisBlock, errTxt)>
		  %endif
		%endif
	      %endif
	      %%
	      ssSetOutputPortComplexSignal(%<s>, %<num>, ...
		%<SLibGetRecordIsComplex(sigRec)>);
	      ssSetOutputPortFrameData(%<s>, %<num>, ...
		%<LibBlockOutputSignalIsFrameData(num)>);
	    %endif
	    %break
	  %case "Xc"
	    ssSetNumContStates(%<s>, %<numContStates>);
	    %break
	  %case "Xd"
	    ssSetNumDiscStates(%<s>, %<numDiscStates>);
	    %break
	  %case "RWork"
	    ssSetNumRWork(%<s>, %<RWork[0]>);
	    %break
	  %case "IWork"
	    ssSetNumIWork(%<s>, %<IWork[0]>);
	    %break
	  %case "PWork"
	    ssSetNumPWork(%<s>, %<PWork[0]>);
	    %break
	  %case "DWork"
	    _ssSetNumDWork(%<s>, %<numDWorks>);
	    %break
	  %case "D"
	    %assign dwork = thisBlock.DWork[num]
	    ssSetDWorkWidth(%<s>, %<num>, ...
	      %<LibBlockDWorkWidth(dwork)>);
	    %%
	    %assign dtIdCurDWork = LibGetDataTypeIdAliasedThruToFromId(...
	      LibBlockDWorkDataTypeId(dwork))
	    %%
	    %if LibIsBuiltInDataType(dtIdCurDWork)
	      %assign dtEnum = LibGetDataTypeEnumFromId(dtIdCurDWork)
	      ssSetDWorkDataType(%<s>, %<num>, %<dtEnum>);
	    %else
	      %%
	      %assign curDT = FixPt_GetDataTypeFromIndex(dtIdCurDWork)
	      %%
	      %if curDT.IsFixedPoint
		{
		  DTypeId dataTypeIdReg =
		  %if FixPt_DataTypeIsFloat(curDT)
		    ssRegisterDataTypeFxpScaledDouble(
		  %else
		    ssRegisterDataTypeFxpFSlopeFixExpBias(
		  %endif
		  %<s>,
		  %<curDT.IsSigned>,
		  %<curDT.RequiredBits>,
		  %<curDT.FracSlope>,
		  %<curDT.FixedExp>,
		  %<curDT.Bias>,
		  0 /* false means do NOT obey data type override setting for this subsystem */ );
		  
		  ssSetDWorkDataType(%<s>, %<num>, dataTypeIdReg );
		}
	      %else
		%assign dtEnum = LibGetDataTypeEnumFromId(dtIdCurDWork)
		%%
		%if dtEnum == "SS_POINTER" || dtEnum == "SS_INTEGER"
		  ssSetDWorkDataType(%<s>, %<num>,%<dtEnum>);
		%else
		  %assign errTxt = "User-defined data type " ...
		    "%<LibGetDataTypeNameFromId(dtIdCurDWork)> is required " ...
		    "for DWork %<num>, but the information needed to define this " ...
		    "data type in the generated S-Function code format is unknown. " ...
		    "The generated code that normally " ...
		    "specifies the data type of this DWork is being omitted. " ...
		    "If additional custom code does not register this user-define data type " ...
		    "and set the data type of this DWork, then the generated code " ...
		    "will be incomplete."
		  %<LibBlockReportWarning(thisBlock, errTxt)>
		%endif
	      %endif
	    %endif
	    %%
	    ssSetDWorkComplexSignal(%<s>, %<num>, ...
	      %<LibBlockDWorkIsComplex(dwork)>);
	    %break
	  %case "Modes"
	    ssSetNumModes(%<s>, %<ModeVector[0]>);
	    %break
	  %case "NonsampledZCs"
	    ssSetNumNonsampledZCs(%<s>, %<NumNonsampledZCs>);
	    %break
	  %default
	    %assign errTxt = "No case for dynamically sizing: %<dsVar>"
	    %<LibReportFatalError(errTxt)>
	%endswitch
      %endforeach
    %endif %% FunctionLevel == 1
  %endif   %% dsSize > 1
  %closefile retBuf
  
  %return retBuf
%endfunction
  
%% Function: SLibUpdatePortConnectivityForChildSfcn ============================
%%
%function SLibUpdatePortConnectivityForChildSfcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %openfile retBuf
  %%
  %% Update connectivity flags for each port
  %%
  %if ParamSettings.FunctionLevel == 2
    /* Update connectivity flags for each port */
    %foreach ipIdx = NumDataInputPorts
      _ssSetInputPortConnected(%<s>, %<ipIdx>, ...
	%<LibBlockInputSignalConnected(ipIdx)>);
    %endforeach
    %foreach ipIdx = NumDataOutputPorts
      _ssSetOutputPortConnected(%<s>, %<ipIdx>, ...
	%<LibBlockOutputSignalConnected(ipIdx)>);
    %endforeach
    %foreach ipIdx = NumDataOutputPorts
      _ssSetOutputPortBeingMerged(%<s>, %<ipIdx>, ...
	%<LibBlockOutputSignalBeingMerged(ipIdx)>);
    %endforeach
    /* Update the BufferDstPort flags for each input port */
    %foreach ipIdx = NumDataInputPorts
      %assign bufDst = LibBlockInputSignalBufferDstPort(ipIdx)
      %<underScore>ssSetInputPortBufferDstPort(%<s>, %<ipIdx>, %<bufDst>);
    %endforeach
    %if PortBasedSampleTimes == "yes"
      /* Update port-based sample time attributes */
      %foreach ipIdx = NumDataInputPorts
	_ssSetInputPortSampleTimeIndex(%<s>, %<ipIdx>, ...
	  %<LibBlockInputSignalLocalSampleTimeIndex(ipIdx)>);
	ssSetInputPortSampleTime(%<s>, %<ipIdx>, ...
	  %<LibBlockInputSignalSampleTime(ipIdx)>);
	ssSetInputPortOffsetTime(%<s>, %<ipIdx>, ...
	  %<LibBlockInputSignalOffsetTime(ipIdx)>);
      %endforeach
      %foreach opIdx = NumDataOutputPorts
	_ssSetOutputPortSampleTimeIndex(%<s>, %<opIdx>, ...
	  %<LibBlockOutputSignalLocalSampleTimeIndex(opIdx)>);
	ssSetOutputPortSampleTime(%<s>, %<opIdx>, ...
	  %<LibBlockOutputSignalSampleTime(opIdx)>);
	ssSetOutputPortOffsetTime(%<s>, %<opIdx>, ...
	  %<LibBlockOutputSignalOffsetTime(opIdx)>);
      %endforeach
      sfcnInitializeSampleTimes(%<s>);
    %endif
  %endif %% FunctionLevel == 2
  %closefile retBuf
  
  %return retBuf
%endfunction

%% Function: SLibInitRegDataTypeFcnToErrFcn  ===================================
%% Abstract: 
%%   Since macros using regDataType field do not work with mdlref sim target 
%%   and sfcn target, we initialize the function pointer accessing this field 
%%   to a function, i.e., FcnSetErrorStatus, that reports an error message.
%%
%function SLibInitRegDataTypeFcnToErrFcn(s, childIdx, underScore, ...
  usingStatic, nonInlSfcns) 
  %openfile retBuf
  %if (CodeFormat == "S-Function" && UsingMalloc && ParamSettings.FunctionLevel == 2) || ...
    IsModelReferenceSimTarget()
    %% Always setup function pointer for _mid.h since level 2
    %% child s-f dll will use it.
    (%<s>)->regDataType.arg1 = ((void *)(%<s>));
    (%<s>)->regDataType.registerFcn = ((OldRegisterDataType)FcnSetErrorStatus);
    (%<s>)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
    (%<s>)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
    (%<s>)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
    (%<s>)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);
  %endif
  %closefile retBuf
  %return retBuf
%endfunction

%function SLibCacheBranchedSysCalledByNonInlinedSfcn() void
  %foreach childIdx = NumChildSFunctions
    %assign thisBlock = ChildSFunctionList[childIdx]
    %if SLibSfcnHasBranchFcnCall(thisBlock)
      %% Go over all output function-call signals
      %foreach callIdx = thisBlock.NumSFcnSysOutputCalls

        %assign recIdx    = thisBlock.SFcnSystemOutputCallMappingInfo[callIdx].StartingIdx
        %assign nCalledFC = thisBlock.SFcnSystemOutputCallMappingInfo[callIdx].NumOfCalledFC
        
        %if nCalledFC > 1 %% This element invokes a branched function-call
          %% mark the first subsystem called the element
          %assign fcOutPortEl    = thisBlock.SFcnSystemOutputCall[recIdx].OutputElement
          %assign firstBlkToCall = thisBlock.SFcnSystemOutputCall[recIdx].BlockToCall
          %assert STRING(firstBlkToCall) != "unconnected"
          
          %assign sysIdx  = firstBlkToCall[0]
          %assign blkIdx  = firstBlkToCall[1]
          %assign fcnCallBlock = ::CompiledModel.System[sysIdx].Block[blkIdx]
          %if fcnCallBlock.Type == "SubSystem"
            %with fcnCallBlock
              %assert (Type == "SubSystem") 
              %assign sysIdx = LibBlockParamSetting("Subsystem", "SystemIdx")
            %endwith
            %assign fcnCallSys = System[sysIdx]
            %if !LibIsSystemField(fcnCallSys, "CallerBlkIdx")
              %<LibAddToSystem(fcnCallSys, "CallerBlkIdx",    thisBlock.BlockIdx)>
              %<LibAddToSystem(fcnCallSys, "CallerBlkPortEl", fcOutPortEl)>
            %else
              %% System has multiple callers, Set CallerBlkIdx to invalid value
              %<LibSetSystemField(fcnCallSys, "CallerBlkIdx",[-1 -1 -1])>
              %<LibSetSystemField(fcnCallSys, "CallerBlkPortEl",-1)>
            %endif
          %elseif fcnCallBlock.Type == "ModelReference"
            %assert !ISFIELD(fcnCallBlock, "CallerBlkIdx")
            %assert !ISFIELD(fcnCallBlock, "CallerBlkPortEl")
            %addtorecord fcnCallBlock CallerBlkIdx thisBlock.BlockIdx
            %addtorecord fcnCallBlock CallerBlkPortEl fcOutPortEl
          %endif
        %endif %% if nCalledFC > 1
      %endforeach %% callIdx = thisBlock.NumSFcnSysOutputCalls
      
    %endif %% if SLibSfcnHasBranchFcnCall(thisBlock)
  %endforeach
%endfunction


%% Function: LibCacheChildSFunctionRegistration ================================
%% Abstract:
%%   Cache the child S-Function registration code. Supports these code
%%   formats.
%%
%%   o RealTime
%%   o RealTimeMalloc
%%   o S-Function
%%
%function LibCacheChildSFunctionRegistration(s, modelName) void
  %% No S-functions to register in this model, or any child models
  %if NumChildSFunctions == 0 && ::CompiledModel.ModelBlocksHaveNonInlinedSfcns == 0
    %assign ::CompiledModel.SFunctionRegistration = ""
    %return ""
  %endif
  
  %% Check code format
  %assign usingStatic = !UsingMalloc && (!SLibIsERTCodeFormat())
  %if CodeFormat == "S-Function" || IsModelReferenceSimTarget()
    %assign underScore = "_"
  %else
    %assign underScore = ""
  %endif

  %%
  %% Declare all child SimStructs
  %%
  %assign baseSysIdx = GetBaseSystemIdx()
  %with System[baseSysIdx]
  %openfile sfunctionRegBuffer
  %%
  %% Setup RTWSfcnInfo for cases where rtModel is being generated
  %%
  %if GenRTModel
    %if !IsModelReferenceTarget()
      %<FcnSetupSFcnRTWInfo()>
    %elseif !IsModelReferenceForASimstructBasedTarget() && ...
      NumChildSFunctions > 0
      %<RTMSet("RTWSfcnInfo", "rt_sfcnInfo")>;
    %endif
  %endif

  %if NumChildSFunctions > 0
    %<RTMSet("NumSFunctions", NumChildSFunctions)>;

    /* register each child */
    {
      %assign nonInlSfcns = ""
      %if usingStatic
        static SimStruct childSFunctions[%<NumChildSFunctions>];
        static SimStruct *childSFunctionPtrs[%<NumChildSFunctions>];

        (void) %<LibGenMemFcnCall("memset", "(void *)&childSFunctions[0]", ...
          "0", "sizeof(childSFunctions)")>;
        %if CodeFormat == "S-Function"
          %<RTMuSet("SFunctions", "&childSFunctionPtrs[0]")>;
        %else
          %<RTMSet("SFunctions", "&childSFunctionPtrs[0]")>;
        %endif
      %elseif SLibIsERTCodeFormat()
        %assign nonInlSfcns = "%<RTMGet("NonInlinedSFcns")>"
        (void) %<LibGenMemFcnCall("memset", ...
          "(void *)&%<nonInlSfcns>.childSFunctions[0]", "0", ...
          "%<NumChildSFunctions>*sizeof(SimStruct)")>;
        %<RTMSet("SFunctions", "&%<nonInlSfcns>.childSFunctionPtrs[0]")>;
      %else
        SimStruct *childSFunctions;
        SimStruct **childSFunctionPtrs;

        childSFunctions = (SimStruct *) ...
          malloc(%<NumChildSFunctions> * sizeof(SimStruct));
        %<RTMChkMemAndReturnIfErr("childSFunctions")>;
        (void) %<LibGenMemFcnCall("memset", "(void *)childSFunctions", "0", ...
          "%<NumChildSFunctions>*sizeof(SimStruct)")>;

        childSFunctionPtrs = (SimStruct **) ...
          malloc(%<NumChildSFunctions> * sizeof(SimStruct *));
        %<RTMChkMemAndReturnIfErr("childSFunctionPtrs")>;

        %if CodeFormat == "S-Function"
          %<RTMuSet("SFunctions", "childSFunctionPtrs")>;
        %else
          %<RTMSet("SFunctions", "childSFunctionPtrs")>;
        %endif
      %endif
      %%
      %if NumChildSFunctions >= RollThreshold
        %% use a loop
        {
          int_T i;
          
          for (i = 0; i < %<NumChildSFunctions>; i++) {
            %if CodeFormat == "S-Function"
              %<RTMuSetIdxed("SFunction", "i", "&childSFunctions[i]")>;
            %elseif SLibIsERTCodeFormat()
              %<RTMSetIdxed("SFunction", "i", "&%<nonInlSfcns>.childSFunctions[i]")>;
            %else
              %<RTMSetIdxed("SFunction", "i", "&childSFunctions[i]")>;
            %endif
          }
        }
      %elseif NumChildSFunctions >= 1
        %% do no use a loop
        %foreach childIdx = NumChildSFunctions
          %assign childSfunLabel = "childSFunctions[" + "%<childIdx>" + "]"
          %assign childSfunAddrLabel = "&%<childSfunLabel>"
          %if CodeFormat == "S-Function"
            %<RTMuSetIdxed("SFunction", childIdx, childSfunAddrLabel)>;
          %elseif SLibIsERTCodeFormat()
            %assign childSfunLabel = "&%<nonInlSfcns>." + "%<childSfunLabel>" 
            %<RTMSetIdxed("SFunction", childIdx, childSfunLabel)>;
          %else
            %<RTMSetIdxed("SFunction", childIdx, childSfunAddrLabel)>;
          %endif
        %endforeach
        %%
      %endif
      %%
      %% Initialize each child SimStruct
      %%
      %foreach childIdx = NumChildSFunctions
        %assign thisBlock = ChildSFunctionList[childIdx]
        %with thisBlock
          %assign sfuncName = ParamSettings.FunctionName
          %openfile tmpChildRegBuffer
          %%
          %% Timing Info
          %%
          %<SLibSetupTimingInfoForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns)>
          %%
          %% mdlInfo 
          %%
          %<SLibSetupMdlInfoForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %% allocate memory for  ModelMethods2
          %%
          %<SLibAllocateMethods2MemForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %% allocate memory for  stateInfo2
          %%
          %<SLibAllocateStatesInfo2MemForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %% Inputs
          %%
          %<SLibSetupInputsForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %% Outputs
          %%
          %<SLibSetupOutputsForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %% States
          %%
          %<SLibSetupStatesForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %% Path, model name, parent SimStruct, and root SimStruct
          %%
          %<SLibSetupPathInfoForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %% S-Function parameters
          %%
          %<SLibSetupSfcnParamsForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %% RWork, IWork, PWork, DWork and Mode
          %%
          %<SLibSetupWorksForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %%  Function calls
          %%
          %<SLibSetupCallSysForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %% Registered Data Type 
          %%
          %<SLibInitRegDataTypeFcnToErrFcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns)>
          %%
          %% Call child's initialization routines
          %%
          %<SLibCallChildSfcnInitializationFcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %% May need to adjust the sample times
          %%
          %<SLibAdjustStInfoForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %% Need to explicitly reset anything that was dynamically sized
          %%
          %<SLibResetDynSizedFieldsForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %% Update connectivity flags for each port
          %%
          %<SLibUpdatePortConnectivityForChildSfcn(s, childIdx, underScore, ...
            usingStatic, nonInlSfcns) >
          %%
          %% Generated S-Function's require data instance
          %%
          %if LibSFunctionLevel() == "RTWLevel2"
            %% ModelRef doesn't support Generated
            %% non-inline s-function.  We should have already
            %% errored out during compilation.
            %assert !IsModelReferenceTarget()
            %if !UsingMalloc
              %assign funcName = STRING(ParamSettings.FunctionName)
              %assign end = SIZE(funcName,1) - 3
              %assign origName = ""
              %foreach idx = end
                %assign origName = origName + funcName[idx]
              %endforeach
              %assign sidInc = "%<origName>_sfcn_rtw/%<origName>_sid.h"
              /* Instance data for generated S-Function: %<origName> */
              %if CodeFormat == "S-Function"
                {
                  SimStruct *rts = childS;
                  #include "%<sidInc>"
                }
              %else
                #include "%<sidInc>"
              %endif
            %endif %% !UsingMalloc
          %endif %% RTWLevel2
          %closefile tmpChildRegBuffer

          %%
          %% Ensure the childsfcn does not have the same name
          %%
          %if CodeFormat == "S-Function" && (sfuncName == ::CompiledModel.Name)
            %assign errTxt = "\n\nDetected duplicate name '%<sfuncName>' for this generated " ...
              "S-function and the noninlined S-function name from block '%<thisBlock.Name>'." ...
              " Please choose another name for this generated S-function.  "
            %<LibReportError(errTxt)>
          %endif

          %% Adding one record each to CompiledModel everytime we cache an
          %% sfunction extern prototype
          %assign varName = "SFcn_%<ParamSettings.FunctionName>_PrototypeCached"

          %if !EXISTS("::CompiledModel.%<varName>")
            %addtorecord ::CompiledModel %<varName> 1
            %openfile fcnPrototype
            %assign flag = LibExternInFcnDecls()
            %if GenCPP
              %assign flag =  "extern \"C\""
            %endif
            %<flag> void %<ParamSettings.FunctionName>(SimStruct *%<s>);
            %closefile fcnPrototype
            %<LibCacheFunctionPrototype(fcnPrototype)>\
          %endif

          /* %<TypeLevel> Block: %<modelName>%<"/">%<Name> (%<sfuncName>) */
          {
            SimStruct *%<s> = %<RTMGetIdxed("SFunction", childIdx)>;
            %<tmpChildRegBuffer>\
          }
        %endwith   %% thisBlock
      %endforeach  %% NumChildSFunctions
      %%
      %% cache registration code
      %%
    }
  %endif
  %closefile sfunctionRegBuffer
  %endwith %% System[NumSystems-1]
  %assign ::CompiledModel.SFunctionRegistration = sfunctionRegBuffer

%endfunction %% LibCacheChildSFunctionRegistration


%% Function: LibSFunctionRegistrationIsEmpty ===================================
%% Abstract:
%function LibSFunctionRegistrationIsEmpty() void
  %<LibTrapCacheAssert(SFunctionRegistration)>
  %return WHITE_SPACE(SFunctionRegistration)
%endfunction


%% Function: LibDumpSFunctionRegistration ======================================
%% Abstract:
%function LibDumpSFunctionRegistration() Output
  %<LibTrapCacheAssert(SFunctionRegistration)>\
  %if !WHITE_SPACE(SFunctionRegistration)

    /* child S-Function registration */
    %<SFunctionRegistration>\
  %endif
%endfunction


%% Function: GenStandaloneRegistrationFunction =================================
%% Abstract:
%%   Generate the following information:
%%     - Standalone subsystem memory initialization function, i.e., registration
%%     - If the functions are generated in different files,declare them in
%%       subsystem header file.
%function GenStandaloneRegistrationFunction() void
  %assign rootFile = GetBaseFileName()
  %assign callBuf  = ""
  %foreach sysIdx = NumSystems
    %assign system = System[sysIdx]
    %if LibIsSystemField(system, "CachedInitializeDataBody") && ...
      !WHITE_SPACE(LibGetSystemField(system, "CachedInitializeDataBody"))
      %openfile regBuf
      %assign fcnName = system.StandaloneInitializeFcn
      %if LibSystemIsInlined(system)
        %<SLibGetFcnComment(system,"Initialize")>\
      %else
        %assign fcnAbstract = SLibGetFcnCommentContents(system,"Initialize")
        %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(system,"Initialize")
        %assign fcnReturns = "void"
        %assign fcnParams = "void"
        %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
          Category "model"; GeneratedBy "commonreglib.tlc"; Type "Initialize"; ...
          GeneratedFor FcnGeneratedFor(system); BlockDescription fcnBlockDescription}
        %<SLibDumpFunctionBanner(fcnRec)>
        %undef fcnRec
      %endif
      %<SLibIfNetPreprocessorCondition(system)>
      %<SLibGetFcnMemSecPragmaForSystem(fcnName, "MemSecFuncInitTerm", "Pre", system)>\
      %<fcnReturns> %<fcnName>(%<fcnParams>) {
        %<LibGetSystemField(system, "CachedInitializeDataBody")>
      }
      %<SLibGetFcnMemSecPragmaForSystem(fcnName, "MemSecFuncInitTerm", "Post", system)>\
      %<SLibEndIfNetPreprocessorCondition(system)>
      
      %closefile regBuf
      %% Check if the file exists
      %<SLibCacheSystemCodeToFile("sys_fcn_defn", system, regBuf)>
      
      %assign fileBaseName = SLibGetFileNameForSystemCode("mdl_src", system)
      %if fileBaseName != rootFile
        %openfile extRegBuf
        %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcnName, "MemSecFuncInitTerm", "Pre", system)>\
        %<LibExternInFcnDecls()> void %<fcnName>(void);
        %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcnName, "MemSecFuncInitTerm", "Post", system)>\
        %closefile extRegBuf
        %<SLibCacheSystemCodeToFile("sys_standalone_reg_fcn_decl", system, ...
          extRegBuf)>
      %endif

      %assign callBuf = callBuf + SLibIfNetPreprocessorCondition(system) + "\n"
      %assign callBuf = callBuf + "%<fcnName>();\n"
      %assign callBuf = callBuf + SLibEndIfNetPreprocessorCondition(system) + "\n"
      
    %endif
  %endforeach
  %if !WHITE_SPACE(callBuf)
    %assign callBuf = "/* Initialize subsystem data */\n" + callBuf
  %endif
  %% Testing
  %return callBuf
%endfunction

%% Function: SigSrcLivesInStandaloneSS =========================================
%% Abstract:
%%   Given a SigSrc of a record (like BlockOutputs, DWork, ...,) does it live 
%% in a standalone subsystem?  
%%
%%   sigSrc[0] = systemIdx
%%   sigSrc[1] = instanceIdx
%%
%% NOTE: The instance index of a SigSrc for a record may have -1 if the system
%% is root. Since we use this to index into an array, change it to 0 since
%% we know the root has only one instance.
%%
%function SigSrcLivesInStandaloneSS(sigSrc) void

  %% If the instance index is -1, we know it is root and 
  %% not a standalone system.
  %assign retVal = TLC_FALSE

  %if ((sigSrc[1] != -1) && System[sigSrc[0]].LivesInStandaloneSS[sigSrc[1]])
    %assign retVal = TLC_TRUE
  %endif
  
  %return retVal
%endfunction


%% Function: StandaloneParentSysIdxOfSigSrc ====================================
%% Abstract:
%%   Given a SigSrc of a record (like BlockOutputs, DWork, ...,) return the
%% standalone parent systemIdx.
%%
%%   sigSrc[0] = systemIdx
%%   sigSrc[1] = instanceIdx
%%
%% NOTE: The instance index of a SigSrc for a record may have -1 if the system
%% is root. Since we use this to index into an array, change it to 0 since
%% we know the root has only one instance.
%%
%function StandaloneParentSysIdxOfSigSrc(sigSrc) void

  %% If the instance index is -1, we know it is root and 
  %% not a standalone system.
  %assign retVal = -1
  %if ((sigSrc[1] != -1) && System[sigSrc[0]].LivesInStandaloneSS[sigSrc[1]])
    %assign retVal = System[sigSrc[0]].StandaloneParentSysIdx[sigSrc[1]]
  %endif
  
  %return retVal
%endfunction

%function StandaloneParentSysIdxOfDataRec(dataRec) void
  %assert !ISEMPTY(dataRec.SigSrc)
  %return StandaloneParentSysIdxOfSigSrc(SLibGetSystemAndCallSideIndex(dataRec))
%endfunction

%% Function: SLibInitBlockIOHelperOld ============================================
%% Abstract:
%%   This is a helper function for SLibInitBlockIO that collects fields for an
%%   optimized initialization loop that may not be MISRA-C compliant
%function SLibInitBlockIOHelperOld(ptrBlockIOLabel, startIdx, standaloneSSIdx) Output
  %assign blkioIsEmpty = ::CompiledModel.DWorkAndBlockIOCombined ? ...
    SLibModelDWorkStructIsEmpty() : SLibModelBlockIOStructIsEmpty()
  %if !blkioIsEmpty
    %%
    %assign memsetToZeroNeeded     = 0
    %%
    %openfile csgInitBuffer  %% for invariant, or signal object InitialValue
    %openfile straightInitBuffer
    %openfile useLoopVarInitBuffer
    %%
    %assign baseSystemIdx = GetBaseSystemIdx()
    %%
    %assign numElemInMemoryChunk = 0
    %%
    %assign prevSysIdx = -1
    %assign prevInstIdx = -1
    %assign prevDataTypeId = -1
    %assign prevMemsetToZeroSuffice = -1
    %%
    %assign numOutputsPlusOne = BlockOutputs.NumGlobalBlockOutputs + 1
    %assign changeInMemoryChunk = 0
    %%
    %assign localVoidPointerName = "pVoidBlockIORegion"
    %%
    %foreach loopIdx = (numOutputsPlusOne - startIdx)
      %assign boIdx = loopIdx + startIdx

      %if boIdx != BlockOutputs.NumGlobalBlockOutputs && ...
        ISEMPTY(BlockOutputs.GlobalBlockOutput[boIdx].SigSrc)
        %continue
      %endif

      %assign fInfo = GetFinalPassAndNextTransitionIndex(boIdx, standaloneSSIdx)
      %assign finalPass    = fInfo[0]
      %assign skipRecord   = fInfo[1]
      %assign nextStdIdx   = fInfo[2]
      %assign nextStartIdx = fInfo[3] 
      
      %if skipRecord
        %continue
      %endif

      %if !finalPass 
        %%
        %assign bo = BlockOutputs.GlobalBlockOutput[boIdx]
        %assign curSysIdx = System[bo.SigSrc[0]].HStructDeclSystemIdx
        %assign curInstIdx = bo.SigSrc[1]
        %assign curDataTypeId = LibGetDataTypeIdAliasedThruToFromId(LibGetRecordDataTypeId(bo))
        %%
        %if !ISEMPTY(bo.InitialValue)
          %if !FcnSkipDataInitialValueInReg(bo)
            %%
            %% If a non-empty initial value is provided for this block output
            %% then initialize it to that value. Initial values are provided
            %% for:
            %%
            %% - block output signals that have constant sample time but (for
            %%   various reasons) could not be declared invariant and placed
            %%   in the ConstBlockIO structure
            %%
            %% - non-imported-storage-class signals that have signal object
            %%   InitialValue applied on them
            %%
            %% For constant sample time signals, we always generate code for
            %% InitialValue regardless of remove zero initialization option.
            %% For non-constant sample time signals, we still check the option
            %%
            %if (bo.Invariant != "yes")
              %if SLibRemoveZeroInitForData(bo, bo.InitialValue)
                %continue
              %endif
            %endif
            %%
            %assign id = SLibGetBlockOutputIdentifierFromRecord(bo,baseSystemIdx)
            %selectfile csgInitBuffer
            %<FcnInitDataInitialValue(bo, id)>
          %endif
          %continue
        %endif
        %%
        %% InitialValue is empty.  Use default initial value then.
        %%
        %if SLibRemoveZeroInitForDataDefault(bo)
          %continue
        %endif
        %%
        %assign nterms = LibGetRecordWidth(bo)
        %if LibGetRecordIsComplex(bo)
          %assign nterms  = 2*nterms
        %endif
        %%
        %%if IndividualBlockIOInit || ...
        %if ...
         (curSysIdx     != prevSysIdx   )   || ...
          (curInstIdx    != prevInstIdx  )   || ...
          (curDataTypeId != prevDataTypeId )  
          %%
          %assign changeInMemoryChunk = 1
        %else
          %assign changeInMemoryChunk = 0
        %endif
        %%
        %if changeInMemoryChunk
          %%
          %assign curMemsetToZeroSuffice = FcnMemsetToZeroInitSuffice(curDataTypeId)
          %%
          %if curMemsetToZeroSuffice
            %%
            %assign memsetToZeroNeeded = 1
          %endif
        %endif
      %endif  %% if !finalPass
      %%
      %if changeInMemoryChunk || finalPass
        %%
        %% output code to initialize prior chunk of memory
        %%
        %if  ( numElemInMemoryChunk > 0 ) && ...
             !prevMemsetToZeroSuffice
          %%
          %assign prevDataTypeDefaultInitValue = ...
	    SLibGetDefaultInitialValueFromId(prevDataTypeId)
          %assign prevDataTypeName             = ...
	    LibGetDataTypeNameFromId(prevDataTypeId)
          %%
          %if FcnSuitableForMemset(prevDataTypeDefaultInitValue, prevDataTypeId, "") && ...
            FcnPreferMemsetToAssignment(numElemInMemoryChunk, prevDataTypeId)
            %%
            %selectfile straightInitBuffer
            %assign sanitizedInitValue = ...
              FcnCastValueForMemsetUse(prevDataTypeId, prevDataTypeDefaultInitValue)
            (void) %<LibGenMemFcnCall("memset", prevStartAddr, sanitizedInitValue, ...
              "%<numElemInMemoryChunk>*sizeof(%<prevDataTypeName>)")>;
          %else
            %if numElemInMemoryChunk > 1
              %% 
              %selectfile useLoopVarInitBuffer
              %<localVoidPointerName> = (void *)(%<prevStartAddr>);
              for (i = 0; i < %<numElemInMemoryChunk>; i++) {
                ((%<prevDataTypeName>*)%<localVoidPointerName>)[i] = ...
		  %<prevDataTypeDefaultInitValue>;
              }
            %else
              %selectfile straightInitBuffer
              ((%<prevDataTypeName>*)%<prevStartAddr>)[0] = ...
		%<prevDataTypeDefaultInitValue>;
            %endif
          %endif
        %endif
        %%
        %if !finalPass
          %assign prevSysIdx              = curSysIdx
          %assign prevInstIdx             = curInstIdx
          %assign prevDataTypeId          = curDataTypeId
          %assign prevMemsetToZeroSuffice = curMemsetToZeroSuffice
          %%
          %assign numElemInMemoryChunk = 0
          %%
          %if prevMemsetToZeroSuffice
            %assign prevStartAddr = "#error do not use address: memset zero sufficient"
          %else
            %% Caution: don't get address unless it will be used.  The act of getting  
            %% the address marks BlockIO as being accessed.  Based on this mark,
            %% code generation will declare a BlockIO variable.  These declaration
            %% could even occur in some other function unrelated to BlockIO 
            %% initialization such as mdlTerminate.
            %%
            %assign prevStartAddr = SLibGetBlockOutputFromRecord(bo,baseSystemIdx)
          %endif
        %endif
      %endif  %% if changeInMemoryChunk || finalPass
      %%
      %if !finalPass
        %assign numElemInMemoryChunk = numElemInMemoryChunk + nterms
      %endif

      %if finalPass
        %break
      %endif
    %endforeach  %% for each boIdx
    %%
    %closefile csgInitBuffer
    %closefile straightInitBuffer
    %closefile useLoopVarInitBuffer
    %%
    %if memsetToZeroNeeded
      %if standaloneSSIdx == -1
        %assign blockIOType = IsModelReferenceTarget() ? ...
          System[NumSystems-2].Interface.tsysBlockIOType : tBlockIOType
        (void) %<LibGenMemFcnCall("memset", ptrBlockIOLabel, "0", ...
          "sizeof(%<blockIOType>)")>;
        %<SLibAccessArgHelper(System[baseSystemIdx].Interface.BlockIOArgDef,"","")>
      %else
        %assign type = System[standaloneSSIdx].Interface.tsysBlockIOType
        %assign var = "(void *) &" + System[standaloneSSIdx].Interface.tsysBlockIO
 
        (void) %<LibGenMemFcnCall("memset", var, "0", "sizeof(%<type>)")>;
      %endif
    %endif
    %%
    %if  !WHITE_SPACE(csgInitBuffer) ...
      || !WHITE_SPACE(straightInitBuffer) ...
      || !WHITE_SPACE(useLoopVarInitBuffer)
      %% SLibGetBlockOutputFromRecord above took care of LibAccessArg
      {
        %if  !WHITE_SPACE(useLoopVarInitBuffer)
          int_T i;
          void *%<localVoidPointerName>;
          %<useLoopVarInitBuffer>\
        %endif
        %<straightInitBuffer>\
        %<csgInitBuffer>\
      }
    %endif
  %endif
  %return [%<nextStdIdx>, %<nextStartIdx>]
%endfunction %% SLibInitBlockIOHelperOld

%% Function: LocalInitDworkVectorOld ==============================================
%% Abstract:
%%   Does not check remove zero initialization option.  Caller should do that.
%%   This is only called by the old DWork initialization code (pre-2008b)
%%
%function LocalInitDworkVectorOld(stdSSBuf, stdIdx, ...
  initCount, contents, initValue, dType, baseAddr, ppIf, ppFi) void
  
  %openfile tmpBuf
  %<ppIf>
  %if initCount == 1
    %<contents> = %<initValue>;
  %elseif initCount >= RollThreshold
    %% use a loop
    {
      int_T i;
      %<dType> *dwork_ptr = (%<dType> *) %<baseAddr>;
      
      for (i = 0; i < %<initCount>; i++) {
	dwork_ptr[i] = %<initValue>;
      }
    }
  %else
    %% do not use loop
    {
      %<dType> *dwork_ptr = (%<dType> *) %<baseAddr>;
      %foreach initIdx = initCount
	dwork_ptr[%<initIdx>] = %<initValue>;
      %endforeach
    }
    %%
  %endif
  %<ppFi>
  %closefile tmpBuf

  %% Add the initialization code to the right buffer
  %assign stdSSBuf.DWorkBuff[stdIdx].initBuffer = ...
    stdSSBuf.DWorkBuff[stdIdx].initBuffer + tmpBuf
  
  %return stdSSBuf
%endfunction %%LocalInitDworkVectorOld

%% Function: SLibInitDWorkOld =====================================================
%% Abstract:
%%   Initialize DWork structure (ie. those with internal storage) to zero
%%   Memset entire DWork structure to 0 if non-floating elements exist.
%%   Assign double and single floating-point elements to 0.0
%%
%%   This function returns vector with three values [numeric, numeric, string]:
%%     haveFloat  - found at least one floating-point region
%%     needMemset - found at least one non-floating-point region
%%     initBuffer - buffer with floating-point assignments to 0.0
%%
%function SLibInitDWorkOld(stdSSBuf) void
  %assign prevDataTypeIdx   = -1
  %assign prevStdIdx = -1
  %assign initCount  = 0

  %foreach dwIdx = DWorks.NumNonLocalDWorks
    %assign dwRec  = DWorks.DWork[dwIdx]
    %%
    %if dwRec.StorageClass != "Auto" || dwRec.OptimizedAwayInTLC
      %continue
    %endif

    %assign idx = SLibGetSystemAndCallSideIndex(dwRec)
    %if SigSrcLivesInStandaloneSS(idx)
      %assign baseSystemIdx = StandaloneParentSysIdxOfDataRec(dwRec)
    %else
      %assign baseSystemIdx = GetBaseSystemIdx()
    %endif
    %assign stdIdx = System[baseSystemIdx].IndexInStandaloneSubsystemArray

    %% InitialValue is not provided.  Use default initial value then.
    %if SLibRemoveZeroInitForDataDefault(dwRec)
      %continue
    %endif
    %%
    %assign nterms = SLibDWorkWidth(dwRec)
    %assign isComplex = SLibDWorkIsComplex(dwRec)
    %assign ppStuff = SLibDataPreprocessorStuff(dwRec)
    %assign ppIf = ppStuff[0]
    %assign ppFi = ppStuff[1]
    
    %% Data type transition or standalone subsystem transition
    %if prevDataTypeIdx != SLibDWorkDataTypeId(dwRec) || prevStdIdx != stdIdx
      
      %if initCount > 0
        %assign stdSSBuf.DWorkBuff[prevStdIdx].haveFloat = 1
        %% Need to set floating-point dworks explicitly to 0.0
        %assign dType = LibGetDataTypeNameFromId(prevDataTypeIdx)
        %assign defaultInitialValue = SLibGetDefaultInitialValueFromId(prevDataTypeIdx)
        %%
        %assign stdSSBuf = ...
          LocalInitDworkVectorOld(stdSSBuf, prevStdIdx, ...
          initCount, contents, defaultInitialValue, dType, baseAddr, ppIf, ppFi)
        %%
        %assign initCount = 0
      %endif
      %assign prevDataTypeIdx  = SLibDWorkDataTypeId(dwRec)
      %assign prevStdIdx       = stdIdx
      %if (LibGetDataTypeIdAliasedThruToFromId(prevDataTypeIdx) == tSS_DOUBLE || ...
        LibGetDataTypeIdAliasedThruToFromId(prevDataTypeIdx) == tSS_SINGLE)
        %if InitFltsAndDblsToZero
          %assign name       = FcnGetDWorkIdentifier(dwRec, baseSystemIdx)
          %assign dataLayout = SLibGetDataLayout(dwRec)
          %assign reim       = isComplex ? ".%<tRealPart>" : ""
          %assign initCount  = isComplex ? nterms * 2 : nterms
          %assign contents   = "%<name>%<dataLayout[3]>%<reim>"
          %assign baseAddr   = "&%<contents>"
        %elseif SLibZeroMemory("DWork")
          %assign stdSSBuf.DWorkBuff[stdIdx].needMemset = 1
        %endif
      %elseif (prevDataTypeIdx>1) && SLibZeroMemory("DWork")
        %assign stdSSBuf.DWorkBuff[stdIdx].needMemset = 1
      %endif
    %else
      %if LibGetDataTypeIdAliasedThruToFromId(prevDataTypeIdx) == tSS_DOUBLE ||...
        LibGetDataTypeIdAliasedThruToFromId(prevDataTypeIdx) == tSS_SINGLE
        %if InitFltsAndDblsToZero
          %assign nterms = isComplex ? nterms * 2 : nterms
          %assign initCount = initCount + nterms
        %elseif SLibZeroMemory("DWork")
          %assign stdSSBuf.DWorkBuff[stdIdx].needMemset = 1
        %endif
      %endif
    %endif
  %endforeach
  %if initCount > 0
    %assert(prevStdIdx == stdIdx)
    %assign stdSSBuf.DWorkBuff[prevStdIdx].haveFloat= 1
    %% Need to set floating-point dworks explicitly to 0.0
    %assign dType = LibGetDataTypeNameFromId(prevDataTypeIdx)
    %assign defaultInitialValue = SLibGetDefaultInitialValueFromId(prevDataTypeIdx)
    %assign stdSSBuf = ...
      LocalInitDworkVectorOld(stdSSBuf,prevStdIdx, ...
      initCount, contents, defaultInitialValue, dType, baseAddr, ppIf, ppFi)
  %endif
  
  %if stdSSBuf.DWorkBuff[0].needMemset
    %assert(!IsModelReferenceTarget())
    %assign baseSystemIdx = GetBaseSystemIdx()
    %<SLibAccessArgHelper(System[baseSystemIdx].Interface.DWorkArgDef,"","")>
  %endif
  %% SLibGetDataLayout above took care of LibAccessArg for what's in initBuffer
  %return stdSSBuf

%endfunction  %% SLibInitDWorkOld

%endif %% _REGLIB_

%% [EOF] commonreglib.tlc
