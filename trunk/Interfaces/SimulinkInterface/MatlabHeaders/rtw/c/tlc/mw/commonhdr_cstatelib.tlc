%% 
%% 
%% 
%%
%% Copyright 1994-2012 The MathWorks, Inc.
%%
%% Abstract:
%%   This system TLC library file contains functions that are common
%%   between the different code generators for producing the the model's
%%   continues states  structure definition.

%if EXISTS("_COMMONHDR_CSTATELIB_") == 0
%assign _COMMONHDR_CSTATELIB_ = 1

%% ============================================================================
%% Create global cache variables to hold each structure definition
%% Note: These will hold only the outermost structure definition and are used 
%% only for determining if they are empty or not for adding a free line
%% to the Terminate function.
%% ============================================================================

%<LibAddToCompiledModel("ContStatesStructDefn", 0)>
%<LibAddToCompiledModel("PrevZCStatesStructDefn", 0)>
%<LibAddToCompiledModel("ZCSignalValueStructDefn", 0)>

%% Function: SLibGetSystemCStates  ===========================================
%% Abstract:
%%      Returns the contents of a system's Continuous State structure.
%% 
%function SLibGetSystemCStates(sysIdx)
  %assign sysCStates    = ""
  %assign cstatesArg    = System[sysIdx].Interface.ContStatesArgDef
  %assign childTypeDefs = ...
    FcnGetChildSystemTypedefs(sysIdx, "CStates", "ContStates")
  %assign numElements   = childTypeDefs[1]
  %assign res           = ["", 0]
  %openfile sysCStates
  %if cstatesArg.NumFlatFields > 0
    %with ::CompiledModel.ContStates
      %foreach csIdx = cstatesArg.NumFlatFields
	%assign cs = ContState[cstatesArg.FirstLocation + csIdx]
	%with cs
	  %assign comment  = "/* '%<SLibGrBlockName(GrSrc)>' */"
          %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
          %if isMdlRef
            %assign blk = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
	    %assign intrf = GetModelrefInterface(blk)
            %assign width = CAST("Number", %<intrf.xOptWidth>)
            %assert (width > 0)
            %assign optWidth = LibOptionalVectorWidth(width)
            %<intrf.xDataType> %<Identifier>%<optWidth>;  %<comment>
	  %else
	    %assign optWidth = LibOptionalVectorWidth(Width)
	    real_T %<Identifier>%<optWidth>; %<comment>
	  %endif
	  %assign numElements = numElements + 1
	%endwith %% cs
      %endforeach
    %endwith
  %endif
  %<childTypeDefs[0]>\
  %closefile sysCStates
  %assert (LibGetFieldSet(System[sysIdx], "HasCStatesArg") == 0)
  %if numElements > 0
    %assign System[sysIdx].HasCStatesArg = 1
  %endif
  %<LibSetFieldSet(System[sysIdx], "HasCStatesArg")>
  %if numElements > 0
    %assign res[0] = "%<sysCStates>"
    %assign res[1] = %<numElements>
  %endif
  %return res %% return [%<sysCStates>, %<numElements>] 
%endfunction

%% Function: LibCacheSystemCStatesStructDef  =========================
%% Abstract:
%%   Cache the definition of the system's continuous states structure.
%function LibCacheSystemCStatesStructDef(sysIdx) void
  %if !SLibSystemHasOwnDataScope(System[sysIdx])
    %return
  %endif
  %assign cstatesBuff = SLibGetSystemCStates(sysIdx)
  %assign cstatesDef = ""
  %if (sysIdx < (NumSystems-1))
    %assign identifier = FcnSysVarGroupType(System[sysIdx],"ContStates")
    %assign sysInfo = GetSystemNameForComments(System[sysIdx])
    %openfile comment
    /* Continuous states for %<sysInfo> */
    %closefile comment
  %else
    %assign ::CompiledModel.ContStatesStructDefn = ...
      WHITE_SPACE(cstatesBuff[0])?"":"Nonempty"
    %assign identifier = tContStateType
    %openfile comment
    /* Continuous states (auto storage) */
    %closefile comment
  %endif

  %assign userTypes = LibDumpTypedefsCache()
  %assign ::CompiledModel.TypedefsCache = ""
  %if cstatesBuff[1] > 0 
    %openfile cstatesDef
    %<userTypes>\
    
    %<comment>\
    %<GetHideChildDefineSymbol("ifndef")>\
    typedef struct {
      %<cstatesBuff[0]>
    } %<identifier>;
    %<GetHideChildDefineSymbol("endif")>\

    %closefile cstatesDef
  %endif
  %%
  %<SLibCacheSystemCodeToFile("sys_data_continue_typedef", System[sysIdx], cstatesDef)>
%endfunction

%% Function:  SLibGetNonContDerivSig =========================================
%% Abstract:
%%    Set up the cache data typedef for discrete derivative signal
%function SLibGetNonContDerivSig() void
  %openfile nonContDerivSig
  %if SolverType == "VariableStep" && ...
    CodeFormat == "S-Function" && !Accelerator
    %assign nDU = SolverResetInfo.NumNonContDerivSignals
    %if nDU > 0
      %assign dU  = "nonContDerivSigCache"
      %<GetHideChildDefineSymbol("ifndef")>\
      typedef struct {
	%foreach idx = nDU
	  %%
	  %assign sigSrc = SolverResetInfo.NonContDerivSignal[idx].SigSrc
	  %assign startEl = SolverResetInfo.NonContDerivSignal[idx].StartEl
	  %assign regLen = SolverResetInfo.NonContDerivSignal[idx].RegionLen
	  %%
	  %assign idNum = IDNUM(sigSrc)
	  %assert (idNum[0] == "B")
	  %if idNum[1] < BlockOutputs.NumGlobalBlockOutputs
	    %assign bo = BlockOutputs.GlobalBlockOutput[idNum[1]]
	    %assert (LibGetRecordWidth(bo) >= regLen + startEl)
	    %assert (bo.Invariant == "no")
	    %assert (!LibGetRecordIsComplex(bo))
	  %else
	    %assign nExternalOp = BlockOutputs.NumExternalBlockOutputs
	    %foreach iExOp = nExternalOp
	      %if BlockOutputs.ExternalBlockOutput[iExOp].LogicalSrc == sigSrc
		%assign bo = BlockOutputs.ExternalBlockOutput[iExOp]
		%break
	      %endif
	    %endforeach
	  %endif
	  %assign opW  = (LibGetRecordWidth(bo) == 1) ? "" : "[%<startEl>]"
	  %assign dType = LibGetDataTypeNameFromId(LibGetRecordDataTypeId(bo))
	  %assign sizeInBytes = "%<regLen>*sizeof(%<dType>)"
	  char cache_%<idx>[%<sizeInBytes>];
	%endforeach
      } %<dU>;
      %<GetHideChildDefineSymbol("endif")>\
    %endif
  %endif
  
  %closefile nonContDerivSig
  %<SLibCacheSystemCodeToFile("sys_data_discrete_typedef", System[NumSystems-1], ...
    nonContDerivSig)>
%endfunction

%% Function:  SLibGetSystemCStatesDeriv  =====================================
%% Abstract:
%%   Returns the contents of a system's Continuous State Derivatives structure.
%% 
%function SLibGetSystemCStatesDeriv(sysIdx) void
  %assign sysCStates    = ""
  %assign cstatesArg    = System[sysIdx].Interface.ContStatesArgDef
  %assign childTypeDefs = ...
    FcnGetChildSystemTypedefs(sysIdx, "CStatesDeriv", "ContStatesDerivative")
  %assign numElements   = childTypeDefs[1]
  %assign res           = ["", 0]
  %openfile sysCStates
  %if cstatesArg.NumFlatFields > 0
    %with ::CompiledModel.ContStates
      %foreach csIdx = cstatesArg.NumFlatFields
	%assign cs = ContState[cstatesArg.FirstLocation + csIdx]
	%with cs
	  %assign comment  = "/* '%<SLibGrBlockName(GrSrc)>' */"
          %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
          %if isMdlRef
            %assign blk = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
	    %assign intrf = GetModelrefInterface(blk)
            %assign width = CAST("Number", %<intrf.xOptWidth>)
            %assert (width > 0)
            %assign optWidth = LibOptionalVectorWidth(width)
            %<intrf.xDotDataType> %<Identifier>%<optWidth>;  %<comment>
	  %else
	    %assign optWidth = LibOptionalVectorWidth(Width)
	    real_T %<Identifier>%<optWidth>; %<comment>
	  %endif
	  %assign numElements = numElements + 1
	%endwith %% cs
      %endforeach
    %endwith
  %endif
  %<childTypeDefs[0]>\
  %closefile sysCStates
  %assert (LibGetFieldSet(System[sysIdx], "HasCStatesDerivArg") == 0)
  %if numElements > 0
    %assign System[sysIdx].HasCStatesDerivArg = 1
  %endif
  %<LibSetFieldSet(System[sysIdx], "HasCStatesDerivArg")>
  %if numElements > 0
    %assign res[0] = "%<sysCStates>"
    %assign res[1] = %<numElements>
  %endif
  %return res %% return [%<sysCStates>, %<numElements>] 
%endfunction

%% Function: LibCacheSystemStateDerivStructDef =========================
%% Abstract:
%%   Cache the definition of the system's continuous states derivatives
%%   structure.
%function LibCacheSystemStateDerivStructDef(sysIdx) void
  %if !SLibSystemHasOwnDataScope(System[sysIdx])
    %return
  %endif
  %assign cstatesDerivBuff = LibIsMultiSolver() ? ...
    SLibDeploymentGetSystemCStatesDeriv(sysIdx) : SLibGetSystemCStatesDeriv(sysIdx)
  %assign cstatesDerivDef = ""
  %if (sysIdx < (NumSystems-1))
    %assign identifier = FcnSysVarGroupType(System[sysIdx],"ContStatesDerivative")
    %assign sysInfo = GetSystemNameForComments(System[sysIdx])
    %openfile comment
    /* State derivatives for %<sysInfo> */
    %closefile comment
  %else
    %assign identifier = tXdotType
    %openfile comment
    /* State derivatives (auto storage) */
    %closefile comment
  %endif

  %assign userTypes = LibDumpTypedefsCache()
  %assign ::CompiledModel.TypedefsCache = ""
  %if cstatesDerivBuff[1] > 0 
    %openfile cstatesDerivDef
    %<userTypes>\
    
    %if LibIsMultiSolver()
      %<cstatesDerivBuff[0]>\
    %else
      %<comment>\
      %<GetHideChildDefineSymbol("ifndef")>\
      typedef struct {
        %<cstatesDerivBuff[0]>
      } %<identifier>;
      %<GetHideChildDefineSymbol("endif")>\
    %endif
    
    %closefile cstatesDerivDef
  %endif
  %%
  %<SLibCacheSystemCodeToFile("sys_data_continue_typedef", System[sysIdx], ...
    cstatesDerivDef)>
%endfunction

%% Function:  SLibGetSystemContStatesDisabled  =====================================
%% Abstract:
%%   Returns the contents of a system's continuous state disabled structure.
%% 
%function SLibGetSystemContStatesDisabled(sysIdx)
  %assign sysCStates    = ""
  %assign cstatesArg    = System[sysIdx].Interface.ContStatesArgDef
  %assign childTypeDefs = ...
    FcnGetChildSystemTypedefs(sysIdx, "ContStatesDisabled", "ContStatesDisabled")
  %assign numElements   = childTypeDefs[1]
  %assign res           = ["", 0]
  %openfile sysCStates
  %if cstatesArg.NumFlatFields > 0
    %with ::CompiledModel.ContStates
      %foreach csIdx = cstatesArg.NumFlatFields
	%assign cs = ContState[cstatesArg.FirstLocation + csIdx]
	%with cs
	  %assign comment  = "/* '%<SLibGrBlockName(GrSrc)>' */"
          %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
          %if isMdlRef
            %assign blk = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
	    %assign intrf = GetModelrefInterface(blk)
            %assign width = CAST("Number", %<intrf.xOptWidth>)
            %assert (width > 0)
            %assign optWidth = LibOptionalVectorWidth(width)
            %<intrf.xDisDataType> %<Identifier>%<optWidth>;  %<comment>
	  %else
	    %assign optWidth = LibOptionalVectorWidth(Width)
	    boolean_T %<Identifier>%<optWidth>; %<comment>
	  %endif
	  %assign numElements = numElements + 1
	%endwith %% cs
      %endforeach
    %endwith
  %endif
  %<childTypeDefs[0]>\
  %closefile sysCStates
  %assert (LibGetFieldSet(System[sysIdx], "HasContStatesDisabledArg") == 0)
  %if numElements > 0
    %assign System[sysIdx].HasContStatesDisabledArg = 1
  %endif
  %<LibSetFieldSet(System[sysIdx], "HasContStatesDisabledArg")>
  %if numElements > 0
    %assign res[0] = "%<sysCStates>"
    %assign res[1] = %<numElements>
  %endif
  %return res %% return [%<sysCStates>, %<numElements>] 
%endfunction

%% Function: LibCacheSystemStateDiabledStructDef  =========================
%% Abstract:
%%   Cache the definition of the system's continuous states disabled
%%   structure.
%function LibCacheSystemStateDisabledStructDef(sysIdx) void
  %if !SLibSystemHasOwnDataScope(System[sysIdx])
    %return
  %endif
  %assign cstatesDisabledBuff = SLibGetSystemContStatesDisabled(sysIdx)
  %assign cstatesDisabledDef = ""
  %if (sysIdx < (NumSystems-1))
    %assign identifier = FcnSysVarGroupType(System[sysIdx],"ContStatesDisabled")
    %assign sysInfo = GetSystemNameForComments(System[sysIdx])
    %openfile comment
    /* State Disabled for %<sysInfo> */
    %closefile comment
  %else
    %assign identifier = tXdisType
    %openfile comment
    /* State disabled  */
    %closefile comment
  %endif

  %assign userTypes = LibDumpTypedefsCache()
  %assign ::CompiledModel.TypedefsCache = ""
  %if cstatesDisabledBuff[1] > 0 
    %openfile cstatesDisabledDef
    %<userTypes>\
    
    %<comment>\
    %<GetHideChildDefineSymbol("ifndef")>\
    typedef struct {
      %<cstatesDisabledBuff[0]>
    } %<identifier>;
    %<GetHideChildDefineSymbol("endif")>\

    %closefile cstatesDisabledDef
  %endif
  %%
  %<SLibCacheSystemCodeToFile("sys_data_continue_typedef", System[sysIdx], ...
    cstatesDisabledDef)>
%endfunction


%% Function:  SLibGetSystemContStatesAbsoluteTolerance  =====================================
%% Abstract:
%%   Returns the contents of a system's continuous state AbsoluteTolerance structure.
%% 
%function SLibGetSystemContStatesAbsoluteTolerance(sysIdx)
  %assign sysCStates    = ""
  %assign cstatesArg    = System[sysIdx].Interface.ContStatesArgDef
  %assign childTypeDefs = ...
    FcnGetChildSystemTypedefs(sysIdx, "ContStatesAbsoluteTolerance", "ContStatesAbsoluteTolerance")
  %assign numElements   = childTypeDefs[1]
  %assign res           = ["", 0]
  %% Only generate absolute tolerance structure when the solver is variable-step
  %if (::CompiledModel.SolverType == "VariableStep") 
    %openfile sysCStates
    %if cstatesArg.NumFlatFields > 0
      %with ::CompiledModel.ContStates
        %foreach csIdx = cstatesArg.NumFlatFields
          %assign cs = ContState[cstatesArg.FirstLocation + csIdx]
          %with cs
            %assign comment  = "/* '%<SLibGrBlockName(GrSrc)>' */"
            %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
            %if isMdlRef
              %assign blk = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
              %assign intrf = GetModelrefInterface(blk)
              %assign width = CAST("Number", %<intrf.xOptWidth>)
              %assert (width > 0)
              %% Type can be empty if referenced model is built with fixed-step
              %% solver setting but still has continuous states
              %if (!ISEMPTY(intrf.xAbsTolDataType))
                %% Use actual abstol width and structure
                %assign optWidth = LibOptionalVectorWidth(width)
                %<intrf.xAbsTolDataType> %<Identifier>%<optWidth>;  %<comment>
              %else
                %% Use real_T type and cstate width because there is no structure
                %% It is important to set this correct because further offset will
                %% be otherwise incorrect.
                real_T %<Identifier>[%<Width>];  %<comment>
              %endif
            %else
              %assign optWidth = LibOptionalVectorWidth(Width)
              real_T %<Identifier>%<optWidth>; %<comment>
            %endif
            %assign numElements = numElements + 1
          %endwith %% cs
        %endforeach
      %endwith
    %endif
    %<childTypeDefs[0]>\
    %closefile sysCStates
  %endif %%if variable step solver
  
  %assert (LibGetFieldSet(System[sysIdx], "HasContStatesAbsoluteToleranceArg") == 0)
  %if numElements > 0
    %assign System[sysIdx].HasContStatesAbsoluteToleranceArg = 1
  %endif
  %<LibSetFieldSet(System[sysIdx], "HasContStatesAbsoluteToleranceArg")>
  %if numElements > 0
    %assign res[0] = "%<sysCStates>"
    %assign res[1] = %<numElements>
  %endif
  %return res %% return [%<sysCStates>, %<numElements>] 
%endfunction


%% Function: LibCacheSystemStateDiabledStructDef  =========================
%% Abstract:
%%   Cache the definition of the system's continuous states Absolute
%%   Tolerance structure.
%function LibCacheSystemCStateAbsoluteToleranceStructDef(sysIdx) void
  %if !SLibSystemHasOwnDataScope(System[sysIdx])
    %return
  %endif
  %assign cstatesAbsoluteToleranceBuff = SLibGetSystemContStatesAbsoluteTolerance(sysIdx)
  %assign cstatesAbsoluteToleranceDef = ""
  %if (sysIdx < (NumSystems-1))
    %assign identifier = FcnSysVarGroupType(System[sysIdx],"ContStatesAbsoluteTolerance")
    %assign sysInfo = GetSystemNameForComments(System[sysIdx])
    %openfile comment
    /* Continuous State Absolute Tolerance for %<sysInfo> */
    %closefile comment
  %else
    %assign identifier = tXAbsTolType
    %openfile comment
    /* Continuous State Absolute Tolerance  */
    %closefile comment
  %endif

  %assign userTypes = LibDumpTypedefsCache()
  %assign ::CompiledModel.TypedefsCache = ""
  %if cstatesAbsoluteToleranceBuff[1] > 0 
    %openfile cstatesAbsoluteToleranceDef
    %<userTypes>\
    
    %<comment>\
    %<GetHideChildDefineSymbol("ifndef")>\
    typedef struct {
      %<cstatesAbsoluteToleranceBuff[0]>
    } %<identifier>;
    %<GetHideChildDefineSymbol("endif")>\

    %closefile cstatesAbsoluteToleranceDef
  %endif
  %%
  %<SLibCacheSystemCodeToFile("sys_data_continue_typedef", System[sysIdx], ...
    cstatesAbsoluteToleranceDef)>
%endfunction


%% Function: SLibGetSystemZCEvent ==============================================
%% Abstract:
%%   Returns the contents of a systems ZCEvent structure.
%%
%function SLibGetSystemZCEvent(sysIdx) void
  %assign blkZcRecArg        = System[sysIdx].Interface.ZCSVArgDef
  %% 
  %assign sysZCEvent    = ""
  %assign childTypeDefs = ...
    FcnGetChildSystemTypedefs(sysIdx, "ZCEvent", "ZCEvent")
  %assign numElements   = childTypeDefs[1]
  %assign res           = ["", 0]
  %openfile sysZCEvent
  %if blkZcRecArg.NumFlatFields > 0 
    %with ::CompiledModel.ZcRec
      %foreach zcRecIdx = blkZcRecArg.NumFlatFields
        %assign zcRec = BlkZcRec[blkZcRecArg.FirstLocation + zcRecIdx]
        %assign comment  = "/* %<SLibGrBlockCommentName(zcRec.GrSrc)> */"
        %foreach zcsIdx  = zcRec.NumZcSignalInfos
          %assign zcsInfo  = zcRec.ZcSignalInfo[zcsIdx] 
          %assign name  = FcnGetZCEventCGVarName(zcsInfo)
          %assign width = FcnGetZCEventCGVarWidth(zcsInfo)
          %assign optWidth = LibOptionalVectorWidth(width)
          ZCSigState %<name>%<optWidth>; %<comment>
          %assign numElements = numElements + 1
        %endforeach        
      %endforeach
    %endwith
  %endif  
  %<childTypeDefs[0]>\
  %closefile sysZCEvent
  %assert (LibGetFieldSet(System[sysIdx], "HasZCEventArg") == 0)
  %if numElements > 0
    %assign System[sysIdx].HasZCEventArg = 1
    %% For model reference, we igore anything set in the root system
    %if !(IsModelReferenceTarget() && (NumSystems-1 == sysIdx))
      %assign ::CompiledModel.HasZCEventArg = 1
    %endif
  %endif
  %<LibSetFieldSet(System[sysIdx], "HasZCEventArg")>
  %if numElements > 0
    %assign res[0] = "%<sysZCEvent>"
    %assign res[1] = %<numElements>
  %endif
  %return res
%endfunction


%% Function: LibCacheSystemZCEStructDef ========================================
%% Abstract:
%%   Cache the definition of the system ZCE structure.
%%
%function LibCacheSystemZCEStructDef(sysIdx) void
  %if !SLibSystemHasOwnDataScope(System[sysIdx])
    %return
  %endif
  %assign zceBuff = SLibGetSystemZCEvent(sysIdx)
  %assign zceDef = ""
  %assign identifierTag = ""
  %if (sysIdx < (NumSystems-1))
    %assign identifier = FcnSysVarGroupType(System[sysIdx],"ZCEvent")
    %if IsModelReferenceTarget() && GenerateClassInterface && ...
        IsModelReferenceBaseSys(System[sysIdx])
      %assign identifier = tPrevZCStateType
    %endif
    %assign sysInfo = GetSystemNameForComments(System[sysIdx])
    %openfile comment
    /* Zero-crossing (trigger) state for %<sysInfo> */
    %closefile comment
  %else
    %assign ::CompiledModel.PrevZCStatesStructDefn = ...
      WHITE_SPACE(zceBuff[0])?"":"Nonempty"
    %assign identifier = tPrevZCStateType
    %if SLibAutosarActive()
      %assign identifierTag = ::CompiledModel.GlobalScope.tPrevZCStateTypeTag
    %endif
    %openfile comment
    /* Zero-crossing (trigger) state */
    %closefile comment
  %endif
  %%
  %assign userTypes = LibDumpTypedefsCache()
  %assign ::CompiledModel.TypedefsCache = ""
  %if zceBuff[1] > 0 
    %openfile zceDef
    %<userTypes>\
      %<comment>\
      %assign nonInlSysIdx = System[sysIdx].NonInlinedParentSystemIdx
      %if !LibSystemIsReusedLibraryFcn(System[nonInlSysIdx])
        %<GetHideChildDefineSymbol("ifndef")>\
      %endif
      %<SLibIfNetPreprocessorCondition(System[sysIdx])>
      typedef struct %<identifierTag> {
        %<zceBuff[0]>
      } %<identifier>;
      %<SLibEndIfNetPreprocessorCondition(System[sysIdx])>
      %if !LibSystemIsReusedLibraryFcn(System[nonInlSysIdx])
        %<GetHideChildDefineSymbol("endif")>\
      %endif
    %closefile zceDef
  %endif
  %%
  %if CodeFormat == "Ada"
    %if (System[sysIdx].Type == "root")
      %assign parentSystem = System[sysIdx]
    %else
      %assign parentSystem = System[System[sysIdx].FileNameOwnerIdx]
    %endif
    %<LibAddToSystemField(parentSystem, "SystemTypeDefs", zceDef)>
  %else
    %<SLibCacheSystemCodeToFile("sys_data_ZCE_typedef", System[sysIdx], zceDef)>
  %endif
%endfunction

%%adzc
%% Function: SLibGetSystemZcSignalValue ======================================
%% Abstract:
%%   Returns the contents of a systems ZcSignalInfo structure.
%%
%function SLibGetSystemZCSignalValue(sysIdx) void
  %assign zcArg        = System[sysIdx].Interface.ZCSVArgDef
  %assign childTypeDefs = ...
    FcnGetChildSystemTypedefs(sysIdx, "ZCSignalValue", "ZCSV")
  %assign numElements   = childTypeDefs[1]
  %assign res           = ["", 0]

  %% For a referenced model that may be used in a variable step solver
  %% (either the SIM target or RSIM target), we need to generate the
  %% typedef for zc signals, even if it contains only discrete signals.
  %if ((::CompiledModel.NumNonsampledZCs > 0) || ...
       (IsModelReferenceForASimstructBasedTarget()))
    %openfile sysZCSignalValue
    %if zcArg.NumFlatFields > 0
      %with ::CompiledModel.ZcRec
        %foreach zcRecIdx = zcArg.NumFlatFields
          %assign zcRec = BlkZcRec[zcArg.FirstLocation + zcRecIdx]
          %assign comment  = "/* %<SLibGrBlockCommentName(zcRec.GrSrc)> */"
          %assign blk = System[zcRec.SigSrc[0]].Block[zcRec.SigSrc[2]]
          %%if !Accelerator && zcsInfo.ZcSignalType != "Discrete" || Accelerator
            %if (TYPE(blk.Type) == "Identifier" && blk.Type == "ModelReference")
              %assign intrf = GetModelrefInterface(blk)
              %assign width = CAST("Number", %<intrf.zcOptWidth>)
              %assert (width > 0)
              %assign optWidth = LibOptionalVectorWidth(width)
              %assign zcsInfo  = zcRec.ZcSignalInfo[0] 
              %assign name     = FcnGetZCSignalCGVarName(zcsInfo)
              %<intrf.zcDataType> %<name>%<optWidth>;  %<comment>
            %else                
              %foreach zcsIdx  = zcRec.NumZcSignalInfos
                %assign zcsInfo  = zcRec.ZcSignalInfo[zcsIdx] 
                %assign name  = FcnGetZCSignalCGVarName(zcsInfo)
                %assign width = FcnGetZCSignalCGVarWidth(zcsInfo)
                %assign optWidth = LibOptionalVectorWidth(width)
                real_T %<name>%<optWidth>; %<comment>
              %endforeach        
            %endif        
            %assign numElements = numElements + 1                
          %%endif            
        %endforeach      
      %endwith
    %endif    
    %<childTypeDefs[0]>\
    %closefile sysZCSignalValue
  %endif
  %assert (LibGetFieldSet(System[sysIdx], "HasZCSignalValueArg") == 0)
  %if numElements > 0
    %assign System[sysIdx].HasZCSignalValueArg = 1
  %endif
  %<LibSetFieldSet(System[sysIdx], "HasZCSignalValueArg")>
  %if numElements > 0
    %assign res[0] = "%<sysZCSignalValue>"
    %assign res[1] = %<numElements>
  %endif
  %return res  
%endfunction
%%adzc


%%adzc
%% Function: LibCacheSystemZCSignalValueStructDef =============================
%% Abstract:
%%   Cache the  ZCSignalValue struct
%%
%function LibCacheSystemZCSignalValueStructDef(sysIdx) void  
  %if !SLibSystemHasOwnDataScope(System[sysIdx])
    %return
  %endif
  %%
  %assign zcBuff = SLibGetSystemZCSignalValue(sysIdx)
  %assign zcDef = ""
  %if (sysIdx < (NumSystems-1))    
    %assign identifier = FcnSysVarGroupType(System[sysIdx],"ZCSV")
    %assign sysInfo = GetSystemNameForComments(System[sysIdx])
    %openfile comment
    /* Zero-crossing (trigger) state for %<sysInfo> */
    %closefile comment
  %else    
    %assign ::CompiledModel.ZCSignalValueStructDefn = ...
      WHITE_SPACE(zcBuff[0])?"":"Nonempty"  
    %assign identifier = tZCSignalValueType
    %openfile comment
    /* Zero-crossing (trigger) state */
    %closefile comment      
  %endif
  %%
  %assign userTypes = LibDumpTypedefsCache()
  %assign ::CompiledModel.TypedefsCache = ""
  %if zcBuff[1] > 0 
    %openfile zcDef
    %<userTypes>\
      %<comment>\
      %assign nonInlSysIdx = System[sysIdx].NonInlinedParentSystemIdx
      %if !LibSystemIsReusedLibraryFcn(System[nonInlSysIdx])
        %<GetHideChildDefineSymbol("ifndef")>\
      %endif
      %<SLibIfNetPreprocessorCondition(System[sysIdx])>
      typedef struct {
        %<zcBuff[0]>
      } %<identifier>;
      %<SLibEndIfNetPreprocessorCondition(System[sysIdx])>
      %if !LibSystemIsReusedLibraryFcn(System[nonInlSysIdx])
        %<GetHideChildDefineSymbol("endif")>\
      %endif
    %closefile zcDef
  %endif
  %%
  %<SLibCacheSystemCodeToFile("sys_data_continue_typedef", System[sysIdx], zcDef)>
%endfunction
%%adzc


%% Function: SLibGetSystemMassMatrixGlobal =========================================
%% Abstract:
%%   Returns the definiton of a systems mass matrix.
%%
%function SLibGetSystemMassMatrixGlobal(sysIdx) void

  %% This is typedef of the global (model-wide) mass matrix.
  %% It only appears at the root level.
  %assert (sysIdx == GetBaseSystemIdx())  

  %assign sysMassMatrixGlobal = ""
  
  %% Global Mass Matrix is assembled at the root-level only -- do not dive 
  %% into child systems.
  %assign numElements   = 0  

  %assign res           = ["", 0]
  
  %openfile sysMassMatrixGlobal
  
  %if (::CompiledModel.ModelIsLinearlyImplicit == "yes")
    %assign numElements =  numElements + 1
    int_T  ir[%<::CompiledModel.ModelMassMatrixNzMax>];
    int_T  jc[%<::CompiledModel.NumContStates>+1];
    real_T pr[%<::CompiledModel.ModelMassMatrixNzMax>];
  %endif

  %closefile sysMassMatrixGlobal
  %assert (LibGetFieldSet(System[sysIdx], "HasMassMatrixGlobalArg") == 0)
  %if numElements > 0
    %assign System[sysIdx].HasMassMatrixGlobalArg = 1
  %endif
  %<LibSetFieldSet(System[sysIdx], "HasMassMatrixGlobalArg")>
  %if numElements > 0
    %assign res[0] = "%<sysMassMatrixGlobal>"
    %assign res[1] = %<numElements>
  %endif
  %return res %% return [%<sysMassMatrixGlobal>, %<numElements>] 
%endfunction


%% Function: LibCacheSystemMassMatrixGlobalDef =============================
%% Abstract:
%%   Cache the (global) Mass Matrix definition
%%
%function LibCacheSystemMassMatrixGlobalDef(sysIdx) void
  
  %% The global (model-wide) mass matrix -- should only appear at the root level.
  %assert (sysIdx == GetBaseSystemIdx())  
  
  %assign massMatrixGlobalBuff = LibIsMultiSolver() ? ...
    SLibDeploymentGetSystemMassMatrix(sysIdx) : SLibGetSystemMassMatrixGlobal(sysIdx)
  %assign massMatrixGlobalDef = ""
  %assign identifier = tMassMatrixGlobalType
  %openfile comment
    /* Mass Matrix (global) */
  %closefile comment

  %assign userTypes = LibDumpTypedefsCache()
  %assign ::CompiledModel.TypedefsCache = ""
  %if massMatrixGlobalBuff[1] > 0 
    %openfile massMatrixGlobalDef
    %<userTypes>\
    
    %if LibIsMultiSolver()
      %<massMatrixGlobalBuff[0]>\
    %else
      %<comment>\
      %<GetHideChildDefineSymbol("ifndef")>\
      typedef struct {
        %<massMatrixGlobalBuff[0]>
      } %<identifier>;
      %<GetHideChildDefineSymbol("endif")>\
    %endif

    %closefile massMatrixGlobalDef
  %endif
  %%
  %<SLibCacheSystemCodeToFile("sys_data_massMatrix_typedef", System[sysIdx], ...
    massMatrixGlobalDef)>
%endfunction


%% Function:  SLibGetSystemMassMatrixOffset  =====================================
%% Abstract:
%%   Returns the contents of a system's MassMatrix offset structure.
%% 
%function SLibGetSystemMassMatrixOffset(sysIdx)
  %assign sysMassMatrixOffset    = ""
  %assign cstatesArg    = System[sysIdx].Interface.MassMatricesArgDef
  %assign childTypeDefs = ...
    FcnGetChildSystemTypedefs(sysIdx, "MassMatrixOffset", "MassMatrixOffset")  
  %assign numElements   = childTypeDefs[1]
  %assign res           = ["", 0]
  %openfile sysMassMatrixOffset
  %if cstatesArg.NumFlatFields > 0
    %with ::CompiledModel.MassMatrices
      %foreach csIdx = cstatesArg.NumFlatFields
	%assign cs = MassMatrix[cstatesArg.FirstLocation + csIdx]
	%with cs
	  %assign comment  = "/* '%<SLibGrBlockName(GrSrc)>' */"
          %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
          %if isMdlRef
            
            %% TODO: JK linearly-implicit blocks not supported in referenced models, yet
            %assert TLC_FALSE
            
	  %else
	    int_T %<Identifier>; %<comment>
	  %endif
	  %assign numElements = numElements + 1
	%endwith %% cs
      %endforeach
    %endwith
  %endif
  %<childTypeDefs[0]>\
  %closefile sysMassMatrixOffset
  %assert (LibGetFieldSet(System[sysIdx], "HasMassMatrixOffsetArg") == 0)
  %if numElements > 0
    %assign System[sysIdx].HasMassMatrixOffsetArg = 1
  %endif
  %<LibSetFieldSet(System[sysIdx], "HasMassMatrixOffsetArg")>
  %if numElements > 0
    %assign res[0] = "%<sysMassMatrixOffset>"
    %assign res[1] = %<numElements>
  %endif
  %return res %% return [%<sysMassMatrixOffset>, %<numElements>] 
%endfunction

%% Function: LibCacheSystemMassMatrixOffsetStructDef  =========================
%% Abstract:
%%   Cache the definition of the system's MassMatrix offset
%%   structure.
%function LibCacheSystemMassMatrixOffsetStructDef(sysIdx) void
  %if !SLibSystemHasOwnDataScope(System[sysIdx])
    %return
  %endif
  %assign massMatrixOffsetBuff = SLibGetSystemMassMatrixOffset(sysIdx)
  %assign massMatrixOffsetDef = ""
  %if (sysIdx < (NumSystems-1))   
    %assign identifier = FcnSysVarGroupType(System[sysIdx],"MassMatrixOffset")    

    %assign sysInfo = GetSystemNameForComments(System[sysIdx])
    %openfile comment
    /* MassMatrix Offset for %<sysInfo> */
    %closefile comment
  %else    
    %assign identifier = tMassMatrixOffsetType    
    %openfile comment
    /* MassMatrix offset  */
    %closefile comment
  %endif

  %assign userTypes = LibDumpTypedefsCache()
  %assign ::CompiledModel.TypedefsCache = ""
  %if massMatrixOffsetBuff[1] > 0 
    %openfile massMatrixOffsetDef
    %<userTypes>\
    
    %<comment>\
    %<GetHideChildDefineSymbol("ifndef")>\
    typedef struct {
      %<massMatrixOffsetBuff[0]>
    } %<identifier>;
    %<GetHideChildDefineSymbol("endif")>\

    %closefile massMatrixOffsetDef
  %endif
  %%
  %<SLibCacheSystemCodeToFile("sys_data_massMatrix_typedef", System[sysIdx], ...
    massMatrixOffset)>
%endfunction


%% Function: LibContStatesStructIsEmpty =======================================
%% Abstract:
%%   Does the root system have any continuous states?
%%
%function LibContStatesStructIsEmpty() void
  %assign baseSysIdx = GetBaseSystemIdx()
  %assert (LibGetFieldSet(System[baseSysIdx], "HasCStatesArg") == 1)
  %return (System[baseSysIdx].HasCStatesArg == 0)
%endfunction

%% Function: LibPrevZCStatesStructIsEmpty =====================================
%% Abstract:
%%   Does the root system have any prevZCEvents?
%%
%function LibPrevZCStatesStructIsEmpty() void  
  %assign baseSysIdx = GetBaseSystemIdx()
  %assert (LibGetFieldSet(System[baseSysIdx], "HasZCEventArg") == 1)
  %return (System[baseSysIdx].HasZCEventArg == 0)
%endfunction

%% Function: SLibModelPrevZCEventsStructIsEmpty ================================
%% Abstract:
%%   Does the model have any prevZCEvents?
%%
%function SLibModelPrevZCEventsStructIsEmpty() void
  %return (::CompiledModel.HasZCEventArg == 0)
%endfunction

%%adzc
%% Function: LibZCSignalValueStructIsEmpty =====================================
%% Abstract:
%%   Is the cache empty?
%%
%function LibZCSignalValueStructIsEmpty() void
  %assign baseSysIdx = GetBaseSystemIdx()
  %assert (LibGetFieldSet(System[baseSysIdx], "HasZCSignalValueArg") == 1)
  %return (System[baseSysIdx].HasZCSignalValueArg == 0)
%endfunction
%%adzc


%% Function: LibCStatesDerivStructIsEmpty ==================================
%% Asbract: 
%%   Is the cache empty?
%%
%function LibCStatesDerivStructIsEmpty() void
   %assign baseSysIdx = GetBaseSystemIdx()
   %assert (LibGetFieldSet(System[baseSysIdx], "HasCStatesDerivArg") == 1)
   %return (System[baseSysIdx].HasCStatesDerivArg == 0)
%endfunction

%% Function: LibContStatesDisabledStructIsEmpty() void
%% Asbract: 
%%   Is the cache empty?
%%
%function LibContStatesDisabledStructIsEmpty()
  %assign baseSysIdx = GetBaseSystemIdx()
  %assert (LibGetFieldSet(System[baseSysIdx], "HasContStatesDisabledArg") == 1)
  %return (System[baseSysIdx].HasContStatesDisabledArg == 0)
%endfunction

%% Function: LibContStatesAbsoluteToleranceStructIsEmpty() void
%% Asbract: 
%%   Is the cache empty?
%%
%function LibContStatesAbsoluteToleranceStructIsEmpty()
  %assign baseSysIdx = GetBaseSystemIdx()
  %assert (LibGetFieldSet(System[baseSysIdx], "HasContStatesAbsoluteToleranceArg") == 1)
  %return (System[baseSysIdx].HasContStatesAbsoluteToleranceArg == 0)
%endfunction

%% Solver Data
%% Function: SLibCacheIntgStructDef ===========================================
%% Abstract:
%%   Caches integrator solver data structure definition
%%
%function SLibCacheIntgStructDef() void
  %openfile intgDataDefn
%if ISEQUAL(Solver, "ode1")
#ifndef %<upperSolver>_INTG
#define %<upperSolver>_INTG
  /* %<upperSolver> Integration Data */
  typedef struct {
      real_T *f[1]; /* derivatives */
  } %<upperSolver>_IntgData;
#endif
%elseif ISEQUAL(Solver, "ode2")
#ifndef %<upperSolver>_INTG
#define %<upperSolver>_INTG
  /* %<upperSolver> Integration Data */
  typedef struct {
      real_T *y; /* output */
      real_T *f[2]; /* derivatives */
  } %<upperSolver>_IntgData;
#endif
%elseif ISEQUAL(Solver, "ode3")
#ifndef %<upperSolver>_INTG
#define %<upperSolver>_INTG
  /* %<upperSolver> Integration Data */
  typedef struct {
      real_T *y; /* output */
      real_T *f[3]; /* derivatives */
  } %<upperSolver>_IntgData;
#endif
%elseif ISEQUAL(Solver, "ode4")
#ifndef %<upperSolver>_INTG
#define %<upperSolver>_INTG
  /* %<upperSolver> Integration Data */
  typedef struct {
      real_T *y; /* output */
      real_T *f[4]; /* derivatives */
  } %<upperSolver>_IntgData;
#endif
%elseif ISEQUAL(Solver, "ode5")
#ifndef %<upperSolver>_INTG
#define %<upperSolver>_INTG
  /* %<upperSolver> Integration Data */
  typedef struct {
      real_T *y; /* output */
      real_T *f[6]; /* derivatives */
  } %<upperSolver>_IntgData;
#endif
%elseif ISEQUAL(Solver, "ode8")
#ifndef %<upperSolver>_INTG
#define %<upperSolver>_INTG
  /* %<upperSolver> Integration Data */
  typedef struct {
      real_T *deltaY; /* output diff */
      real_T *f[13]; /* derivatives */
      real_T *x0; /* Initial State */
  } %<upperSolver>_IntgData;
#endif
%elseif ISEQUAL(Solver, "ode14x")
#ifndef %<upperSolver>_INTG
#define %<upperSolver>_INTG
  /* %<upperSolver> Integration Data */
  typedef struct {
    real_T  *x0;
    real_T  *f0;
    real_T  *x1start;
    real_T  *f1;
    real_T  *Delta;     
    real_T  *E;    
    real_T  *fac;  
    real_T  *DFDX; 
    real_T  *W;    
    int_T   *pivots;     
    real_T  *xtmp;
    real_T  *ztmp;
    real_T  *M;
    real_T  *M1;
    real_T  *Edot;
    real_T  *xdot;
    real_T  *fminusMxdot;
    boolean_T   isFirstStep;
  } %<upperSolver>_IntgData;
#endif
%endif
  %closefile intgDataDefn
  %return intgDataDefn
%endfunction

%endif %% _COMMONHDR_CSTATELIB
