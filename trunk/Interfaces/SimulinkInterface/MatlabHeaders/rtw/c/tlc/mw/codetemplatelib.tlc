%% ==============================================================================
%% 
%% 
%% 
%%
%% Abstract:
%%   Output file template library
%%
%% Copyright 1994-2011 The MathWorks, Inc.
%%
%selectfile NULL_FILE

%% =============================================================================
%% Public functions
%% =============================================================================

%% DocFunction{Code Configuration Functions}: LibGetNumSourceFile ===============
%% Abstract:
%%   Get the number of source files (.c and .h) that have been created.
%%
%% Call syntax:
%%   %assign numFiles = LibGetNumSourceFiles()
%%
%% Returns:
%%   Returns the number of files (Number).

%function LibGetNumSourceFiles() void
  %return LibGetNumModelFiles()
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetSourceFileTag ===============
%% Abstract:
%%   Returns <fileName>_h and <fileName>_c for header and source files,
%%   respectively where fileName is the name of the model file.
%%
%% Call syntax:
%%   %assign tag = LibGetSourceFileTag(fileIdx)
%%
%% Arguments:
%%   fileIndex (Number) - File index.
%%
%% Returns:
%%   Returns the tag (String).

%function LibGetSourceFileTag(fileIdx) void
  %return LibGetModelFileTag(fileIdx)
%endfunction

%% DocFunction{Code Configuration Functions}: LibCreateSourceFileAtPath ===============
%% Abstract:
%%   Create a new C file, and return its reference.  If the file already exists,
%%   simply return its reference.
%%
%% Call syntax:
%%   %assign fileH = LibCreateSourceFileAtPath("Source", "Custom", "../slprj/ert/_shareutils/foofile","foofile")
%%
%% Arguments:
%%   type (String):
%%     Valid values are "Source" and "Header" for .c and .h files,
%%     respectively.
%%
%%   creator (String):
%%     Who's creating the file?  An error is reported if different creators
%%     attempt to create the same file.
%%
%%   namewithpath (String):
%%     Name of the file (with the file path but without the extension).
%%
%%   basename (String):
%%     Name of the file (without the path or extension).
%%
%%   Note: For files destined to the model build dir, use the simpler
%%         LIbCreateSourceFile(type,creator,name) 
%%
%% Note: File are not written to disk if they are empty.
%%
%% Returns:
%%   Reference to the model file (Scope).
%%
%function LibCreateSourceFileAtPath(type,creator,namewithpath,basename) void
  %assign type = (type == "Source") ? "SystemBody" : "SystemHeader"
  %return SLibAddModelFileWithBasename(type,creator,namewithpath,basename)
%endfunction

%% DocFunction{Code Configuration Functions}: LibCreateSourceFile ===============
%% Abstract:
%%   Create a new C file, and return its reference.  If the file already exists,
%%   simply return its reference.
%%
%% Call syntax:
%%   %assign fileH = LibCreateSourceFile("Source", "Custom", "foofile")
%%
%% Arguments:
%%   type (String):
%%     Valid values are "Source" and "Header" for .c and .h files,
%%     respectively.
%%
%%   creator (String):
%%     Who's creating the file?  An error is reported if different creators
%%     attempt to create the same file.
%%
%%   name (String):
%%     Name of the file (without the extension).
%%
%% Note: File are not written to disk if they are empty.
%%
%% Returns:
%%   Reference to the model file (Scope).

%function LibCreateSourceFile(type,creator,name) void
  %assign type = (type == "Source") ? "SystemBody" : "SystemHeader"
  %return SLibAddModelFile(type,creator,name)
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetSourceFileFromIdx ===========
%% Abstract:
%%   Return a model file reference based on its index.  This is very useful
%%   for a common operation on all files.  For example, to set the leading file
%%   banner of all files.
%%
%% Call syntax:
%%   %assign fileH = LibGetSourceFileFromIdx(fileIdx)
%%
%% Arguments:
%%   fileIdx (Number): Index of model file (that is internally managed by Simulink Coder).
%%
%% Returns:
%%   Reference (Scope) to the model file.

%function LibGetSourceFileFromIdx(fileIdx) void
  %return ModelFiles.ModelFile[fileIdx]
%endfunction

%% DocFunction{Code Configuration Functions}: LibSetSourceFileSection ===========
%% Abstract:
%%   Add to the contents of a file.  Valid attributes include:
%%
%%   Banner            - Set the file banner (comment) at the top of the file.
%%   Includes          - Append to the #include section.
%%   Defines           - Append to the #define section.
%%   IntrinsicTypes    - Append to the intrinsic typedef section.  Intrinsic
%%                       types are those that only depend on intrinsic C types.
%%   PrimitiveTypedefs - Append to the primitive typedef section.  Primitive
%%                       typedefs are those that only depend on intrinsic C types
%%                       and any typedefs previously defined in the
%%                       IntrinsicTypes section.
%%   UserTop           - Append to the "user top" section.
%%   Typedefs          - Append to the typedef section.  Typedefs can depend on
%%                       any previously defined type.
%%   Enums             - Append to the enumerated types section.
%%   Definitions       - Append to the data definition section.
%%   ExternData        - (reserved) extern data.
%%   ExternFcns        - (reserved) extern functions.
%%   FcnPrototypes     - (reserved) function prototypes.
%%   Declarations      - Append to the data declaration section.
%%   Functions         - Append to the C functions section.
%%   CompilerErrors    - Append to the #error section.
%%   CompilerWarnings  - Append to the #warning section.
%%   Documentation     - Append to the documentation (comment) section.
%%   UserBottom        - Append to the "user bottom" section.
%%
%%  Code is emitted by Simulink Coder in the order in which it is listed
%%  above.
%%
%%  Example call syntax (iterating over all file):
%%
%%  %openfile tmpBuf
%%    whatever
%%  %closefile tmpBuf
%%
%%  %foreach fileIdx = LibGetNumSourceFiles()
%%    %assign fileH = LibGetSourceFileFromIdx(fileIdx)
%%    %<LibSetSourceFileSection(fileH,"SectionOfInterest",tmpBuf)>
%%  %endforeach
%%
%%  %assign fileH = LibCreateSourceFile("Header","Custom","foofile")
%%  %<LibSetSourceFileSection(fileH,"Defines","#define FOO 5.0\n")
%%
%%  Arguments:
%%    fileH   - Reference or index to a file (Scope or Number).
%%    section - File section of interest (String).
%%    value   - Value (String).

%function LibSetSourceFileSection(fileH, section, value) void
  %if TYPE(fileH) != "Scope"
    %if TYPE(fileH) == "Number"
      %assign fileH = ModelFiles.ModelFile[fileH]
    %else
      %assign errTxt = "LibSetSourceFileSection expects a reference or " ...
	"and index to a file.  It was passed a %<TYPE(fileH)>"
      %<LibReportError(errTxt)>
    %endif
  %endif
  %if section == "ExternData" || section == "ExternFcns" || section == "FcnPrototypes"
    %assign errTxt = "%<section> is reserved for Simulink Coder."
    %setcommandswitch "-v1"
    %<LibReportError(errTxt)>
  %endif
  %<SLibSetModelFileAttribute(fileH,section,value)>
%endfunction

%% Function: LibGetSourceFileSection ============================================
%% Abstract:
%%   Get the contents of a file.  See LibSetSourceFileSection for list of valid
%%   sections.
%%
%%  Arguments:
%%    fileIndex - Reference or index to a file (Scope or Number).
%%    section   - File section of interest (String).

%function LibGetSourceFileSection(fileIdx, section) void
  %if TYPE(fileIdx) != "Number"
    %if TYPE(fileIdx) == "Scope"
      %assign fileIdx = fileIdx.Index
    %else
      %assign errTxt = "LibGetSourceFileSection expects an index or a " ...
	"reference to a file."
      %<LibReportError(errTxt)>
    %endif
  %endif
  %return LibGetModelFileAttribute(fileIdx,section)
%endfunction

%% Function: LibGetSourceFileIndent ============================================
%% Abstract:
%%   Get the Indent flag of a file.
%%
%%  Arguments:
%%    fileIndex - Reference or index to a file (Scope or Number).

%function LibGetSourceFileIndent(fileIdx) void
  %if TYPE(fileIdx) != "Number"
    %if TYPE(fileIdx) == "Scope"
      %assign fileIdx = fileIdx.Index
    %else
      %assign errTxt = "LibGetSourceFileSection expects an index or a " ...
	"reference to a file."
      %<LibReportError(errTxt)>
    %endif
  %endif
  %return ModelFiles.ModelFile[fileIdx].Indent
%endfunction

%% Function: LibGetSourceFileShared ============================================
%% Abstract:
%%   Get the Shared flag of a file. This is set for shared utility functions
%%   being generated to _sharedutils. Note shared type use a different flag
%%   (see LibGetSourceFileSharedType())
%%
%%  Arguments:
%%    fileIndex - Reference or index to a file (Scope or Number).

%function LibGetSourceFileShared(fileIdx) void
  %if TYPE(fileIdx) != "Number"
    %if TYPE(fileIdx) == "Scope"
      %assign fileIdx = fileIdx.Index
    %else
      %assign errTxt = "LibGetSourceFileSection expects an index or a " ...
	"reference to a file."
      %<LibReportError(errTxt)>
    %endif
  %endif
  %return ModelFiles.ModelFile[fileIdx].Shared
%endfunction

%% Function: LibGetSourceFileSharedType ============================================
%% Abstract:
%%   Get the Shared Type flag of a file. This is set for shared types
%%   being generated to _sharedutils. Note shared type use a different flag
%%   (see LibGetSourceFileSharedType())
%%
%%  Arguments:
%%    fileIndex - Reference or index to a file (Scope or Number).

%function LibGetSourceFileSharedType(fileIdx) void
  %if TYPE(fileIdx) != "Number"
    %if TYPE(fileIdx) == "Scope"
      %assign fileIdx = fileIdx.Index
    %else
      %assign errTxt = "LibGetSourceFileSection expects an index or a " ...
	"reference to a file."
      %<LibReportError(errTxt)>
    %endif
  %endif
  %return ModelFiles.ModelFile[fileIdx].SharedType
%endfunction

%% Function: LibIndentSourceFile ================================================
%% Abstract:
%%   Indent a file with the c_indent utility (from within TLC environment).
%%
%% Call syntax:
%%   %<LibIndentSourceFile("foofile.c","")>
%%
%% Arguments:
%%   name - Name of file (String).
%%   opts - options to pass c_indent.

%function LibIndentSourceFile(name,opts) void
  %<SLibIndentFile(name,opts)>
%endfunction

%% DocFunction{Code Configuration Functions}: LibSetSourceFileCodeTemplate ======
%% Abstract:
%%   By default, *.c and *.h files are generated with the code templates
%%   specified in the GUI.  This function allows you to change the
%%   the template for a file.  Uses the "Code templates" entered into the
%%   Templates UI.
%%
%%   Note: Custom templates is a feature of Embedded Coder.
%%
%% Call syntax:
%%   %assign tag = LibSetSourceFileCodeTemplate(opFile,name)
%%
%% Arguments:
%%   opFile (Scope)  - Reference to file
%%   name   (String) - Name of the desired template
%%
%% Returns:
%%   None

%function LibSetSourceFileCodeTemplate(opFile,name) void
  %<SLibSetModelFileAttribute(opFile,"CodeTemplate",name)>
%endfunction

%% DocFunction{Code Configuration Functions}: LibSetSourceFileOutputDirectory ===
%% Abstract:
%%   By default, *.c and *.h files are generated into the build directory.
%%   This function allows you to change the default location.  Note that
%%   the caller is reponsible for specifying a valid directory.
%%
%% Call syntax:
%%   %assign tag = LibSetSourceFileOutputDirectory(opFile,dirName)
%%
%% Arguments:
%%   opFile  (Scope)  - Reference to file
%%   dirName (String) - Name of the desired output directory
%%
%% Returns:
%%   None

%function LibSetSourceFileOutputDirectory(opFile,name) void
  %<SLibSetModelFileAttribute(opFile,"OutputDirectory",name)>
%endfunction


%% DocFunction{Code Configuration Functions}: LibCallModelInitialize ============
%% Abstract:
%%   Returns necessary code for calling the model's initialize function (valid
%%   for ERT only).

%function LibCallModelInitialize() void
  %openfile tmpFcnBuf
  %<SLibModelInitFcnName()>(%<SLibModelFcnArgs("Initialize",TLC_TRUE,"")>);
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% DocFunction{Code Configuration Functions}: LibCallModelStep ==================
%% Abstract:
%%   Returns necessary code for calling the model's step function (valid
%%   for ERT only).

%function LibCallModelStep(tid) void
  %assign rootSystem.CurrentTID =tid 
  %openfile tmpFcnBuf
  %<FcnCallMdlStep(tid)>
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% DocFunction{Code Configuration Functions}: LibCallModelTerminate =============
%% Abstract:
%%   Returns necessary code for calling the model's terminate function (valid
%%   for ERT only).

%function LibCallModelTerminate() void
  %openfile tmpFcnBuf
  %if IncludeMdlTerminateFcn
    %<::CompiledModel.Name>_terminate(%<SLibModelFcnArgs("Terminate",TLC_TRUE,"")>);
  %endif
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% DocFunction{Code Configuration Functions}: LibCallSetEventForThisBaseStep ====
%% Abstract:
%%   Returns necessary code for calling the model's set events function (valid
%%   for ERT only).
%%
%% Args:
%%   buffername - Name of the variable used to buffer the events.  For the
%%                example ert_main.c this is "eventFlags".

%function LibCallSetEventForThisBaseStep(buffername) void
  %return EventFlagsFunction("%<::CompiledModel.Name>_", buffername)
%endfunction

%% DocFunction{Code Configuration Functions}: LibWriteModelData =================
%% Abstract:
%%   Returns necessary data for the model (valid for ERT only).

%function LibWriteModelData() void
  %return SLibDeclareModelFcnArgs(TLC_TRUE)
%endfunction
  
%% DocFunction{Code Configuration Functions}: LibSetRTModelErrorStatus ==========
%% Abstract:
%%   Returns the code required set the model error status
%%
%% Args:
%%   str (String) - char * to a C string
%%
%% Call syntax:
%%   %<LibSetRTModelErrorStatus("\"Overrun\"")>;

%function LibSetRTModelErrorStatus(str) void
  %return RTMSetErrStat(str)
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetRTModelErrorStatus ==========
%% Abstract:
%%   Returns the code required to get the model error status
%%
%% Call syntax:
%%   %<LibGetRTModelErrorStatus()>;

%function LibGetRTModelErrorStatus() void
  %return RTMGetErrStat()
%endfunction

%% DocFunction{Sample Time Functions}: LibIsSingleRateModel =====================
%% Abstract:
%%   Return true if model is single rate and false otherwise.

%function LibIsSingleRateModel() void
  %assign rootSystem = System[NumSystems-1]
  %return LibIsSingleRateSystem(rootSystem)
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetMdlSrcBaseName ==============
%% Abstract:
%%   Return the base name of the model's main source (e.g., model.c) file

%function LibGetMdlSrcBaseName() void
  %return ::CompiledModel.Name
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetMdlPubHdrBaseName ===========
%% Abstract:
%%   Return the base name of the model's public header (e.g., model.h) file

%function LibGetMdlPubHdrBaseName() void
  %return ::CompiledModel.Name
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetMdlPrvHdrBaseName ===========
%% Abstract:
%%   Return the base name of the model's private header (e.g., model_private.h)
%%   file

%function LibGetMdlPrvHdrBaseName() void
  %return ::CompiledModel.Name + "_private"
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetModelDotCFile ==============
%% Abstract:
%%   Get the record for the model.c file. Additional code can then be cached
%%   using LibSetSourceFileSection().
%%
%% Call syntax:
%%   %assign srcFile = LibGetModelDotCFile()
%%   %<LibSetSourceFileSection(srcFile, "Functions", mybuf)>
%% 
%% Returns:
%%   Returns the model.c source file record.

%function LibGetModelDotCFile() void
  %return LibCreateSourceFile("Source","Simulink",::CompiledModel.Name)
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetModelDotHFile ==============
%% Abstract:
%%   Get the record for the model.h file. Additional code can then be cached
%%   using LibSetSourceFileSection().
%%
%% Call syntax:
%%   %assign hdrFile = LibGetModelDotHFile()
%%   %<LibSetSourceFileSection(hdrFile, "Functions", mybuf)>
%% 
%% Returns:
%%   Returns the model.h source file record.

%function LibGetModelDotHFile() void
  %return LibCreateSourceFile("Header","Simulink",::CompiledModel.Name)
%endfunction

%% Function: LibIsSingleTasking =================================================
%% Abstract:
%%   Return true if the model is configured for singletasking execution and
%%   false otherwise (i.e., multitasking).

%function LibIsSingleTasking() void
  %return SLibSingleTasking()
%endfunction

%% DocFunction{Code Configuration Functions}: LibWriteModelInput ================
%% Abstract:
%%   Return the code necessary to write to a particular root input (i.e., a
%%   model inport block).   This function is valid for ERT only, and not valid 
%%   for referenced models.
%%
%% Args:
%%   tid (Number):  Task identifier (0 is fastest rate and n is the slowest)
%%   rollThreshold: Width of signal before wrapping in a for loop.

%function LibWriteModelInput(tid,rollThreshold) void
  %if IsModelReferenceTarget()
     %assign errTxt = "LibWriteModelInput may not be called for referenced " + ...
       "models; you may wish to guard its invocation with !IsModelReferenceTarget()."
     %<LibReportError(errTxt)>
  %endif
  %openfile tmpFcnBuf
  %if MultiInstanceERTCode && !RootIOStructures
    %assign localUQualifier = "_"
  %else
    %assign localUQualifier = "."
  %endif
  %foreach idx = ExternalInputs.NumExternalInputs
    %assign extInp = ::CompiledModel.ExternalInputs.ExternalInput[idx]
    %with extInp
      %if TID == tid
	%assign rhs = "your_value"
	/* InportID: %<idx>, TaskID: %<tid> */
	%assign id = LibGetRecordIdentifier(extInp)
	%assign optStr = ""
	%if StorageClass == "Auto"
	  %assign optStr = "%<LibGetExternalInputStruct()>%<localUQualifier>"
	%endif
	%if StorageClass == "ImportedExternPointer"
	  %assign id = "%<id>_value"
	%endif
	%assign portWidth = LibGetRecordWidth(extInp)
	%assign isComplex = LibGetRecordIsComplex(extInp)
	%if portWidth == 1
	  %if isComplex
	    %<optStr>%<id>.re = %<rhs>;
	    %<optStr>%<id>.im = %<rhs>;
	  %else
	    %<optStr>%<id> = %<rhs>;
	  %endif
	%elseif portWidth < rollThreshold
	  %foreach sigIdx = portWidth
	    %if isComplex
	      %<optStr>%<id>[%<sigIdx>].re = %<rhs>;
	      %<optStr>%<id>[%<sigIdx>].im = %<rhs>;
	    %else  
	      %<optStr>%<id>[%<sigIdx>] = %<rhs>;
	    %endif
	  %endforeach
	%else %% portWidth > rollThreshold
	  {
	    int i = 0;
	    for(i = 0; i < %<portWidth>; i++) {
	      %if isComplex
		%<optStr>%<id>[i].re = %<rhs>;
		%<optStr>%<id>[i].im = %<rhs>;
	      %else
		%<optStr>%<id>[i] = %<rhs>;
	      %endif
	    }
	  }
	%endif
      %endif
    %endwith %% extInp
  %endforeach
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% DocFunction{Code Configuration Functions}: LibWriteModelOutput ===============
%% Abstract:
%%   Return the code necessary to write to a particular root output (i.e., a
%%   model outport block).   This function is valid for ERT only, and not valid 
%%   for referenced models.
%%
%% Args:
%%   tid (Number):  Task identifier (0 is fastest rate and n is the slowest)
%%   rollThreshold: Width of signal before wrapping in a for loop.

%function LibWriteModelOutput(tid,rollThreshold) void
  %if IsModelReferenceTarget()
     %assign errTxt = "LibWriteModelOutput may not be called for referenced " + ...
       "models; you may wish to guard its invocation with !IsModelReferenceTarget()."
     %<LibReportError(errTxt)>
  %endif
  %openfile tmpFcnBuf
  %if MultiInstanceERTCode && !RootIOStructures
    %assign localYQualifier = "_"
  %else
    %assign localYQualifier = "."
  %endif
  %assign lhs = "your_variable"
  %foreach idx = ExternalOutputs.NumExternalOutputs
    %assign extOut       = ExternalOutputs.ExternalOutput[idx]
    %assign sysIdx       = extOut.Block[0]
    %assign blkIdx       = extOut.Block[1]
    %assign outportBlock = System[sysIdx].Block[blkIdx]
    %with System[sysIdx]
      %with outportBlock
	%if tid == TID
	  %assign portWidth = LibBlockInputSignalWidth(0)
          %assign id = LibGetRecordIdentifier(outportBlock)
	  /* OutportID: %<idx>, TaskID: %<tid> */
	  %if portWidth == 1
	    %if SLibExternalOutputIsVirtual(outportBlock)
	      %<lhs> = %<LibBlockInputSignal(0, "", "", 0)>;
	    %else
	      %<lhs> = %<LibGetExternalOutputStruct()>%<localYQualifier>%<id>;
	    %endif
	  %elseif portWidth < rollThreshold
	    %foreach sigIdx = portWidth
	      %if SLibExternalOutputIsVirtual(outportBlock)
		%<lhs> = %<LibBlockInputSignal(0, "", "", sigIdx)>;
	      %else
		%<lhs> = %<LibGetExternalOutputStruct()>%<localYQualifier>%<id>[%<sigIdx>];
	      %endif
	    %endforeach
	  %else %% portWidth > rollThreshold
	    {
	      int i = 0;
	      for(i = 0; i < %<portWidth>; i++) {
		%if SLibExternalOutputIsVirtual(outportBlock)
		  %<lhs>[i] = %<LibBlockInputSignal(0, "i", "", 0)>;
		%else
		  %<lhs>[i] = %<LibGetExternalOutputStruct()>%<localYQualifier>%<id>[i];
		%endif
	      }
	    }
	  %endif
	%endif
      %endwith %% outportBlock
    %endwith %% System[sysIdx]
  %endforeach
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% DocFunction{Code Configuration Functions}: LibWriteModelInputs ===============
%% Abstract:
%%   Return the code necessary to write to root inputs (i.e., all the
%%   model inport blocks).  This function is valid for ERT only, and not valid 
%%   for referenced models.

%function LibWriteModelInputs() void
  %if IsModelReferenceTarget()
     %assign errTxt = "LibWriteModelInputs may not be called for referenced " + ...
       "models; you may wish to guard its invocation with !IsModelReferenceTarget()."
     %<LibReportError(errTxt)>
  %endif
  %openfile varbufs
  %foreach tid = LibNumSynchronousSampleTimes()
    %<LibWriteModelInput(tid,RollThreshold)>\
  %endforeach
  %closefile varbufs
  
  %if WHITE_SPACE(varbufs)
    %return ""
  %else
    %openfile tmpFcnBuf
    #if 0
    %<varbufs>\
    #endif
    %closefile tmpFcnBuf
    %return tmpFcnBuf
  %endif
%endfunction

%% DocFunction{Code Configuration Functions}: LibWriteModelOutputs ==============
%% Abstract:
%%   Return the code necessary to write to root outputs (i.e., all the
%%   model outport blocks).   This function is valid for ERT only, and not valid 
%%   for referenced models.

%function LibWriteModelOutputs() void
  %if IsModelReferenceTarget()
     %assign errTxt = "LibWriteModelOutputs may not be called for referenced " + ...
       "models; you may wish to guard its invocation with !IsModelReferenceTarget()."
     %<LibReportError(errTxt)>
  %endif
  %openfile varbufs
  %foreach tid = LibNumSynchronousSampleTimes()
    %<LibWriteModelOutput(tid,RollThreshold)>\
  %endforeach
  %closefile varbufs
  
  %if WHITE_SPACE(varbufs)
    %return ""
  %else
    %openfile tmpFcnBuf
    #if 0
    %<varbufs>\
    #endif
    %closefile tmpFcnBuf
    %return tmpFcnBuf
  %endif
%endfunction

%% DocFunction{Sample Time Functions}: LibNumDiscreteSampleTimes ================
%% Abstract:
%%   Return the number of discrete sample times in the model

%function LibNumDiscreteSampleTimes() void
  %return ::CompiledModel.NumSynchronousSampleTimes - LibIsContinuous(0)
%endfunction            

%function LibGetTID01EQ() void
  %return ::CompiledModel.FixedStepOpts.TID01EQ
%endfunction

%function LibGetSampleTimePeriodAndOffset(tid, idx) void
  %return ::CompiledModel.SampleTime[tid].PeriodAndOffset[idx]
%endfunction


%% DocFunction{Sample Time Functions}: LibNumSynchronousSampleTimes ================
%% Abstract:
%%   Return the number of synchronous sample times in the model

%function LibNumSynchronousSampleTimes() void
  %return ::CompiledModel.NumSynchronousSampleTimes
%endfunction

%% DocFunction{Sample Time Functions}: LibNumAsynchronousSampleTimes ============
%% Abstract:
%%   Return the number of asynchronous sample times in the model

%function LibNumAsynchronousSampleTimes() void
  %return ::CompiledModel.NumAsynchronousSampleTimes
%endfunction

%% DocFunction{Code Configuration Functions}: LibAddSourceFileCustomSection =====
%% Abstract:
%%   Add a custom section to a source file.  You must associate a custom
%%   section with one of the built-in sections: Includes, Defines, Types,
%%   Enums, Definitions, Declarations, Functions, or Documentation.
%%
%%   No action if the section already exists, except to report an error
%%   if a inconsistent built-in section association is attempted.
%%
%%   Only available with Embedded Coder.
%%
%% Arguments:
%%   file           - Source file reference (Scope)
%%   builtInSection - Name of the associated built-in section (String)
%%   newSection     - Name of the new (custom) section (String)

%function LibAddSourceFileCustomSection(file,builtInSection,newSection) void
  %if !SLibIsERTTarget()
    %assign errTxt = "LibAddSourceFileCustomSection is only available with " ...
      "ERT-based (Embedded Coder) targets."
    %<LibReportError(errTxt)>
  %endif
  %assign cc = file.CustomContents
  %if !ISFIELD(cc,newSection)
    %assign c = file.Contents
    %switch builtInSection
      %case "Types"
	%% Valid association, and required (note Types are associated with
	%% Typedefs since there is no built-in Types section)
	%assign section = "Typedefs"
	%assign isRequired = TLC_TRUE
	%break
      %case "Includes"
      %case "ModelTypesIncludes"
      %case "ModelTypesDefines"
      %case "ModelTypesTypedefs"
      %case "Defines"
      %case "Enums"
      %case "Definitions"
      %case "Declarations"
      %case "Functions"
	%% Valid association, and required
	%assign section = builtInSection
	%assign isRequired = TLC_TRUE
	%break
      %case "Documentation"
	%% Valid association, and not required
	%assign section = builtInSection
	%assign isRequired = TLC_FALSE
	%break
      %default
	%% Invalid association
	%assign errTxt = "You are attempting to associate '%<newSection>' " ...
	  "with '%<builtInSection>', which is not a valid association."
	%<LibReportError(errTxt)>
    %endswitch
    %addtorecord cc                 \
    CustomContent {                 \
      Name           newSection     \
      BuiltInSection section        \
      IsRequired     isRequired     \
      Value          ""             \
      IsRetrieved    TLC_FALSE      \
    }
    %addtorecord cc %<newSection> cc.CustomContent[cc.NumCustomContents]
    %assign cc.NumCustomContents = cc.NumCustomContents + 1
  %else
    %assign cs = cc.%<newSection>
    %% Be consistent with switch case above on Types
    %if builtInSection == "Types"
      %assign builtInSection = "Typedefs"
    %endif
    %if cs.BuiltInSection != builtInSection
      %assign errTxt = "Attempt to create a custom model file section " ...
	"'%<newSection>' with an '%<builtInSection>' association, " ...
	"however, this custom section has already been created " ...
	"with an '%<cs.BuiltInSection>' association."
      %<LibReportError(errTxt)>
    %endif
  %endif
%endfunction

%% DocFunction{Code Configuration Functions}: LibSetSourceFileCustomSection =====
%% Abstract:
%%   Set a custom section previously created with LibAddSourceFileCustomSection.
%%
%%   Only available with Embedded Coder.
%%
%% Arguments:
%%   file   - Source file reference or index  (Scope or Number)
%%   attrib - Name of custom section          (String)
%%   value  - value to be appended to section (String)

%function LibSetSourceFileCustomSection(file,attrib,value) void
  %if TYPE(file) != "Scope"
    %if TYPE(file) == "Number"
      %assign file = ModelFiles.ModelFile[file]
    %else
      %assign errTxt = "LibSetSourceFileCustomSection expect a " ...
	"reference or an index to a file.  It was passed a: " ...
	"%<TYPE(file)>"
      %<LibReportError(errTxt)>
    %endif
  %endif
  %assign cc = file.CustomContents
  %if !ISFIELD(cc,attrib)
    %assign errTxt = "Attempt to set the value of an custom attribute " ...
      "that does not exist for source file %<file.Name>: %<attrib>."
    %<LibReportError(errTxt)>
  %endif
  %if !ISEMPTY(value) && !WHITE_SPACE(value)
    %assign cs = cc.%<attrib>
    %assign cs.Value = cs.Value + value
    %assign file.IsEmpty = TLC_FALSE
  %endif
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetSourceFileCustomSection =====
%% Abstract:
%%   Get a custom section previously created with LibAddSourceFileCustomSection.
%%
%% Arguments:
%%   file   - Source file reference or index (Scope or Number)
%%   attrib - Name of custom section         (String)

%function LibGetSourceFileCustomSection(file,attrib) void
  %if TYPE(file) != "Scope"
    %if TYPE(file) == "Number"
      %assign file = ModelFiles.ModelFile[file]
    %else
      %assign errTxt = "LibGetSourceFileCustomSection expect a " ...
	"reference or an index to a file.  It was passed a: " ...
	"%<TYPE(file)>"
    %endif
  %endif
  %assign cc = file.CustomContents
  %if !ISFIELD(cc,attrib)
    %% Never been created, so just return empty string.
    %return ""
  %else
    %assign cs = cc.%<attrib>
    %if cs.IsRetrieved
      %assign codeTemplate = file.CodeTemplate
      %if ISEMPTY(FEVAL("regexp",codeTemplate,"_cgt.tlc"))
	%assign actFile = codeTemplate
      %else
	%assign actFile = FEVAL("rtw_cgt_name_conv",codeTemplate,"tlc2cgt")
      %endif
      %assign warnTxt = "%<cs.Name> symbol is used more than once in " + ...
	"Code Template file: %<actFile>.\n%<cs.Name> can be used only" + ...
	" once in the template file."
      %<LibReportWarning(warnTxt)>
      %return ""
    %else
      %assign cs.IsRetrieved = TLC_TRUE
      %if ISEMPTY(cs.Value)
	%return ""
      %else
	%return cs.Value
      %endif
    %endif
  %endif
%endfunction

%% =============================================================================
%% Add ModelFiles to CompiledModel
%% =============================================================================

%with CompiledModel
  %addtorecord CompiledModel \
  ModelFiles {               \
    NumModelFiles    0       \
    NumSupportFiles  0       \
    ComplianceLevel -1       \
  }
%endwith %% CompiledModel

%% =============================================================================
%% Private functions (MathWorks use only)
%% =============================================================================

%function SLibGetTag(type, name) void

  %% In case name contains . and other funny char
  %assign name = LibConvertNameToIdentifier(name)

  %switch type
    %case "SystemHeader"
      %assign tag = "%<name>_h"
      %break
    %case "SystemBody"
      %assign tag = "%<name>_c"
      %break
    %default
      %assign errTxt = "unknown type: %<type>"
      %<LibReportFatalError(errTxt)>
  %endswitch
  %return tag
%endfunction
  
%% Function: SLibSetSourceFileCustomTokenInUse =================================
%% Abstract:
%%   The rtw_expand_template script identifies and set customs tokens with
%%   this function.  This allows custom sections to be placed in the
%%   appropriate section when a token is missing.
%%
%function SLibSetSourceFileCustomTokenInUse(fileIdx,token) void
  %assign cc = ModelFiles.ModelFile[fileIdx].CustomContents
  %<SETFIELD(cc, token + "_InUse", TLC_TRUE)>
%endfunction


%% Function: FcnAppendMissingTokens ============================================
%% Abstract:
%%   Since custom sections can be added without a corresponding token in
%%   the code template file, we need to gracefully accomodate missing tokens.
%%   If the custom token is missing, it's placed just below it's registered
%%   built-in section.
%%
%function FcnAppendMissingTokens(opFile,section) void
  %assign c = opFile.Contents
  %with opFile.CustomContents
    %foreach idx = NumCustomContents
      %assign cc = CustomContent[idx]
      %assign tokenInUse = ISFIELD(opFile.CustomContents, cc.Name + "_InUse")
      %if cc.IsRequired && !tokenInUse && cc.BuiltInSection == section && !cc.IsRetrieved
	%assign c.%<section> = c.%<section> + cc.Value
	%assign cc.IsRetrieved = TLC_TRUE
      %endif
    %endforeach
  %endwith
%endfunction


%% Check if model file exists
%function SLibDoesModelFileExist(type,name) void
  
  %% Check hash name
  %assign tag = SLibGetTag(type, name)
  
  %% Return hashed value if file already created
  
  %if ISFIELD(ModelFiles,tag)
    %assign mf = ModelFiles.ModelFile[ModelFiles.%<tag>]
    %return mf
  %else
    %return ""
  %endif
%endfunction

%% Function SLibAddGeneratedFileToList ===================================
%% Abstract:
%%   Adds specified file to TLC global variable GeneratedFileList
%%
%function SLibAddGeneratedFileToList(filename, category, type, dir) void
  %if ::CompiledModel.CoderReportInfo
    %matlab rtwprivate("rtwreport", "addFileInfo", LibGetModelName(),...
    filename, category, type, dir)
  %else
    %assign ::GeneratedFileList = GeneratedFileList + filename + ";" + category + ";" + type + ";" + dir + ","
  %endif
%endfunction %%SLibAddGeneratedFileToList

  
%% Function: SLibAddModelFile =========================================== 
%% Create a new model file, or return its existing reference.
%%
%% "type" is the type of file, e.g. "SystemBody" (.c file) or "SystemHeader" (.h file)
%% "creator" is typically "Simulink".
%% "name" is the base name of the file if writing to the build directory,
%%        and is the full path if writing to some other directory (e.g. _sharedutils)
%% 
%% For example: Building model "foo" to build directory ./foo_ert_rtw/ .
%%              If creating source file "foo.h" to build directory, then:
%%                type="SystemHeader", creator="Simulink", 
%%                name="foo", basename="foo".
%%              If creating shared type "a.h" in the shared utilities dir:
%%                type="SystemHeader", creator="Simulink", 
%%                name="<fullpathto>/_sharedutils/a", basename="a"
%%
%function SLibAddModelFile(type, creator, name) void
  %return SLibAddModelFileWithBasename(type, creator, name, name)
%endfunction

%% Function: SLibAddModelFileWithBasename =========================================== 
%% Create a new model file, or return its existing reference.
%%
%% "type" is the type of file, e.g. "SystemBody" (.c file) or "SystemHeader" (.h file)
%% "creator" is typically "Simulink".
%% "name" is the base name of the file if writing to the build directory,
%%        and is the full path if writing to some other directory (e.g. _sharedutils)
%% 'basename' is always the base name of the file
%% 
%% For example: Building model "foo" to build directory ./foo_ert_rtw/ .
%%              If creating source file "foo.h" to build directory, then:
%%                type="SystemHeader", creator="Simulink", 
%%                name="foo", basename="foo".
%%              If creating shared type "a.h" in the shared utilities dir:
%%                type="SystemHeader", creator="Simulink", 
%%                name="<fullpathto>/_sharedutils/a", basename="a"
%%
%function SLibAddModelFileWithBasename(type, creator, name, basename) void

  %assign mf = SLibDoesModelFileExist(type, name)
  
  %if TYPE(mf) == "Scope" %% file exists
    %if creator != mf.Creator
      %if type == "SystemHeader" && mf.Group == "utility" && mf.Type == "SystemHeader"
        %<SLibReportErrorWithIdAndArgs("RTW:tlc:ErrWhenGenSharedDataConflictModelFile", "%<name>"+".h")> 
      %else
        %assign errTxt = "%<creator> is attempting to create " ...
	  "file %<name>, however, this file was already created " ...
          "by %<mf.Creator>."
        %<LibReportFatalError(errTxt)>
      %endif
    %else
      %return mf
    %endif
  %endif
  
  %assign tag = SLibGetTag(type, name)
  
  %% Include the code template from "rtw_code.tlc" (or custom template)
  %if ERTCustomFileBanners
    %assign template = (type == "SystemBody") ? ...
      ERTSrcFileBannerTemplate : ERTHdrFileBannerTemplate
  %else
    %assign template = "rtw_code.tlc"
  %endif

  %% Add model file record
  %% Defines the structure of a file 
  %% (e.g. the opFile argument to SLibSetModelFileAttribute and SLibGetModelFileAttribute)
  
  %addtorecord ::CompiledModel.ModelFiles   \
  ModelFile {                              \
    Name                   "%<name>"       \
    BaseName               "%<basename>"       \
    Type                   "%<type>"       \
    Creator                "%<creator>"    \
    Index                  ModelFiles.NumModelFiles \
    SystemsInFile          []              \
    RequiredIncludes       []              \
    Filter                 0               \
    IsEmpty                TLC_TRUE        \
    WrittenToDisk          TLC_FALSE       \
    Indent                 TLC_FALSE       \
    Shared                 TLC_FALSE       \
    SharedType             TLC_FALSE       \
    CodeTemplate           template        \
    OutputDirectory        ""              \
    Group                  ""              \
    DefinedMacro           ""              \
    Contents {                             \
      Banner               ""              \
      Includes             ""              \
      ModelTypesIncludes   ""              \
      ModelTypesDefines    ""              \
      Defines              ""              \
      ModelTypesTypedefs   ""              \
      IntrinsicTypes       ""              \
      PrimitiveTypedefs    ""              \
      UserTop              ""              \
      Typedefs             ""              \
      Enums                ""              \
      Definitions          ""              \
      ExternData           ""              \
      ExternFcns           ""              \
      FcnPrototypes        ""              \
      Declarations         ""              \
      Functions            ""              \
      CompilerErrors       ""              \
      CompilerWarnings     ""              \
      Documentation        ""              \
      UserBottom           ""              \
    }                                      \
    CustomContents {                       \
      NumCustomContents 0                  \
    }                                      \
  }
  %addtorecord ::CompiledModel.ModelFiles %<tag> %<ModelFiles.NumModelFiles>
  
  %assign ::CompiledModel.ModelFiles.NumModelFiles = ModelFiles.NumModelFiles + 1

  %return ModelFiles.ModelFile[ModelFiles.NumModelFiles - 1]

%endfunction

%% Function: SLibSetContentAttribute ========================================
%% Abstract: 
%%   Adds to the Contents field of a file
%%
%% Arguments:
%%   opFile - the file we are adding to (see CompiledModel.ModelFiles structure above)
%%   c - specifies the Contents section <opFile>.Contents
%%   attrib - the subfield of the Contents to add to, e.g. Includes or Typedefs or ...
%%   value - the text to add

%function SLibSetContentsAttribute(opFile, c, attrib, value) void
  %if !ISFIELD(c,attrib)
    %assign errTxt = "Attempt to set the value of an attribute that does " ...
      "not exist for source file %<opFile.Name>: %<attrib>."
    %<LibReportError(errTxt)>
  %endif
  %if !WHITE_SPACE(value)
    %assign c.%<attrib> = c.%<attrib> + value
    %assign opFile.IsEmpty = TLC_FALSE
  %endif
%endfunction

%% Function: SLibSetModelFileAttribute ========================================
%% Abstract: 
%%   Adds to either the file Contents or to some other top-level section
%%   of the file (e.g. RequiredIncludes)
%%
%% Arguments:
%%   opFile - the file we are adding to (see CompiledModel.ModelFiles structure above)
%%   attrib - can specify a top-level section (field name) of the file to add to
%%            (e.g. RequiredIncludes), or can specify a sub-section (field name) of
%%            Contents (e.g. Includes or Typedefs or ...).
%%   value - the text to add

%function SLibSetModelFileAttribute(opFile,attrib,value) void
  %% After LibClearModelFileBuffers() is called, Contents will not
  %% exist. However, still allow access to SystemsInFile,
  %% RequiredIncludes, NeedsModelHeader.
  %if ISFIELD(opFile,"Contents")
    %assign c = opFile.Contents
  %endif

  %% Handle a few known attributes (top-level fields) here, and for all others 
  %% call SLibSetContentsAttribute to set the appropriate sub-field of Contents
  %switch attrib
    %case "SystemsInFile"
      %foreach idx = SIZE(opFile.SystemsInFile,1)
	%if opFile.SystemsInFile[idx] == value
	  %% already in list
	  %return ""
	%endif
      %endforeach
      %assign opFile.SystemsInFile = opFile.SystemsInFile + value
      %break
    %case "RequiredIncludes"
      %% Add to RequiredIncludes unless already there
      %foreach idx = SIZE(opFile.RequiredIncludes,1)
	%if opFile.RequiredIncludes[idx] == value
	  %% already in list
	  %return ""
	%endif
      %endforeach
      %assign opFile.RequiredIncludes = opFile.RequiredIncludes + value
      %break
    %case "Filter"
      %assert (value == 1)
      %assign opFile.Filter = value
      %break
    %case "WrittenToDisk"
      %assert (value == TLC_TRUE)
      %assign opFile.WrittenToDisk = value
      %break
    %case "Banner"
      %if IncludeFileBanners
	%<SLibSetContentsAttribute(opFile, c, attrib, value)>
      %endif
      %break
    %case "CodeTemplate"
    %case "OutputDirectory"
      %assign opFile.%<attrib> = value
      %break
    %case "Group"
      %if ISEMPTY(opFile.Group)
        %assign opFile.Group = value
      %endif
      %break
    %default
      %<SLibSetContentsAttribute(opFile, c, attrib, value)>
  %endswitch      
%endfunction


%% Function: SLibSetModelFileAttributeWithRequiredInclude ==================================
%% Abstract: 
%%   Like SLibSetModelFileAttribute, but this version also adds a specified include
%%   (currently always "rtwtypes.h") to the RequiredIncludes section
%%
%% Arguments:
%%   opFile - the file we are adding to (see CompiledModel.ModelFiles structure above)
%%   attrib - can specify a top-level section (field name) of the file to add to
%%            (e.g. RequiredIncludes), or can specify a sub-section (field name) of
%%            Contents (e.g. Includes or Typedefs or ...).
%%   value - the text to add
%%   incl - the include to add to RequiredIncludes. The caller should just
%%          pass the include file name, e.g. "rtwtypes.h", and later on the
%%          emitting code will wrap that in an include directive
%%          to turn it into: #include "rtwtypes.h"

%function SLibSetModelFileAttributeWithRequiredInclude(opFile,attrib,value,incl) void
  %% Call the underlying function twice, first to add to the RequiredIncludes,
  %% then to add to the given section. But note we're careful not to add the
  %% RequiredIncludes if we're not actually adding anything (i.e. if value is empty).
  %% 
  %if !WHITE_SPACE(value) && !WHITE_SPACE(incl)
    %<SLibSetModelFileAttribute(opFile, "RequiredIncludes", incl)>  
  %endif
  %<SLibSetModelFileAttribute(opFile, attrib, value)>  
%endfunction


%function SLibGetModelFileIndent(opFile) void
  %return opFile.Indent
%endfunction

%function SLibSetModelFileIndent(opFile, setting) void
  %assign opFile.Indent = setting
%endfunction

%function SLibGetModelFileShared(opFile) void
  %return opFile.Shared
%endfunction

%function SLibSetModelFileShared(opFile, setting) void
  %assign opFile.Shared = setting
%endfunction

%function SLibGetModelFileSharedType(opFile) void
  %return opFile.SharedType
%endfunction

%function SLibSetModelFileSharedType(opFile, setting) void
  %assign opFile.SharedType = setting
%endfunction

%function SLibGetModelFileIsEmpty(opFile) void
  %return opFile.IsEmpty
%endfunction

%function SLibGetModelFileFromTag(tag) void
  %return ModelFiles.ModelFile[ModelFiles.%<tag>]
%endfunction

%% Function: LibGetNumModelFiles ================================================
%% Abstract:
%%   Get the number of generated files.
%%
%function LibGetNumModelFiles() void
  %return ModelFiles.NumModelFiles
%endfunction


%% Function: LibGetModelFileTag =================================================
%% Abstract:
%%   Returns <fileName>_h and <fileName>_c for header and source files,
%%   respectively where fileName is the name of the model file.
%%   This is useful for creating a header file multiple inclusion guaurd.  For example,
%%     __RTW_GENERATED_HEADER_FILE_%<LibGetModelFileTag()>__
%%
%function LibGetModelFileTag(fileIdx) void
  %assign mf = ModelFiles.ModelFile[fileIdx]
  %assign ext  = mf.Type == "SystemBody" ? "_c" : "_h"
  %return "%<mf.BaseName>%<ext>"
%endfunction


%% Function: LibGetModelFileNeedHeaderGuard ====================================
%% Abstract:
%%   Return true if a header file guard is required, and false otherwise.
%%
%function LibGetModelFileNeedHeaderGuard(fileIdx) void
  %assign opFile = LibGetSourceFileFromIdx(fileIdx)
  %if LibGetModelFileAttribute(fileIdx,"Type") != "SystemHeader"
    %return 0
  %elseif LibGetSourceFileShared(fileIdx)
    %% Shared utility functions put out their own guard (in cache_sharedutils_lib.tlc)
    %% so return false here.
    %return 0
  %elseif opFile.Name == SLibGetFileNameForCode("rtwtypes_hdr")
    %return 0
  %else
    %if CodeFormat == "S-Function"
      %assign tag = LibGetModelFileTag(fileIdx)
      %assign mdlName = LibGetModelName()
      %return tag != "%<mdlName>_mid_h" && tag != "%<mdlName>_sid_h"
    %else
      %return 1
    %endif
  %endif
%endfunction


%% Function: LibGetModelFileAttribute ===========================================
%% Abstract:
%%   (MathWorks internal function.  External users, use LibGetSourceFileSection instead.)
%%   Gets a specified section of a file.
%%
%% Arguments:
%%   fileIdx - file index
%%   attrib - either a top-level field name or a sub-field of Contents

%function LibGetModelFileAttribute(fileIdx, attrib) void
  
  %if ModelFiles.ComplianceLevel == -1
    %assign errTxt = "Must set code template compliance level with " ...
      "TLC function LibSetCodeTemplateComplianceLevel()."
    %<LibReportFatalError(errTxt)>
  %endif
  
  %assign opFile = ModelFiles.ModelFile[fileIdx]

  %% After LibClearModelFileBuffers() is called, Contents will not
  %% exist. However, still allow access to Name, BaseName, Type and Creator.
  %if ISFIELD(opFile,"Contents")
    %assign c = opFile.Contents
  %endif

  %switch attrib
    %case "Name" 
      %assign headerExt = ".h"
      %assign sourceExt = "." + ::LangFileExt
      %assign extension = opFile.Type == "SystemHeader" ? headerExt : sourceExt
      %return "%<opFile.Name>%<extension>"
    %case "BaseName" 
      %assign headerExt = ".h"
      %assign sourceExt = "." + ::LangFileExt
      %assign extension = opFile.Type == "SystemHeader" ? headerExt : sourceExt
      %return "%<opFile.BaseName>%<extension>"
    %case "Type"
    %case "Creator"
    %case "Filter"
    %case "IsEmpty"
    %case "WrittenToDisk"
    %case "CodeTemplate"
    %case "OutputDirectory"
    %case "Group"
      %return opFile.%<attrib>
    %case "Banner"
      %return c.%<attrib>
    %case "Includes"
      %% This prepends the RequiredIncludes to the Includes, 
      %% but otherwise goes through the same steps as the
      %% the other fields of Contents (below)
      %<FcnAppendMissingTokens(opFile,attrib)> %% inserts from CustomContents if needed
      %% Roll together the RequiredIncludes, if any.
      %% Note what we have in the array is just the include filenames,
      %% so the code below wraps these in an "#include \"<filename>\"" directive.
      %assign retValue = ""
      %foreach idx = SIZE(opFile.RequiredIncludes,1)
        %assign requiredFile = opFile.RequiredIncludes[idx]
        %if ISEMPTY(requiredFile)
          %assign inclBuf = ""
        %elseif requiredFile[0] == "<"
          %assign inclBuf = "\n#include " + requiredFile + "\n"
        %else
          %assign inclBuf = "\n#include \"" + requiredFile + "\"\n"
        %endif
        %% Not genearte requiredFile if it is als in includes section
        %if ISEMPTY(FEVAL("strfind", c.%<attrib>, inclBuf))
          %assign retValue = retValue + inclBuf
        %endif
      %endforeach
      %% Now add in the Includes, if any
      %if !WHITE_SPACE(c.%<attrib>)
	%assign retValue = retValue + c.%<attrib>
      %endif
      %return retValue
    %case "Defines"
    %case "IntrinsicTypes"
    %case "PrimitiveTypedefs"
    %case "UserTop"
    %case "Typedefs"
    %case "Enums"
    %case "Definitions"
    %case "ExternData"
    %case "ExternFcns"
    %case "FcnPrototypes"
    %case "Declarations"
    %case "Functions"
    %case "CompilerErrors"
    %case "CompilerWarnings"
    %case "Documentation"
    %case "UserBottom"
    %case "ModelTypesIncludes"
    %case "ModelTypesDefines"
    %case "ModelTypesTypedefs"
      %% This inserts from the CustomContents section, if needed
      %<FcnAppendMissingTokens(opFile,attrib)>
      %if !WHITE_SPACE(c.%<attrib>)
	%return "\n" + c.%<attrib>
      %else
	%return ""
      %endif
    %default
      %assign errTxt = "Uknown file attribute: %<attrib>"
      %<LibReportFatalError(errTxt)>
  %endswitch
%endfunction  %% LibGetModelFileAttribute


%% Function: LibClearModelFileBuffers ==========================================
%% Abstract:
%%   Clear the variables associated with Model File contents.
%%
%function LibClearModelFileBuffers() void
  %if ResetTLCGlobalsAfterUse
    %with ::CompiledModel.ModelFiles
      %foreach idx = NumModelFiles
	%with ModelFile[idx]
	  %undef Contents
	%endwith
      %endforeach
    %endwith %% CompiledModel.ModelFiles
  %endif
%endfunction


%% Function: LibWriteToStandardOutput ==========================================
%% Abstract:
%%   Assuming the current file is NULL_FILE, write text to the MATLAB command
%%   window.  If the current file is not NULL_FILE, you need to reselect the
%%   appropriate file after a call to this function.
%%
%function LibWriteToStandardOutput(txt) void
%%
%% DO NOT INDENT THIS TLC CODE !!!
%%
%selectfile STDOUT
%if RTWVerbose
%<txt>
%endif
%selectfile NULL_FILE
%endfunction  %% LibWriteToStandardOutput


%% Function: LibSetCodeTemplateComplianceLevel =================================
%% Abstract:
%%   Synchronize a custom code template.  This function must be
%%   called from a code template.
%%
%function LibSetCodeTemplateComplianceLevel(level) void
  %if level != 1 && level != 2
    %assign errTxt = "Unknown code template compliance level: %<level>"
    %<LibReportError(errTxt)>
  %endif
  %assign ::CompiledModel.ModelFiles.ComplianceLevel = level
%endfunction

%% [EOF] codetemplatelib.tlc
