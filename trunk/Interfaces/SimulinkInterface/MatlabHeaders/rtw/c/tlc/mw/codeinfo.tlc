%% ============================================================================
%% 
%%  
%% 
%%
%% Abstract: 
%%   This file creates the codeInfo MATLAB object and saves it in a MAT file.
%%   The process of creation here means emitting out an MATLAB file which 
%%   contains appropriate syntax to create codeInfo object.
%%
%% Copyright 2007-2012 The MathWorks, Inc.
%%

%if (EXISTS("_CIINFO_") == 0)
%assign _CIINFO_ = 1

%include "%<::CompiledModel.Name>_codeIRInfo.tlc"
%include "codeinfolib.tlc"
%% reset state of codeinfolib.tlc which is also used by C API processing
%<SLibResetCodeInfoLib()>

%include "codeinfodatalib.tlc"
%include "codeinfofcnlib.tlc"
%include "codeinfomdlreflib.tlc"
%include "autosarsup.tlc"

%selectfile NULL_FILE
%realformat "CONCISE"

%% Name of the .m function which creates the codeInfo object and saves in .mat
%assign fcnName = "writeCodeInfoFcn"
%assign timingSubfcnName = "getIndexFromTimingInternalId"
%assign iDataSubfcnName = "getInternalDataByName"
%assign iDataSubfcnVariableName = "getInternalDataByVariableName"
%assign nameChkfcnName = "checkDataGraphicalNames"

%selectfile NULL_FILE

%%with CompiledModel
%% Open file on disk and start writing to it
%openfile ModelCI = "%<fcnName>.m"
%assign comment = "% Autogenerated file: %<::CompiledModel.GeneratedOn>"
%<comment>
function %<fcnName>

%assign componentObj = "codeInfo"
%if (ExportFunctionsMode != 0)
  %assign expInportsObj = "expInports"
%else
  %assign expInportsObj = ""
%endif
%if ISEQUAL(SLibAutosarGetSchemaVersion(), "4.0")
  %assign typeReplaceObj = "typeReplaceMap"
%else
  %assign typeReplaceObj = ""
%endif
%assign comment = "% Load a ComponentInterface object from IR"
%<comment>
%<FcnLoadCodeIRInfo()>

%if SLibAutosarActive()
  %assign map = FcnGetAutosarDataMap()
%<componentObj>.Name          = '%<map.ComponentName>';
%if ISEQUAL(SLibAutosarGetSchemaVersion(), "4.0")
  %assign aiObj = CompiledModel.RTWAutosar.Object.ObjectProperties
  typeReplaceMap = containers.Map();
  %if ISFIELD(aiObj, "Appl2ImplDataTypeMap")
    %assign mapSize = aiObj.NumAppl2ImplDataTypeMap
    %foreach mapIdx = mapSize
      %assign mapObj = aiObj.Appl2ImplDataTypeMap[mapIdx].Object
      %assign appTypeName = mapObj.ObjectProperties.ApplicationTypeName
      %assign impTypeName = mapObj.ObjectProperties.ImplementationTypeName
      typeReplaceMap('%<appTypeName>') = '%<impTypeName>';
    %endforeach
  %endif
%endif
%endif
%%
%<SLibCreateInportInterfaces()>
%%
%<SLibCreateOutportInterfaces()>
%%
skippedParameters = [];
%<SLibCreateParameterInterfaces()>
%assign prmArgs = SLibCreateParameterArguments()
if ~isempty(%<prmArgs>)
codeInfo.Parameters = [codeInfo.Parameters; %<prmArgs>];
end
%%
%<SLibCreateDataStoreInterfaces()>
%%
%if !GenerateClassInterface
  %if !IsModelReferenceTarget()
    %% Create Initialize function interface
    %<SLibCreateModelFunctionInterface(componentObj, "Initialize", "")>
    %%
    %if LibIsDeploymentDiagram()
      %<SLibDeploymentGenerateCodeInfo(componentObj)>
    %elseif (ExportFunctionsMode == 0) && (SLibIsAsyncTaskOnlyModel() == TLC_FALSE)
      %assign isRateGrouping = SLibIsMultiRateAndRateGrouping(System[NumSystems-1])
      %%
      %assign updateCState  = (NumContStates > 0)
      %if isRateGrouping
        %%    
        %% Create rate grouped function interfaces      
        %foreach tidIdx = NumSynchronousSampleTimes
          %if (tidIdx==1) && FixedStepOpts.TID01EQ
            %continue
          %endif
          %assign tid = tidIdx
          %if !CombineOutputUpdateFcns
            %assign outString = "Output"
            %if updateCState
              %assign updateString = "UpdateContStates"
            %else 
              %assign updateString = "RootUpdate"
            %endif
            %<SLibCreateModelFunctionInterface(componentObj, outString, tid)>
            %<SLibCreateModelFunctionInterface(componentObj, updateString, tid)>
          %else
            %if updateCState 
              %assign outString = "UpdateContStates"
            %else
              %assign outString = "OutputUpdate"
            %endif
            %<SLibCreateModelFunctionInterface(componentObj, outString, tid)>
          %endif
          %assign updateCState = TLC_FALSE 
        %endforeach
      %else
        %%    
        %% Create non-rate grouped function interfaces
        %if !CombineOutputUpdateFcns
          %assign outString = "Output"
          %if updateCState
            %assign updateString = "UpdateContStates"
          %else 
            %assign updateString = "RootUpdate"
          %endif
          %<SLibCreateModelFunctionInterface(componentObj, outString, "")>
          %<SLibCreateModelFunctionInterface(componentObj, updateString, "")>
        %else
          %if updateCState 
            %assign outString = "UpdateContStates"
          %else
            %assign outString = "OutputUpdate"
          %endif
          %<SLibCreateModelFunctionInterface(componentObj, outString, "")>
        %endif
      %endif
    %elseif (ExportFunctionsMode != 0)
      %if (SLibAutosarActive())
        %<SLibCreatePeriodicRunnables(componentObj)>
      %else
        %<SLibCreateExportFunctions(componentObj)>
      %endif
    %else
      %% do nothing
    %endif
    
    %if IncludeMdlTerminateFcn
      %<SLibCreateModelFunctionInterface(componentObj, "Terminate", "")>
    %endif
  %else
    %<SLibCreateModelReferenceFunctionInterfaces(componentObj)>
  %endif
%else
  %if IsModelReferenceRTWTarget()
    %<SLibCreateModelReferenceFunctionInterfaces(componentObj)>
    for i=1 : length(codeInfo.OutputFunctions)
       codeInfo.OutputFunctions(i).Owner = codeInfo.InternalData(1).Implementation;
    end
  %elseif NumSynchronousSampleTimes > 1 && SLibIsRateGrouping()  %% multi rate
    fcnVec = [];
    %foreach tid = NumSynchronousSampleTimes
      %if (tid==1) && FixedStepOpts.TID01EQ
        %continue
      %endif
     
      %assign timeObj = SLibGetRTWTimingObject(tid)
      fcnTemp = codeInfo.OutputFunctions(1);      
      tmpImpl = RTW.CImplementation;
      tmpImpl.Name = [fcnTemp.Prototype.Name,'%<tid>'];
      tmpImpl.HeaderFile = fcnTemp.Prototype.HeaderFile;
      tmpImpl.SourceFile = fcnTemp.Prototype.SourceFile;
      tmpFcn = RTW.FunctionInterface;
      tmpFcn.Prototype = tmpImpl;
      tmpFcn.Timing = %<timeObj>;
      tmpFcn.Owner = fcnTemp.Owner;
      fcnVec = [fcnVec; tmpFcn];
    %endforeach  
    %% depending on the fix of g758487, the wrapper step function may or may not present
    codeInfo.OutputFunctions = fcnVec;
  %endif
%endif

%% Add AUTOSAR PIMDefs to codeInfo. Needed for AUTOSAR arxml export.
%if SLibAutosarActive()
  %assign pimObj = "pimInfo"
  %<SLibAutosarWriteOutPIMDefsForCodeInfo(pimObj)>
%endif

if ~isempty(skippedParameters)
codeInfo.Parameters(skippedParameters) = [];
end

%% Writing out internal data
%assign internalData = FIELDNAMES(CodeInfoMap.InternalDataMap)
%foreach idx = SIZE(internalData,1)
  %if (idx == 0)
%<componentObj>.InternalData = [%<componentObj>.InternalData; %<internalData[idx]>];
  %else
%<componentObj>.InternalData(end+1) = %<internalData[idx]>;
  %endif
%endforeach

%assign comment = "% Handling Right-Click Builds"
%<comment>
ss = rtwprivate('getSourceSubsystemHandle',codeInfo.GraphicalPath);
%assign comment = "% Check if Rt-Click build, then re-map SIDs"
%<comment>
if ~isempty(ss) && rtwprivate('rtwattic','hasSIDMap')
   codeInfo = modifyCodeInfoForSubsystemBuild(ss, codeInfo);
end

%if !IsModelReferenceTarget()
save codeInfo.mat %<componentObj> %<expInportsObj> %<typeReplaceObj>;
%else
  %assert IsModelReferenceRTWTarget() || ...
    (IsModelReferenceSimTarget() && ::CompiledModel.PILSimTargetUnification)
save %<CompiledModel.Name>_mr_codeInfo.mat %<componentObj>  
%endif
  
returnVal = 1;

%assign comment = "% End Function"
%<comment>: %<fcnName>

function idx = %<timingSubfcnName>(internalIdVec, internalId)
 idx = find(internalIdVec == internalId);
 if (isempty(idx) || (length(idx) > 1))
    ciMsg = 'Time object cannot be empty'; 
    ciExc = MException('RTW:buildProcess:CodeInfoInternalError',ciMsg);
    throw(ciExc);
  end
%<comment>: %<timingSubfcnName>

function %<nameChkfcnName>(ciName, rtwName)
  if (strcmp(ciName, rtwName) ~= 1)
    ciMsg = ['Name mismatch: ', ciName, ' and ', rtwName]; 
    ciExc = MException('RTW:buildProcess:CodeInfoInternalError',ciMsg);
    throw(ciExc);
  end
%<comment>: %<nameChkfcnName>

function iData = %<iDataSubfcnName>(iDataVec, iDataName)
 iData = find(iDataVec, 'GraphicalName', iDataName);
 if (isempty(iData) || (length(iData) > 1))
    ciMsg = 'Internal Data object cannot be empty'; 
    ciExc = MException('RTW:buildProcess:CodeInfoInternalError',ciMsg);
    throw(ciExc);
  end
%<comment>: %<iDataSubfcnName>

function iData = %<iDataSubfcnVariableName>(iDataVec, iDataVariableName)
 iData = [];
 for idxData = 1:numel(iDataVec)
    if strcmp(iDataVariableName, iDataVec(idxData).Implementation.VariableName)
       iData = iDataVec(idxData);
       break
    end
 end
 if isempty(iData)
    ciMsg = 'Internal Data object cannot be empty'; 
    ciExc = MException('RTW:buildProcess:CodeInfoInternalError',ciMsg);
    throw(ciExc);
  end
%<comment>: %<iDataSubfcnVariableName>

function codeInfo = modifyCodeInfoForSubsystemBuild(ss, codeInfo)
    
%assign comment = "% Extract Subsystem Build Map from AtticData"
%<comment>
    Subsystem_Build_Mapping = rtwprivate('rtwattic','getSIDMap');

%assign comment = "% Parameters"
%<comment>
    for i = 1:length(codeInfo.Parameters)
        sid = codeInfo.Parameters(i).SID;        

        sid = Simulink.ID.getSubsystemBuildSID(sid,ss, Subsystem_Build_Mapping);
        codeInfo.Parameters(i).SID = sid;        
    end
    
%assign comment = "% Data Stores"
%<comment>
     for i = 1:length(codeInfo.DataStores)
         sid = codeInfo.DataStores(i).SID;         

         sid = Simulink.ID.getSubsystemBuildSID(sid,ss, Subsystem_Build_Mapping);
         codeInfo.DataStores(i).SID = sid;
     end
    
%assign comment = "% Inports"
%<comment>
    for i = 1:length(codeInfo.Inports)
        sid = codeInfo.Inports(i).SID;
        
        sid = Simulink.ID.getSubsystemBuildSID(sid,ss, Subsystem_Build_Mapping);
        codeInfo.Inports(i).SID = sid;
    end
    
%assign comment = "% Outports"
%<comment>
    for i = 1:length(codeInfo.Outports)
        sid = codeInfo.Outports(i).SID;
 
        sid = Simulink.ID.getSubsystemBuildSID(sid,ss, Subsystem_Build_Mapping);
        codeInfo.Outports(i).SID = sid;
    end    
   
%closefile ModelCI

%endif  %% _CIINFO_

%% [EOF] codeinfo.tlc
