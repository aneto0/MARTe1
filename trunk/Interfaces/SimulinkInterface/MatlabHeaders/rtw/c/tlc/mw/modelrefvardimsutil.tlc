%% ============================================================================
%% 
%% 
%%
%% Abstract:
%%   This system file contains helper functions to support vardims signals
%% for model reference.
%%
%% Copyright 1994-2011 The MathWorks, Inc.
%%

%if EXISTS("_MODELREFVARDIMSUTIL_") == 0
%assign _MODELREFVARDIMSUTIL_ = 1


%% Function SLibGetArgUseCanDimSizeDW =======================================
%% Abstract:
%%   Check if a data input/output port or external input/output port uses
%%   canonical dimsize dwork
%function SLibGetArgUseCanDimSizeDW(arg)
  
  %if AllowVarDimsSig
    %return ISFIELD(arg, "CanonicalDimSizeDWorkIdx")
  %else
    %return TLC_FALSE
  %endif
  
%endfunction %% end SLibGetArgUseCanDimSizeDW


%% Function SLibGetCanDimSizeDWIdxForArg =======================================
%% Abstract:
%%   Check if a data input/output port or external input/output port uses
%%   canonical dimsize dwork
%function SLibGetCanDimSizeDWIdxForArg(arg)
  
  %assert(SLibGetArgUseCanDimSizeDW(arg))
  %return arg.CanonicalDimSizeDWorkIdx
  
%endfunction %% end SLibGetCanDimSizeDWIdxForArg


%% Function SLibGetArgUseSharedDimSizeDW =======================================
%% Abstract:
%%   Check if a data input/output port or external input/output port uses
%%   shared dwork as dimsize dwork
%function SLibGetArgUseSharedDimSizeDW(arg)
  
  %if AllowVarDimsSig
    %return ISFIELD(arg, "DimSizeDWork")
  %else
    %return TLC_FALSE
  %endif
  
%endfunction %% end SLibGetArgUseSharedDimSizeDW


%% Function SLibGetArgIsVarDims ============================================
%% Abstract:
%%   Check if a data input/output port or external input/output port is variable 
%%   dimensions mode or it is a nonvirtual bus contains variable-size element
%function SLibGetArgIsVarDims(arg)
  
  %if AllowVarDimsSig
    %return SLibGetArgUseCanDimSizeDW(arg) || SLibGetArgUseSharedDimSizeDW(arg)
  %else
    %return TLC_FALSE
  %endif
  
%endfunction %% end SLibGetArgIsVarDims


%% Function SLibGetExternalIOIsVarDims ============================================
%% Abstract:
%%   Check if a external input/output is variable dimensions mode or it is a 
%%   nonvirtual bus contains variable-size element. Canonical
%%   input/output cannot have field DimSizeDWork
%function SLibGetExternalIOIsVarDims(canIO)
  
  %return SLibGetArgUseCanDimSizeDW(canIO)
  
%endfunction %% end SLibGetExternalIOIsVarDims


%% Function SLibGetCanIOIsVarDims ============================================
%% Abstract:
%%   Check if a canonical input/output is variable dimensions mode. or it is a 
%%   nonvirtual bus contains variable-size element. Canonical
%%   input/output cannot have field DimSizeDWork
%function SLibGetCanIOIsVarDims(canIO)
  
  %return SLibGetArgUseCanDimSizeDW(canIO)
  
%endfunction %% end SLibGetCanIOIsVarDims


%% Function SLibGetCanDWorkIsCanDimSizeDWork =================================
%% Abstract: 
%%   Check if a canonical dwork is used as a canonical dimsize dwork
%function SLibGetCanDWorkIsCanDimSizeDWork(cdwIdx)
  
  %if AllowVarDimsSig
    %if ISFIELD(CanonicalDWorkArgDef[cdwIdx], "IsCanDimSizeDWork")
      
      %assign isDimSizeDWork = CanonicalDWorkArgDef[cdwIdx].IsCanDimSizeDWork
      
    %else
      
      %% Loop through all canonical inputs and outputs to check if 
      %% any of them use this canonical dwork as canonical dimsize dwork
      
      %assign isDimSizeDWork = TLC_FALSE
      
      %% check if it is used as an input dim size canonical dwork
      %foreach argIdx = NumCanonicalInputArgDefs
        %assign ci = CanonicalInputArgDef[argIdx]
        %if SLibGetCanIOIsVarDims(ci) && ...
          cdwIdx == SLibGetCanDimSizeDWIdxForArg(ci)
          %assign isDimSizeDWork = TLC_TRUE
          %break
        %endif
      %endforeach %% NumCanonicalInputArgDefs
      
      %if !isDimSizeDWork
        %% check if it is used as an output dim size canonical
        %% dwork for an output port with lower index
        %foreach argIdx = NumCanonicalOutputArgDefs
          %assign co = CanonicalOutputArgDef[argIdx]
          %if SLibGetCanIOIsVarDims(co) && ...
            cdwIdx == SLibGetCanDimSizeDWIdxForArg(co)
            %assign isDimSizeDWork = TLC_TRUE
            %break
          %endif
        %endforeach %% end NumCanonicalInputArgDefs
      %endif
      
      %addtorecord CanonicalDWorkArgDef[cdwIdx] IsCanDimSizeDWork isDimSizeDWork
    %endif
  
    %return isDimSizeDWork
  %else
    %return TLC_FALSE
  %endif
  
%endfunction %% end SLibGetCanDWorkIsCanDimSizeDWork

%% Function SLibGetDWorkIsCanDimSizeDWorkInBaseSys ==============================
%% Abstract:
%%   Check if a dwork is ever used as canonical dimsize dwork in the base system. 
%%   If so, this dwork won't be used as other type of DWork in base system
%function SLibGetDWorkIsCanDimSizeDWorkInBaseSys(dwIdx)
  
  %if AllowVarDimsSig
    %if ISFIELD(::CompiledModel.DWorks.DWork[dwIdx], "IsCanDimSizeDWorkInBaseSysem")
    
      %assign isCanDimSizeDWork = ::CompiledModel.DWorks.DWork[dwIdx].IsCanDimSizeDWorkInBaseSystem
    
    %else
      
      %% find the canonical dwork point to this dwork and check
      %% if it is used as a canonical dimsize dwork
      
      %assign isCanDimSizeDWork = TLC_FALSE
      %assign baseSysIdx = GetBaseSystemIdx()
      %assign baseSys = ::CompiledModel.System[baseSysIdx]
      %with baseSys.Interface
        %foreach cdwIdx = NumCanonicalDWorkArgDefs
          %assign canDW = CanonicalDWorkArgDef[cdwIdx]
          %if canDW.FirstSignalSrc == dwIdx
            %if SLibGetCanDWorkIsCanDimSizeDWork(cdwIdx)
              %assign isCanDimSizeDWork = TLC_TRUE
            %endif
            %break
          %endif
        %endforeach
      %endwith
      
      %addtorecord ::CompiledModel.DWorks.DWork[dwIdx] IsCanDimSizeDWorkInBaseSysem isCanDimSizeDWork
    %endif
    
    %return isCanDimSizeDWork
  %else
    %return TLC_FALSE
  %endif
  
%endfunction %% end SLibGetDWorkIsCanDimSizeDWorkInBaseSys


%% Function SLibGetDimSizeDWorkFullPath ==========================================
%% Abstract:
%%   Return the full path of a non-canonical dimsize dwork
%function SLibGetDimSizeDWorkFullPath(dimSizeDWorkIdx)
  %assign dworkRec        = ::CompiledModel.DWorks.DWork[dimSizeDWorkIdx]
  %if ISFIELD(dworkRec, "VarGroupIdx")
    %assign varGroup        = ::CompiledModel.VarGroups.VarGroup[dworkRec.VarGroupIdx[0]]
    %assign varGroupTypeIdx = varGroup.CGTypeIdx
    %assign varGroupType    = ::CompiledModel.CGTypes.CGType[varGroupTypeIdx]
    %assign varGroupMember  = varGroupType.Members.Member[dworkRec.VarGroupIdx[1]]
    %assign memberId        = varGroupMember.Name
    %assign memberTypeIdx   = varGroupMember.CGTypeIdx

    %if IsModelReferenceTarget()
      %assign name = varGroup.LocalName
    %else
      %assign name = varGroup.Name
    %endif

    %if IsModelReferenceTarget() || varGroup.IsPointer
      %assign fullpath = name + "->" + memberId
    %else
      %assign fullpath = name + "." + memberId
    %endif
    
    %assign width = LibCGTypeWidth(memberTypeIdx)
    %if width == 1
      %assign fullpath = "&" + fullpath
    %else
      %assert width > 1
      %assign fullpath = "&" + fullpath + "[0]"
    %endif
  %else
    %assign dataLayout   = SLibGetDataLayout(dworkRec)
    %assign name         = dworkRec.Identifier
    %assign isPointer    = dworkRec.StorageClass == "ImportedExternPointer" ? ...
      TLC_TRUE : TLC_FALSE
    %if (isPointer)
      %assign fullpath   = "%<name>"
    %else
      %assign fullpath   = "&%<name>%<dataLayout[3]>"
    %endif    
  %endif
  %return fullpath
%endfunction %% end SLibGetDimSizeDWorkFullPath


%% Function SLibGetDimSizeDWorkFullPathForFcnArg ==============================
%% Abstract:
%%   Return the full path of a non-canonical dimsize dwork
%%
%function SLibGetDimSizeDWorkFullPathForFcnArg(dimSizeDWorkIdx, baseIdx, cross)
  %assign dworkRec        = ::CompiledModel.DWorks.DWork[dimSizeDWorkIdx]
  %if ISFIELD(dworkRec, "VarGroupIdx")
    %assign varGroup        = ::CompiledModel.VarGroups.VarGroup[dworkRec.VarGroupIdx[0]]
    %assign varGroupTypeIdx = varGroup.CGTypeIdx
    %assign varGroupType    = ::CompiledModel.CGTypes.CGType[varGroupTypeIdx]
    %assign varGroupMember  = varGroupType.Members.Member[dworkRec.VarGroupIdx[1]]
    %assign memberId        = varGroupMember.Name
    %assign memberTypeIdx   = varGroupMember.CGTypeIdx

    %% SLibCGIRVarGroupPath doesn't work for non-hierarchical var groups.
    %% thus we need to generate prefix by ourselves if the input size
    %% is from root inport.
    %if varGroup.Category == "ExternalInputSize"
      %assign fullpath = varGroup.Name + "."
    %else
      %assign fullpath = SLibCGIRVarGroupPath(dworkRec.VarGroupIdx[0], baseIdx, cross)
    %endif
    %assign fullpath = fullpath + memberId
  
    %assign width = LibCGTypeWidth(memberTypeIdx)
    %if width == 1
      %assign fullpath = "&" + fullpath
    %else
      %assert width > 1
      %assign fullpath = "&" + fullpath + "[0]"
    %endif
  %else
    %assign dataLayout   = SLibGetDataLayout(dworkRec)
    %assign name         = dworkRec.Identifier
    %assign isPointer    = dworkRec.StorageClass == "ImportedExternPointer" ? ...
      TLC_TRUE : TLC_FALSE
    %if (isPointer)
      %assign fullpath   = "%<name>"
    %else
      %assign fullpath   = "&%<name>%<dataLayout[3]>"
    %endif    
  %endif
  
  %return fullpath
%endfunction %% end SLibGetDimSizeDWorkFullPath


%% Function: SLibGetBlockOutputVarDimsIdentifierFromRecord
%%    From the .rtw file BlockOutputs Record get its base identifier in the
%%    block I/O structure to be accessed from within the accessSysIdx
%function SLibGetBlockOutputVarDimsIdentifierFromRecord(dimSizeDWorkIdx, accessSysIdx) void
  %assign dworkRec        = ::CompiledModel.DWorks.DWork[dimSizeDWorkIdx]
  %if ISFIELD(dworkRec, "VarGroupIdx")
    %assign varGroupIdx     = dworkRec.VarGroupIdx[0]
    %assign varGroup        = ::CompiledModel.VarGroups.VarGroup[dworkRec.VarGroupIdx[0]]
    %assign varGroupTypeIdx = varGroup.CGTypeIdx
    %assign varGroupType    = ::CompiledModel.CGTypes.CGType[varGroupTypeIdx]
    %if SLibVarGroupUsedAsMatrix(varGroupType)
      %assign varGroupType = SLibGetBaseTypeForVarGroupUsedAsMatrix(varGroupType)
    %endif
    %assign varGroupMember  = varGroupType.Members.Member[dworkRec.VarGroupIdx[1]]
    %assign memberId        = varGroupMember.Name
    
    %% SLibCGIRVarGroupPath doesn't work for non-hierarchical var groups.
    %% thus we need to generate prefix by ourselves if the input size
    %% is from root inport.
    %if varGroup.Category == "ExternalInputSize"
      %assign identiPath = varGroup.Name + "."
    %else
      %assign identiPath =  SLibCGIRVarGroupPath(varGroupIdx,accessSysIdx,TLC_FALSE)
    %endif
    %assign identipath = identiPath + memberId
  %else
    %assign dataLayout   = SLibGetDataLayout(dworkRec)
    %assign name         = dworkRec.Identifier
    %assign isPointer    = dworkRec.StorageClass == "ImportedExternPointer" ? ...
      TLC_TRUE : TLC_FALSE
    %if (isPointer)
      %assign identipath   = "%<name>"
    %else
      %assign identipath   = "&%<name>%<dataLayout[3]>"
    %endif    
  %endif
  %return identipath
%endfunction %% end SLibGetBlockOutputVarDimsIdentifierFromRecord


%% Function SLibGetStructDWorkIdxForModelRefBlk ================================
%% Abstract:
%%   Get the index to the dwork that is structure for the model reference block.
%%   For model reference block with only fixed-dims signals, there is only one 
%%   dwork as the packed structure. For model reference block with var-dims output,
%%   there are extra dworks as shared dimsize dwork
%%
%function SLibGetStructDWorkIdxForModelRefBlk(block)
  %if AllowVarDimsSig
    %if ISFIELD(block, "StructDWorkIdx")
      %assign structDWorkIdx = block.StructDWorkIdx
    %else
      %assign structDWorkIdx = -1
      %foreach dworkIdx = NumDWork
        %assign dworkCGType = CGTypes.CGType[::CompiledModel.DWorks.DWork[DWork[dworkIdx].FirstRootIdx].CGTypeIdx]
        %if ISFIELD(dworkCGType, "Constructor") && ISEQUAL(dworkCGType.Constructor, "unknown")
          %assign structDWorkIdx = dworkIdx
          %break
        %endif
      %endforeach
      %assert structDWorkIdx != -1
      
      %addtorecord block StructDWorkIdx structDWorkIdx
      
    %endif
    
    %return structDWorkIdx
  %else
    %return 0
  %endif
 
%endfunction %% end SLibGetStructDWorkIdxForModelRefBlk


%% Function FcnAddNeededCanDimSizeDWForCanInp ==================================
%% Abstract:
%%   Add canonical dimsize dwork for canonical input to the argument list.
%%   This is called by FcnAddNeededParameters
%%
%function FcnAddNeededCanDimSizeDWForCanInp(sysFcn, sysIdx, idx, ...
  skipCanDWork) void

  %if AllowVarDimsSig
    %assign ci = CanonicalInputArgDef[idx]
    %assign skipThisArg = 0
    %if IDNUM(ci.SignalSrc[0])[0] == "F"
      %assign skipThisArg = 1
    %endif	
    %if IDNUM(ci.SignalSrc[0])[0] == "L"
      %if (sysFcn != "Output" && sysFcn!= "Update" &&...
        sysFcn!= "RootUpdate" && sysFcn!= "OutputUpdate")
        %assign skipThisArg = 1
      %endif
    %endif
    %if skipThisArg==0   
      %if SLibGetCanIOIsVarDims(ci)
        %assign cdwIdx = SLibGetCanDimSizeDWIdxForArg(ci)
        %if !skipCanDWork[cdwIdx]
          %assign cdw = CanonicalDWorkArgDef[cdwIdx]
          %assign cTID = System[sysIdx].CurrentTID
          %assign isRG = SLibSystemFcnRateGrouping(System[sysIdx], sysFcn)    
          %if SysFcnArgNeeded(sysFcn, cdw, cTID, isRG)
            %assign identi   = LibGetRecordIdentifier(cdw)
            %assign dwRec    = ::CompiledModel.DWorks.DWork[cdw.FirstSignalSrc]
            %assign dwWidth  = SLibDWorkWidth(dwRec)
            %assign dataType = "const " + SLibGetRecordDataTypeName(dwRec, "") + " "
            %if dwWidth > 1
              %assign argDef = identi + "[%<dwWidth>]"
            %else
              %assign argDef = "*" + identi
            %endif
            %<FcnAddParameter(dataType, argDef)>
          %endif %% if SysFcnArgNeeded
        %endif %% if !skipCanDWork
      %endif %% if ISFIELD
    %endif
  %endif
%endfunction %% end FcnAddNeededCanDimSizeDWForCanInp


%% Function FcnAddNeededCanDimSizeDWForCanOut ==================================
%% Abstract:
%%   Add canonical dimsize dwork for canonical output to the argument list.
%%   This is called by FcnAddNeededParameters
%%
%function FcnAddNeededCanDimSizeDWForCanOut(sysFcn, sysIdx, idx, ...
  skipCanDWork) void
  
  %assign co = CanonicalOutputArgDef[idx]
  %if SLibGetCanIOIsVarDims(co)    
    %assign cdwIdx = SLibGetCanDimSizeDWIdxForArg(co)
    %if !skipCanDWork[cdwIdx]
      %assign cdw = CanonicalDWorkArgDef[cdwIdx]
      %assign cTID = System[sysIdx].CurrentTID
      %assign isRG = SLibSystemFcnRateGrouping(System[sysIdx], sysFcn)
      %if SysFcnArgNeeded(sysFcn, cdw, cTID, isRG)
        %assign identi   = LibGetRecordIdentifier(cdw)
        %assign dwRec    = ::CompiledModel.DWorks.DWork[cdw.FirstSignalSrc]
        %assign dwWidth  = SLibDWorkWidth(dwRec)
        %assign dataType = SLibGetRecordDataTypeName(dwRec, "") + " "
        %if dwWidth > 1
          %assign argDef = identi + "[%<dwWidth>]"
        %else
          %assign argDef = "*" + identi
        %endif
        %<FcnAddParameter(dataType, argDef)>
      %endif %% if SysFcnArgNeeded
    %endif %% if !skipCanDWork
  %endif %% 
%endfunction %% end FcnAddNeededCanDimSizeDWForCanOut


%function FcnGetModelRefDWork(aArgClass, aCanIOIdx, aCanDWorkIdx) void
  %% call site
  %assign canDWork = CanonicalDWorkArgDef[aCanDWorkIdx]
  %assign dwIdx    = canDWork.FirstSignalSrc %% global idx
  %assign dwRec    = ::CompiledModel.DWorks.DWork[dwIdx]
  %assign dwWidth  = SLibDWorkWidth(dwRec)
  %if dwWidth == 1
    %return "&" + aArgClass + "VarDims_%<aCanIOIdx>"
  %else
    %return aArgClass + "VarDims_%<aCanIOIdx>"
  %endif
%endfunction

%% Function FcnGetAdditionalCanDimSizeDWForCanInp ==============================
%% Abstract:
%%   Add canonical dimsize dwork for canonical input to the argument list.
%%   This is called by FcnGetAdditionalArgs
%%
%function FcnGetAdditionalCanDimSizeDWForCanInp(sysFcn, sysIdx, ...
  accessSysIdx, callSiteIdx, idx, comma, args, skipCanDWork) void
  
  %if SLibGetCanIOIsVarDims(CanonicalInputArgDef[idx])
    %assign cTID = System[sysIdx].CurrentTID
    %assign isRG = SLibSystemFcnRateGrouping(System[sysIdx], sysFcn)
    %assign candIdx = SLibGetCanDimSizeDWIdxForArg(CanonicalInputArgDef[idx])
    %if !skipCanDWork[candIdx] && ...
      SysFcnArgNeeded(sysFcn, CanonicalDWorkArgDef[candIdx], cTID, isRG)
      %%
      %% We need to be able to access data in the system that
      %% is writing out this function-call (cs[0].  Previously this was
      %% %with System[accessSysIdx], but the HStructDeclSystem for
      %% accessSysIdx and cs[0] is always the same.
      %%
      %assign cs = System[sysIdx].CallSites[callSiteIdx]      
      %assert System[cs[0]].HStructDeclSystemIdx == ...
        System[accessSysIdx].HStructDeclSystemIdx
      %with System[cs[0]]
        %assign ssBlk = System[cs[2]].Block[cs[3]]
        %with ssBlk %% subsystem block
          %assign skipThisArg = 0
          %assign ci = System[sysIdx].Interface.CanonicalInputArgDef[idx]
          %if IDNUM(ci.SignalSrc[0])[0] == "F"
            %assign skipThisArg = 1
          %endif	
          %if IDNUM(ci.SignalSrc[0])[0] == "L"
            %if (sysFcn != "Output" && sysFcn!= "Update" &&...
              sysFcn!= "RootUpdate" && sysFcn!= "OutputUpdate")
              %assign skipThisArg = 1
            %endif
          %endif
          %if !skipThisArg
            %%
            %% genModelRef
            %%
            %if IsModelReferenceTarget() && accessSysIdx == NumSystems-1
              %assign args = args + comma + ...
                FcnGetModelRefDWork("In", idx, candIdx)
            %else
              %assign          ci = CallSiteInfo.CanonicalInputArg[idx]
              %assign       idNum = IDNUM(ci.SignalSrc[0])
              %assign   interface = System[System[cs[0]].HStructDeclSystemIdx].Interface
              %assign canInputArg = interface.CanonicalInputArgDef[idNum[1]]
              %assign args = args + comma + LibGetRecordIdentifier(interface.CanonicalDWorkArgDef[candIdx])
              %<SLibAccessArgHelper(interface.CanonicalDWorkArgDef[candIdx],"",...
                System[accessSysIdx].CurrentTID)>
            %endif
            %assign comma = ", "
          %endif
        %endwith %% subsystem block
      %endwith %% System[sysIdx]
    %endif
  %endif
  
  %return ["%<comma>", "%<args>"]  
%endfunction %% end FcnGetAdditionalCanDimSizeDWForCanInp


%% Function FcnGetAdditionalCanDimSizeDWForCanOut ==============================
%% Abstract:
%%   Add canonical dimsize dwork for canonical output to the argument list.
%%   This is called by FcnGetAdditionalArgs
%%
%function FcnGetAdditionalCanDimSizeDWForCanOut(sysFcn, sysIdx, ...
  accessSysIdx, callSiteIdx, idx, comma, args, skipCanDWork) void
  
  %if SLibGetCanIOIsVarDims(CanonicalOutputArgDef[idx])
    %assign cTID = System[sysIdx].CurrentTID
    %assign isRG = SLibSystemFcnRateGrouping(System[sysIdx], sysFcn)
    %assign candIdx = SLibGetCanDimSizeDWIdxForArg(CanonicalOutputArgDef[idx])
    %if !skipCanDWork[candIdx] && ...
      SysFcnArgNeeded(sysFcn, CanonicalDWorkArgDef[candIdx], cTID, isRG)
      %%
      %% We need to be able to access data in the system that
      %% is writing out this function-call (cs[0].  Previously this was
      %% %with System[accessSysIdx], but the HStructDeclSystem for
      %% accessSysIdx and cs[0] is always the same.
      %%
      %assign cs = System[sysIdx].CallSites[callSiteIdx]    
      %assert System[cs[0]].HStructDeclSystemIdx == ...
        System[accessSysIdx].HStructDeclSystemIdx
      %with System[cs[0]]
        %assign ssBlk = System[cs[2]].Block[cs[3]]
        %with ssBlk %% subsystem block
          %%
          %% getModelRef
          %%
          %if IsModelReferenceTarget() && accessSysIdx == NumSystems-1
            %assign args = args + comma + ...
              FcnGetModelRefDWork("Out", idx, candIdx)
          %else
            %assign interface = System[System[cs[0]].HStructDeclSystemIdx].Interface
            %assign idNum = IDNUM(CallSiteInfo.CanonicalDWorkArg[candIdx].SignalSrc)
            %assert(ISEQUAL(idNum[0], "dp"))
            %assign cdIdx = idNum[1]
            %assign args = args + comma + LibGetRecordIdentifier(interface.CanonicalDWorkArgDef[cdIdx])
            %<SLibAccessArgHelper(interface.CanonicalDWorkArgDef[cdIdx],"",...
              System[accessSysIdx].CurrentTID)>
          %endif
          %assign comma = ", "
        %endwith
      %endwith
    %endif
  %endif
  
  %return ["%<comma>", "%<args>"]
%endfunction %% end FcnGetAdditionalCanDimSizeDWForCanOut


%% Function SLibDumpSfcnInpDimsMode ==========================================
%% Abstract:
%%   Set dimensions model of model reference s-function block input
%%
%function SLibDumpSfcnInpDimsMode(idx)
  %if AllowVarDimsSig
    %if SLibGetExternalIOIsVarDims(ExternalInput[idx]) && ...
       (ISFIELD(CGTypes.CGType[ExternalInput[idx].CGTypeIdx], "Constructor") && ...
       ISEQUAL(CGTypes.CGType[ExternalInput[idx].CGTypeIdx].Constructor, "struct"))==TLC_FALSE
        %% Function SLibGetExternalIOIsVarDims only checks if the record
        %% contains canonical dimsize dwork index. For bus signal with vardims
        %% element(s), the dimensions mode of the signal should be fixed rather
        %% than variable.
        %return "ssSetInputPortDimensionsMode(S, %<idx>, VARIABLE_DIMS_MODE);"
    %else
      %return "ssSetInputPortDimensionsMode(S, %<idx>, FIXED_DIMS_MODE);"
    %endif
  %endif
  
  %return ""
%endfunction %% end SLibDumpSfcnInpDimsMode


%% Function SLibDumpSfcnOutDimsMode ==========================================
%% Abstract:
%%   Set dimensions model of model reference s-function block output
%%
%function SLibDumpSfcnOutDimsMode(idx)
  %if AllowVarDimsSig
    %if SLibGetExternalIOIsVarDims(ExternalOutput[idx]) && ...
        (ISFIELD(CGTypes.CGType[ExternalOutput[idx].CGTypeIdx], "Constructor") && ...
        ISEQUAL(CGTypes.CGType[ExternalOutput[idx].CGTypeIdx].Constructor, "struct"))==TLC_FALSE
        %% Function SLibGetExternalIOIsVarDims only checks if the record
        %% contains canonical dimsize dwork index. For bus signal with vardims
        %% element(s), the dimensions mode of the signal should be fixed rather
        %% than variable.
      %return "ssSetOutputPortDimensionsMode(S, %<idx>, VARIABLE_DIMS_MODE);"
    %else
      %return "ssSetOutputPortDimensionsMode(S, %<idx>, FIXED_DIMS_MODE);"
    %endif
  %endif
  
  %return ""
%endfunction %% end SLibDumpSfcnOutDimsMode

%function SLibModelHasVarDimsInput()
  %assign hasVarDimsInp = TLC_FALSE
  %with ExternalInputs
  %foreach idx = NumExternalInputs
    %if SLibGetExternalIOIsVarDims(ExternalInput[idx])
      %assign hasVarDimsInp = TLC_TRUE
      %break
    %endif
  %endforeach
  %endwith
  
  %return hasVarDimsInp
%endfunction

%function SLibModelHasVarDimsOutput()
  %assign hasVarDimsOut = TLC_FALSE
  %with ExternalOutputs
  %foreach idx = NumExternalOutputs
    %if SLibGetExternalIOIsVarDims(ExternalOutput[idx])
      %assign hasVarDimsOut = TLC_TRUE
      %break
    %endif
  %endforeach
  %endwith
  
  %return hasVarDimsOut
%endfunction

%function SLibModelOutputSizeDependOnlyInputSize()
  %return SLibModelHasVarDimsInput() && ...
    ISFIELD(::CompiledModel, "SignalSizeComputeType") && ...
    ISEQUAL(::CompiledModel.SignalSizeComputeType, "FromInputSize")
%endfunction
 
%function SLibDumpOutputSizeComputeType()
  %if AllowVarDimsSig
    %if SLibModelOutputSizeDependOnlyInputSize()
      %return "ssSetSignalSizesComputeType(S, SS_VARIABLE_SIZE_FROM_INPUT_SIZE);"
    %else
      %return "ssSetSignalSizesComputeType(S, SS_VARIABLE_SIZE_FROM_INPUT_VALUE_AND_SIZE);"
    %endif
  %endif
  
  %return ""
%endfunction %% end SLibDumpOutputSizeComputeType

%function SLibDumpDWorkResetForSizeChange()
  %if AllowVarDimsSig && SLibModelHasVarDimsInput()
    %if ISFIELD(::CompiledModel, "DWorkResetForSizeChange") && ...
      ISEQUAL(::CompiledModel.DWorkResetForSizeChange, "No") 
      %return "ssSetModelRefRequireResetForSignalSize(S, false);"
    %else
      %return "ssSetModelRefRequireResetForSignalSize(S, true);"
    %endif
  %endif
  %return ""
%endfunction %% end SLibDumpDWorkResetForSizeChange

%function SLibDumpRegisterSetOutputSizeRuleTerms()
  %with ExternalOutputs
  %if SLibModelOutputSizeDependOnlyInputSize()
    %openfile setSizeRuleBuf
    %foreach idx = NumExternalOutputs
        %if SLibGetExternalIOIsVarDims(ExternalOutput[idx])
          {
            %assign numRulesLen = SIZE(ExternalOutput[idx].NumInputsDimsDependRules, 1)
            %assign inputsStr = "{"            
            %foreach elIdx = numRulesLen-1
              %assign inputsStr = inputsStr+"%<ExternalOutput[idx].NumInputsDimsDependRules[elIdx]>"+","
            %endforeach
            %assign inputsStr = inputsStr+"%<ExternalOutput[idx].NumInputsDimsDependRules[numRulesLen-1]>"+"}"
            
            int ninps[] = %<inputsStr>;
            
            %assign inputsLen = SIZE(ExternalOutput[idx].DimsDependRulesInputIndices, 1)
            %assign inputsStr = "{"            
            %foreach elIdx = inputsLen-1
              %assign inputsStr = inputsStr+"%<ExternalOutput[idx].DimsDependRulesInputIndices[elIdx]>"+","
            %endforeach
            %assign inputsStr = inputsStr+"%<ExternalOutput[idx].DimsDependRulesInputIndices[inputsLen-1]>"+"}"
           
            int inputs[]  = %<inputsStr>;
            
            MdlRefOutDimsInfo_T ruleInfo;
            
            ruleInfo.numRules = %<SIZE(ExternalOutput[idx].NumInputsDimsDependRules,1)>;
            ruleInfo.numInpsRule = ninps;
            ruleInfo.inpIndices = inputs;
            ruleInfo.setOutputDimsRuleFcn = mdlSetOutputDimsRuleFcn;
            
            ssRegMdlRefSetOutputDimsMethods(S, %<idx>, &ruleInfo);
          }
        %endif
      %endforeach
      %if !LibSystemFcnIsEmpty(System[GetBaseSystemIdx()], "FinalizeDims") 
        ssRegMdlRefFinalizeDimsMethod(S, mdlFinalizeDimsFcn);
      %endif
      
      %closefile setSizeRuleBuf
      %return setSizeRuleBuf
  %endif
  %endwith
  %return ""
%endfunction %% end SLibRegisterSetOutputSizeRuleTerms

%function GenerateModelRefSetDimsCall(subsys, type) void
  %assign fcnInfo = LibGetFcnInfo(subsys, type, subsys.CurrentTID)
  %if type == "SetDims"
    %return LibGenSubsystemFcnCall(["outIdx", "ruleIdx"], fcnInfo, SystemIdx, subsys.SystemIdx, 0)
  %else
    %return LibGenSubsystemFcnCall([], fcnInfo, SystemIdx, subsys.SystemIdx, 0)
  %endif
%endfunction

%function WriteModelrefSFunctionVarDimsSetDimsMethods(type) Output

  %if SLibModelOutputSizeDependOnlyInputSize()
    %assign baseSysIdx = GetBaseSystemIdx()
    %assign fcnEmpty = TLC_FALSE
    
    %if type == "SetDims" && !SLibModelHasVarDimsOutput() || ...
      type == "FinalizeDims" && LibSystemFcnIsEmpty(System[baseSysIdx], "FinalizeDims")
      %assign fcnEmpty = TLC_TRUE
    %endif

    %if !fcnEmpty
      %assign fcnReturns = "static void"
      %if type == "SetDims" 
        %assign fcnName = "mdlSetOutputDimsRuleFcn"
        %assign fcnParams = "SimStruct *S, int outIdx, int ruleIdx"
      %else
        %assert type == "FinalizeDims"
        %assign fcnName = "mdlFinalizeDimsFcn"
        %assign fcnParams = "SimStruct *S"
      %endif
      %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract ""; ...
        Category "model"; GeneratedBy "modelrefvardimsutil.tlc"; Type "FinalizeDims"}
      %<SLibDumpFunctionBanner(fcnRec)>
      %undef fcnRec
      %<fcnReturns> %<fcnName>(%<fcnParams>)

      %with System[baseSysIdx]
      {
        /* call to reusable function */
        %with Interface
          %foreach argIdx=NumCanonicalOutputArgDefs
            %if SLibGetArgIsVarDims(CanonicalOutputArgDef[argIdx])
              %assign idx = CanonicalOutputArgDef[argIdx].RootOutputIdx
              %assign co = CanonicalOutputArgDef[argIdx]
              %assign dataType = SLibGetRecordDataTypeName(co, "")
              %<dataType> *OutPort_%<argIdx> = ...
                (%<dataType> *) ...
                ssGetOutputPortSignal(S, %<idx>);
            %endif
          %endforeach
          %assign vardimsDeclInit = CommonDeclarationAndInitCanIOVarDims(TLC_FALSE, "", 0)
          %assign hasDwork = %<ModelrefBlockNeedsDwork()>
          %if hasDwork
            %assert !IsModelRefScalableBuild()
            %<tsysMdlrefDWorkType> *dw = (%<tsysMdlrefDWorkType> *) ssGetDWork(S, 0);
          %endif
        %endwith
      %endwith
      %<vardimsDeclInit[0]> \
      %<vardimsDeclInit[1]> \
      %with System[NumSystems-1]
        %assign subsys = System[NumSystems-2]
        %<GenerateModelRefSetDimsCall(subsys, type)> \
      %endwith
      %assign baseSysIdx = GetBaseSystemIdx()
      %assign cTID = System[baseSysIdx].CurrentTID
      %assign isRG = SLibSystemFcnRateGrouping(System[baseSysIdx], type)
      %<SLibGenOutportCurrentDimsWrites(type, cTID, isRG)>
    }
    %endif
  %endif
  
%endfunction


%% Function: GetInputCurrentDimensions ==============================================================
%% Abstract:
%%   Dump the code to get the current input dimensions. The function recursively
%%   calls itself for bus signal with vardims element(s) whose current size is
%%   stored in a STRUCT
%%
%function GetInputCurrentDimensions(cgTypeId, dst, inpIdx, startOffset) Output
  %assign eOffset = startOffset
  %with CGTypes
    %if ISFIELD(CGType[cgTypeId], "Constructor") && ...
        ISEQUAL(CGType[cgTypeId].Constructor, "struct")
      %% Current size is stored in a struct
      %foreach idxE = CGType[cgTypeId].Members.NumMembers
        %assign eName = CGType[cgTypeId].Members.Member[idxE].Name
        %assign eDTypeId = CGType[cgTypeId].Members.Member[idxE].CGTypeIdx
        %assign eOffset = %<GetInputCurrentDimensions(eDTypeId, dst+"."+eName, inpIdx, eOffset)>
      %endforeach
    %else
      %if ISFIELD(CGType[cgTypeId], "Constructor") && ...
          ISEQUAL(CGType[cgTypeId].Constructor, "matrix")
        %% Current size is stored in an array
        %assign eWidth = LibCGTypeWidth(cgTypeId)
        %assign dataType = CGType[CGType[cgTypeId].BaseIdx].Name
        %foreach dimIdx = eWidth
          %<dst>[%<dimIdx>] = ...
            (%<dataType>)ssGetCurrentInputPortDimensions(S, %<inpIdx>, %<eOffset>);
          %assign eOffset = eOffset + 1
        %endforeach
      %else
        %% Current size is a scalar of built-in type
        %assign dataType = CGType[cgTypeId].Name
        %<dst> = ...
          (%<dataType>)ssGetCurrentInputPortDimensions(S, %<inpIdx>, %<eOffset>);
        %assign eOffset = eOffset + 1
      %endif
    %endif
  %endwith
  
  %return %<eOffset>
%endfunction

%% Function: GetOutputCurrentDimensions ==============================================================
%% Abstract:
%%   Dump the code to get the current output dimensions. The function recursively
%%   calls itself for bus signal with vardims element(s) whose current size is
%%   stored in a STRUCT
%%
%function GetOutputCurrentDimensions(cgTypeId, dst, outIdx, startOffset) Output
  %assign eOffset = startOffset
  %with CGTypes
    %if ISFIELD(CGType[cgTypeId], "Constructor") && ...
        ISEQUAL(CGType[cgTypeId].Constructor, "struct")
      %% Current size is stored in a struct
      %foreach idxE = CGType[cgTypeId].Members.NumMembers
        %assign eName = CGType[cgTypeId].Members.Member[idxE].Name
        %assign eDTypeId = CGType[cgTypeId].Members.Member[idxE].CGTypeIdx
        %assign eOffset = %<GetOutputCurrentDimensions(eDTypeId, dst+"."+eName, outIdx, eOffset)>
      %endforeach
    %else
      %if ISFIELD(CGType[cgTypeId], "Constructor") && ...
          ISEQUAL(CGType[cgTypeId].Constructor, "matrix")
        %% Current size is stored in an array
        %assign eWidth = LibCGTypeWidth(cgTypeId)
        %assign dataType = CGType[CGType[cgTypeId].BaseIdx].Name
        %foreach dimIdx = eWidth
          %<dst>[%<dimIdx>] = ...
            (%<dataType>)ssGetCurrentOutputPortDimensions(S, %<outIdx>, %<eOffset>);
          %assign eOffset = eOffset + 1
        %endforeach
      %else
        %% Current size is a scalar of built-in type
        %assign dataType = CGType[cgTypeId].Name
        %<dst> = ...
          (%<dataType>)ssGetCurrentOutputPortDimensions(S, %<outIdx>, %<eOffset>);
        %assign eOffset = eOffset + 1
      %endif
    %endif
  %endwith
  
  %return %<eOffset>
%endfunction

%% Function CommonDeclarationAndInitCanIOVarDims ==========================================
%% Abstract:
%%   Declare the local arrays for run-time dimension information of vardims input
%%   and output. Initialize the local arrays for vardims input(s). 
%%   Note: Because the data type for run-time dimension in the generated code is 
%%   int32 and it is int in Simulink, we cannot use pointer to point to the vardims
%%   buffer in Simulink. This is different from how we handle canonical IO.
%%
%function CommonDeclarationAndInitCanIOVarDims(checkAccess, tid, isRateGrouping)

  %assign ioVarDimsDeclBuffer = ""
  %assign ioVarDimsInitBuffer = ""
  
  %if AllowVarDimsSig
    %assign inportVarDimsNamePrefix = "InVarDims_"
    %assign outportVarDimsNamePrefix = "OutVarDims_"
    %assign hasVarDimsIO = TLC_FALSE
    
    %openfile ioVarDimsDeclBuffer
    %foreach argIdx=NumCanonicalInputArgDefs
      %assign ci = CanonicalInputArgDef[argIdx]
      %if SLibGetCanIOIsVarDims(ci)
        %assign cdIdx    = SLibGetCanDimSizeDWIdxForArg(ci)
        %assign canDWork = CanonicalDWorkArgDef[cdIdx]
        %if !checkAccess || FcnArgNeeded(canDWork, tid, isRateGrouping)
          %assign inputPortInfo = ci.SignalSrc
          %assign u_str_idx     = IDNUM(inputPortInfo[0])
          %assign u_idx         = u_str_idx[1]
          %assign dwIdx         = canDWork.FirstSignalSrc
          %assign dwRec         = DWorks.DWork[dwIdx]
          %assign dataType      = SLibGetRecordDataTypeName(dwRec, "")
          %assign dwWidth       = SLibDWorkWidth(dwRec)
          %if dwWidth == 1
            %<dataType> %<inportVarDimsNamePrefix>%<argIdx>;
          %else
            %<dataType> %<inportVarDimsNamePrefix>%<argIdx>[%<dwWidth>];
          %endif
        %endif
        %assign hasVarDimsIO = TLC_TRUE
      %endif
    %endforeach
    
    %%
    %% The var-dims array should also be initialized because the reusable
    %% function does not always update the output var-dims at each call
    %foreach argIdx=NumCanonicalOutputArgDefs
      %assign co = CanonicalOutputArgDef[argIdx]
      %if SLibGetCanIOIsVarDims(co)
        %assign cdwIdx   = SLibGetCanDimSizeDWIdxForArg(co)
        %assign canDWork = CanonicalDWorkArgDef[cdwIdx]
        %if !checkAccess || FcnArgNeeded(canDWork, tid, isRateGrouping)
          %assign idx      = co.RootOutputIdx
          %assign dwIdx    = canDWork.FirstSignalSrc
          %assign dwRec    = DWorks.DWork[dwIdx]
          %assign dataType = SLibGetRecordDataTypeName(dwRec, "")
          %assign dwWidth  = SLibDWorkWidth(dwRec)
          %if dwWidth == 1
            %<dataType> %<outportVarDimsNamePrefix>%<argIdx>;
          %else
            %<dataType> %<outportVarDimsNamePrefix>%<argIdx>[%<dwWidth>];
          %endif
        %endif
        %assign hasVarDimsIO = TLC_TRUE
      %endif
    %endforeach
    
    %%
    %if hasVarDimsIO
      %openfile ioVarDimsInitBuffer
      %assign hasConstOutput = MdlRefHasConstantOutput()
      %assign asyncTID = LibAsynchronousTriggeredTID(tid)
      %if hasConstOutput && ...
        ((NumCanonicalInputArgDefs > 0) || (NumCanonicalOutputArgDefs > 0)) && ...
        (::BlockFcn == "Output" || ::BlockFcn == "OutputUpdate") && ...
        !asyncTID
        %% g738207: When executing modelref S-function's Const Output function,
        %% the current port dimensions (vardims) need not be accessed since
        %% vardims signals can never run at constant rate and do not need to
        %% be run during Const Output. tid is passed in as empty when invoked
        %% during construction of mdlOutputs.
        
      if (%<CompiledModel.GlobalScope.tTID> != CONSTANT_TID) {
      %endif
      %foreach argIdx=NumCanonicalInputArgDefs
        %assign ci = CanonicalInputArgDef[argIdx]
        %if SLibGetCanIOIsVarDims(ci)
          %assign cdwIdx   = SLibGetCanDimSizeDWIdxForArg(ci)
          %assign canDWork = CanonicalDWorkArgDef[cdwIdx]
          %if !checkAccess || FcnArgNeeded(canDWork, tid, isRateGrouping)
            %assign inputPortInfo = ci.SignalSrc
            %assign u_str_idx     = IDNUM(inputPortInfo[0])
            %assign u_idx         = u_str_idx[1]
            %assign dwIdx         = canDWork.FirstSignalSrc
            %assign dwRec         = DWorks.DWork[dwIdx]
            %assign dataType      = SLibGetRecordDataTypeName(dwRec, "")
            %assign dwWidth  = SLibDWorkWidth(dwRec)
            /* Get current dimensions of input port %<u_idx> */
            %assign sizeDWName = "%<inportVarDimsNamePrefix>%<argIdx>"
            %assign eOffset = %<GetInputCurrentDimensions(DWorks.DWork[dwIdx].CGTypeIdx, sizeDWName, u_idx, 0)>
          %endif
        %endif
      %endforeach
      %foreach argIdx=NumCanonicalOutputArgDefs
        %assign co = CanonicalOutputArgDef[argIdx]
        %if SLibGetCanIOIsVarDims(co)
          %assign cdwIdx   = SLibGetCanDimSizeDWIdxForArg(co)
          %assign canDWork = CanonicalDWorkArgDef[cdwIdx]
          %if !checkAccess || FcnArgNeeded(canDWork, tid, isRateGrouping)
            %assign idx      = co.RootOutputIdx
            %assign dwIdx    = canDWork.FirstSignalSrc
            %assign dwRec    = DWorks.DWork[dwIdx]
            %assign dataType = SLibGetRecordDataTypeName(dwRec, "")
            %assign dwWidth  = SLibDWorkWidth(dwRec)
            /* Get current dimensions of output port %<idx> */
            %assign sizeDWName = "%<outportVarDimsNamePrefix>%<argIdx>"
            %assign eOffset = %<GetOutputCurrentDimensions(DWorks.DWork[dwIdx].CGTypeIdx, sizeDWName, idx, 0)>
           %endif
        %endif
      %endforeach
      %if hasConstOutput && ...
        ((NumCanonicalInputArgDefs > 0) || (NumCanonicalOutputArgDefs > 0)) && ...
        (::BlockFcn == "Output" || ::BlockFcn == "OutputUpdate") && ...
        !asyncTID
        %% end if(tid != CONSTANT_TID)
      }
      %endif
      %closefile ioVarDimsInitBuffer
    %endif
    %closefile  ioVarDimsDeclBuffer
  %endif
  
  %return ["%<ioVarDimsDeclBuffer>", "%<ioVarDimsInitBuffer>"]
  
%endfunction %% end CommonDeclarationAndInitCanIOVarDims


%% Function GetBlockInputCanDimSizeDWInterface ================================
%% Abstract:
%%   Get the canonical dimsize dwork information for each input
%%   for the block interface
%%
%function GetBlockInputCanDimSizeDWInterface(sysIdx, sysFcn, tid)
  %assign  inDWStr = ""
  
  %if AllowVarDimsSig
    %assign thisSystem = System[sysIdx]
    %assign currentTID     = tid
    %assign isRateGrouping = SLibSystemFcnRateGrouping(thisSystem, sysFcn)
    
    %assign  comma = ""
    %assign  inCounter = 0
    %assign  numInputs = ExternalInputs.NumExternalInputs

    %foreach argIdx = NumCanonicalInputArgDefs
      %assign idx = SLibGetModelRefRootInputIdx(sysIdx, argIdx)
      
      %% fill 0 for unused inputs
      %assign numZeroToAdd = idx - inCounter
      %if  numZeroToAdd > 0
        %assign inDWStr = AppendZeroToString(inDWStr, comma, numZeroToAdd)
        %assign comma   = ", "
      %endif
      %assign inCounter = idx
      
      %if SLibGetCanIOIsVarDims(CanonicalInputArgDef[argIdx]) && ...
        FcnArgNeeded(CanonicalDWorkArgDef[SLibGetCanDimSizeDWIdxForArg(CanonicalInputArgDef[argIdx])], ...
        currentTID,isRateGrouping)
        %assign inDWStr = "%<inDWStr>%<comma>1"
      %else
        %assign inDWStr = "%<inDWStr>%<comma>0"
      %endif
      
      %assign comma = ", "
      %assign inCounter = inCounter + 1
    %endforeach
    
    %assign numZeroToAdd = numInputs - inCounter
    %if  numZeroToAdd > 0
      %assign inDWStr = AppendZeroToString(inDWStr, comma, numZeroToAdd)
      %assign comma   = ", "
    %endif
    %assign inCounter = numInputs
  %endif
  
  %return "%<inDWStr>"
  
%endfunction %% end GetBlockInputCanDimSizeDWInterface


%% Function GetBlockOutputCanDimSizeDWInterface ================================
%% Abstract:
%%   Get the canonical dimsize dwork information for each output 
%%   for the block interface
%%
%function GetBlockOutputCanDimSizeDWInterface(sysIdx, sysFcn, tid)
  %assign  outDWStr = ""
  
  %if AllowVarDimsSig
    %assign thisSystem = System[sysIdx]
    %assign currentTID     = tid
    %assign isRateGrouping = SLibSystemFcnRateGrouping(thisSystem, sysFcn)
    
    %assign comma  = ""
    %assign outCounter = 0
    %assign  numOutputs = ExternalOutputs.NumExternalOutputs

    %foreach argIdx = NumCanonicalOutputArgDefs
      %assign idx = SLibGetModelRefRootOutputIdx(sysIdx, argIdx)
      
      %% fill 0 for unused outputs
      %assign numZeroToAdd = idx - outCounter
      %if  numZeroToAdd > 0
        %assign outDWStr = AppendZeroToString(outDWStr, comma, numZeroToAdd)
        %assign comma    = ", "
      %endif
      %assign outCounter = idx
      
      %if SLibGetCanIOIsVarDims(CanonicalOutputArgDef[argIdx]) && ...
        FcnArgNeeded(CanonicalDWorkArgDef[SLibGetCanDimSizeDWIdxForArg(CanonicalOutputArgDef[argIdx])], ...
        currentTID,isRateGrouping)
        %assign outDWStr = "%<outDWStr>%<comma>1"
      %else
        %assign outDWStr = "%<outDWStr>%<comma>0"
      %endif
      
      %assign comma = ", "
      %assign outCounter = outCounter + 1
    %endforeach
    
    %assign numZeroToAdd = numOutputs - outCounter
    %if  numZeroToAdd > 0
      %assign outDWStr = AppendZeroToString(outDWStr, comma, numZeroToAdd)
      %assign comma    = ", "
    %endif
    %assign outCounter = numOutputs
  %endif

  %return "%<outDWStr>"
  
%endfunction %% end GetBlockOutputCanDimSizeDWInterface


%% Function AppendModelReferenceRegFcnInputCanDimSizeDWArgs =====================
%% Abstract:
%%   Add canonical dimsize dwork for canonical input to the argument list.
%%   This is called by SLibModelReferenceRegFcnArgs
%%
%function AppendModelReferenceRegFcnInputCanDimSizeDWArgs(idx, currentTID, ...
  isRateGrouping, recArgs, isCallSite)
  %if SLibGetCanIOIsVarDims(CanonicalInputArgDef[idx])
    %assign ci = CanonicalInputArgDef[idx]
    %assign cdwIdx   = SLibGetCanDimSizeDWIdxForArg(ci)
    %assign canDWork = CanonicalDWorkArgDef[cdwIdx]
    %if FcnArgNeeded(canDWork, currentTID, isRateGrouping)
      %assign dwIdx    = canDWork.FirstSignalSrc %% global idx
      %assign dwRec    = ::CompiledModel.DWorks.DWork[dwIdx]
      %assign dwWidth  = SLibDWorkWidth(dwRec)
      %if isCallSite
        %if dwWidth == 1
          %assign recArgs = recArgs + "&InVarDims_%<idx>"
        %else
          %assign recArgs = recArgs + "InVarDims_%<idx>"
        %endif
      %else
        %assign identi   = LibGetRecordIdentifier(canDWork)
        %assign dataType = SLibGetRecordDataTypeName(dwRec, "")
        %if dwWidth > 1
          %assign argDef   = "const " + dataType + " " + identi + "[%<dwWidth>]"
        %else
          %assign argDef   = "const " + dataType + " *" + identi
        %endif
        %assign recArgs  = recArgs  +  argDef
      %endif
    %endif
  %endif
  
  %return recArgs
%endfunction %% end AppendModelReferenceRegFcnInputCanDimSizeDWArgs


%% Function AppendModelReferenceRegFcnOutputCanDimSizeDWArgs ====================
%% Abstract:
%%   Add canonical dimsize dwork for canonical output to the argument list.
%%   This is called by SLibModelReferenceRegFcnArgs
%%
%function AppendModelReferenceRegFcnOutputCanDimSizeDWArgs(idx, currentTID, ...
  isRateGrouping, recArgs, isCallSite)
  %if SLibGetCanIOIsVarDims(CanonicalOutputArgDef[idx])
    %assign co = CanonicalOutputArgDef[idx]
    %assign cdwIdx   = SLibGetCanDimSizeDWIdxForArg(co)
    %assign canDWork = CanonicalDWorkArgDef[cdwIdx]
    %if FcnArgNeeded(canDWork, currentTID, isRateGrouping)
      %assign dwIdx    = canDWork.FirstSignalSrc %% global idx
      %assign dwRec    = ::CompiledModel.DWorks.DWork[dwIdx]
      %assign dwWidth  = SLibDWorkWidth(dwRec)
      %if isCallSite
        %if dwWidth == 1
          %assign recArgs = recArgs + "&OutVarDims_%<idx>"
        %else
          %assign recArgs = recArgs + "OutVarDims_%<idx>"
        %endif
      %else
        %assign identi   = LibGetRecordIdentifier(canDWork)
        %assign dataType = SLibGetRecordDataTypeName(dwRec, "")
        %if dwWidth > 1
          %assign argDef   = dataType + " " + identi + "[%<dwWidth>]"
        %else
          %assign argDef   = dataType + " *" + identi
        %endif
        %assign recArgs  = recArgs  +  argDef
      %endif
    %endif
  %endif
  
  %return recArgs
%endfunction %% end AppendModelReferenceRegFcnOutputCanDimSizeDWArgs

%function SLibGetDimsFromIF(block, portIdx, kind) void
  %return SLibInvokeTLCInterface(block, kind, portIdx, 0, TLC_FALSE, ...
    "", "", 0, "")
%endfunction

%% Function: SLibGetInputCanDimSizeDWForFunctionStr ============================
%% Abstract:
%%   Add canonical dimsize dwork for canonical input to the argument list.
%%   This is called by GetFunctionStr
%%
%function SLibGetInputCanDimSizeDWForFunctionStr(block, portIdx, fcnInfo, ...
  sysFcnName) void
  %assign arg = []  
  %if AllowVarDimsSig
    %assign canInDWorkInfo = fcnInfo.InDimSizeDW
    %if canInDWorkInfo[portIdx] > 0
      %<SLibGetDimsFromIF(block, portIdx, "InputDims")>
      %assign baseSystemIdx = GetBaseSystemIdx()
      %assign baseSystem = ::CompiledModel.System[baseSystemIdx]
      %assign dataPort = block.DataInputPort[portIdx]
      %assert SLibGetArgIsVarDims(dataPort)
      %if SLibGetArgUseCanDimSizeDW(dataPort)
        %assign ownerSysIdx = block.BlockIdx[1]
        %assign currentTID = ::CompiledModel.System[ownerSysIdx].CurrentTID
        %assign cdwIdx = SLibGetCanDimSizeDWIdxForArg(dataPort)
        %if sysFcnName == "RegistrationFcn"
          %if ISFIELD(baseSystem.Interface,"CanonicalDWorkArgDef")
            %assign canDWork = baseSystem.Interface.CanonicalDWorkArgDef[cdwIdx]
            %assign arg = "%<LibGetRecordIdentifier(canDWork)>"
            %<SLibAccessArgHelper(canDWork, "", currentTID)>
          %else
            %assign cdwIdx = dataPort.DimSizeDWorkMR
            %assign cross = baseSystem.CrossNoArgFcnBound
            %assign arg = ...
              "%<SLibGetDimSizeDWorkFullPathForFcnArg(cdwIdx, baseSystemIdx, cross)>"
            %<SLibAccessArgHelper(baseSystem.Interface.DWorkArgDef,"","")>
          %endif
        %else
          %assign hstructSysIdx = ...
            ::CompiledModel.System[BlockIdx[1]].HStructDeclSystemIdx
          %assign interface = ::CompiledModel.System[hstructSysIdx].Interface
          %assign canDWork  = interface.CanonicalDWorkArgDef[cdwIdx]
          %if System[BlockIdx[1]].CrossNoArgFcnBound
            %assign arg = "%<canDWork.GlobalIdentifier>"
            %<SLibAccessArgHelper(canDWork, "Global", currentTID)>
          %else
            %assign arg = "%<LibGetRecordIdentifier(canDWork)>"
          %endif
          %<SLibAccessArgHelper(canDWork, "", currentTID)>
        %endif
      %else
        %assert SLibGetArgUseSharedDimSizeDW(dataPort)
        %assign blkSysIdx = ::CompiledModel.System[BlockIdx[1]].SystemIdx
        %assign dwIdx = dataPort.DimSizeDWork
        %assign cross = ::CompiledModel.System[blkSysIdx].CrossNoArgFcnBound
        %assign arg   = ...
          "%<SLibGetDimSizeDWorkFullPathForFcnArg(dwIdx, blkSysIdx, cross)>"
        %if sysFcnName == "RegistrationFcn"
          %<SLibAccessArgHelper(baseSystem.Interface.DWorkArgDef,"","")>
        %else
          %assign hstructSysIdx = ...
            ::CompiledModel.System[BlockIdx[1]].HStructDeclSystemIdx
          %assign hstructSys = ::CompiledModel.System[hstructSysIdx]
          %assign dwArgDef = hstructSys.Interface.DWorkArgDef
          %<SLibAccessArgHelper(dwArgDef, "", hstructSys.CurrentTID)>
        %endif
      %endif
    %endif
  %endif
  %return arg
%endfunction %% end AppendInputCanDimSizeDWForFunctionStr


%% Function SLibGetOutputCanDimSizeDWForFunctionStr ============================
%% Abstract:
%%   Add canonical dimsize dwork for canonical output to the argument list.
%%   This is called by GetFunctionStr
%%
%function SLibGetOutputCanDimSizeDWForFunctionStr(block, portIdx, fcnInfo, ...
  sysFcnName) void
  %assign arg = []
  %if AllowVarDimsSig 
    %assign canOutDWorkInfo = fcnInfo.OutDimSizeDW
    %if canOutDWorkInfo[portIdx] > 0
      %<SLibGetDimsFromIF(block, portIdx, "OutputDims")>
      %assign baseSystemIdx = GetBaseSystemIdx()
      %assign baseSystem = ::CompiledModel.System[baseSystemIdx]
      %assign dataPort = block.DataOutputPort[portIdx]
      %if SLibGetArgUseCanDimSizeDW(dataPort)
        %assign cdwIdx = SLibGetCanDimSizeDWIdxForArg(dataPort)
        %if sysFcnName == "RegistrationFcn"
          %assign canDWork = baseSystem.Interface.CanonicalDWorkArgDef[cdwIdx]
        %else
          %assign blkSysIdx = System[BlockIdx[1]].HStructDeclSystemIdx
          %assign interface = System[blkSysIdx].Interface
          %assign canDWork  = interface.CanonicalDWorkArgDef[cdwIdx]
        %endif
        %assign currentTID = ::CompiledModel.System[BlockIdx[1]].CurrentTID 
        %if System[BlockIdx[1]].CrossNoArgFcnBound
          %assign arg = "%<canDWork.GlobalIdentifier>"
          %<SLibAccessArgHelper(canDWork, "Global", currentTID)>
        %else
          %assign arg = "%<LibGetRecordIdentifier(canDWork)>"
        %endif
        %<SLibAccessArgHelper(canDWork,"",currentTID)>
      %elseif SLibGetArgUseSharedDimSizeDW(dataPort)
        %assign blkSysIdx = ::CompiledModel.System[BlockIdx[1]].SystemIdx
        %assign cross = ::CompiledModel.System[blkSysIdx].CrossNoArgFcnBound
        %assign dwIdx = dataPort.DimSizeDWork
        %assign arg = ...
          "%<SLibGetDimSizeDWorkFullPathForFcnArg(dwIdx, blkSysIdx, cross)>"
        %if sysFcnName == "RegistrationFcn"
          %assign dworkArgDef = baseSystem.Interface.DWorkArgDef
          %<SLibAccessArgHelper(dworkArgDef, "", currentTID)>
        %endif
      %endif
    %endif
  %endif
  %return arg
%endfunction %% end SLibGetOutputCanDimSizeDWForFunctionStr


%% Function: SetOutputCurrentDimensions ========================================
%% Abstract:
%%   Dump the code to set the current output dimensions. The function recursively
%%   calls itself for bus signal with vardims element(s) whose current size is
%%   stored in a STRUCT
%%
%function SetOutputCurrentDimensions(cgTypeId, src, outIdx, startOffset) Output
  %assign eOffset = startOffset
  %with CGTypes
    %if ISFIELD(CGType[cgTypeId], "Constructor") && ...
        ISEQUAL(CGType[cgTypeId].Constructor, "struct")
      %% Current size is stored in a struct
      %foreach idxE = CGType[cgTypeId].Members.NumMembers
        %assign eName = CGType[cgTypeId].Members.Member[idxE].Name
        %assign eDTypeId = CGType[cgTypeId].Members.Member[idxE].CGTypeIdx
        %assign eOffset = %<SetOutputCurrentDimensions(eDTypeId, src+"."+eName, outIdx, eOffset)>
      %endforeach
    %else
      %if ISFIELD(CGType[cgTypeId], "Constructor") && ...
          ISEQUAL(CGType[cgTypeId].Constructor, "matrix")
        %% Current size is stored in an array
        %assign eWidth = LibCGTypeWidth(cgTypeId)
        %foreach dimIdx = eWidth
          ssSetCurrentOutputPortDimensions(S, %<outIdx>, %<eOffset>, (int)%<src>[%<dimIdx>]);
          %assign eOffset = eOffset + 1
        %endforeach
      %else
        %% Current size is a scalar of built-in type
        ssSetCurrentOutputPortDimensions(S, %<outIdx>, %<eOffset>, (int)%<src>);
        %assign eOffset = eOffset + 1
      %endif
    %endif
  %endwith
  
  %return %<eOffset>
%endfunction

%% Function: SLibGenOutportCurrentDimsWrites ===========================================
%% Abstract:
%%   Generates the output port current dimension write code.
%%
%function SLibGenOutportCurrentDimsWrites(sysFcn, cTID, isRG) Output
  %if AllowVarDimsSig
    %assign baseSysIdx = GetBaseSystemIdx()
    %with System[baseSysIdx]
      %with Interface
        %foreach argIdx = NumCanonicalOutputArgDefs
          %% If the canonical output is vardims and the vardims local array
          %% is passed to the model reference reusable function, set the
          %% current output dimension based on the values in the vardims 
          %% local array
          %if SLibGetCanIOIsVarDims(CanonicalOutputArgDef[argIdx])
            %assign idx     = CanonicalOutputArgDef[argIdx].RootOutputIdx
            %assign cdwIdx  = SLibGetCanDimSizeDWIdxForArg(CanonicalOutputArgDef[argIdx])
            %if SysFcnArgNeeded(sysFcn, CanonicalDWorkArgDef[cdwIdx], cTID, isRG)
              %assign dwIdx   = CanonicalDWorkArgDef[cdwIdx].FirstSignalSrc
              %assign dwRec   = DWorks.DWork[dwIdx]
              %assign dwWidth = SLibDWorkWidth(dwRec)
              /* Set current dimensions for output port %<idx> */
              %assign sizeDWName = "OutVarDims_%<argIdx>"
              %assign eOffset = %<SetOutputCurrentDimensions(DWorks.DWork[dwIdx].CGTypeIdx, sizeDWName, idx, 0)>
            %endif
          %endif
        %endforeach %% NumCanonicalOutputArgDefs
      %endwith
    %endwith
  %endif
%endfunction %% SLibGenOutportCurrentDimsWrites


%endif %% _MODELREFVARDIMSUTIL_
%% [EOF] modelrefvardimsutil.tlc
