%% ============================================================================
%% 
%%
%%
%%              ModelReference
%%                    |
%%      --- -------------------------------------------------
%%      |                         |                         |
%%   SIM(SSYes)                  Coder                     NONE
%% (Model reference sim target)   |                         |
%%                                |                         |
%%                        ---------------               ------------
%%                        |             |               |           |
%%                        SSYes (rsim)  SSNo(ert,grt)   SSYes(rsim) SSNo(ert)
%%
%%
%%
%% SS: SimStruct based target
%% SSNo is equavalent to RTModelYes
%%
%% Copyright 1994-2012 The MathWorks, Inc.
%%

%if EXISTS("_MODELREFUTIL_") == 0
%assign _MODELREFUTIL_ = 1

%% Function:IsModelReferenceTarget ============================================
%% Abstract:
%%    Return true if we are generating code for model reference target
%%
%function IsModelReferenceTarget()
  %if "NONE" != ::CompiledModel.ModelReferenceTargetType
    %return TLC_TRUE
  %else
    %return TLC_FALSE
  %endif
%endfunction

%% Function:IsModelReferenceInlineOffTarget ============================================
%% Abstract:
%%    Return true if we are generating code for model reference target with inline off
%%
%function IsModelReferenceInlineOffTarget()
  %if IsModelReferenceTarget()
    %switch InlineParameters
      %case 0
        %% Cannot happen
        %assert(TLC_TRUE)
        %return TLC_FALSE
      %case 1
        %return TLC_FALSE
      %case 2
        %assert(SupportModelReferenceInlineOff)
        %return TLC_TRUE
    %endswitch
  %else
    %return TLC_FALSE
  %endif
%endfunction


%% Function: IsModelReferenceSimTarget =========================================
%% Abstract:
%%    Return true if we are generating code for model reference Sim target
%%
%function IsModelReferenceSimTarget()
  %if "SIM" == ::CompiledModel.ModelReferenceTargetType
    %return TLC_TRUE
  %else
    %return TLC_FALSE
  %endif
%endfunction

%% Function: IsModelReferenceForASimstructBasedTarget =========================
%function IsModelReferenceForASimstructBasedTarget()
  %return ::ModelReferenceForASimstructBasedTarget
%endfunction

%% Function: IsModelReferenceNonSimstructBasedRTWTarget =========================
%% 
%%  Is this a non-simstruct based target (i.e., this is not RSIM)
%function IsModelReferenceNonSimstructBasedRTWTarget()
  %return IsModelReferenceRTWTarget() && !IsModelReferenceForASimstructBasedTarget()
%endfunction


%% Function: IsSimstructBasedTarget ===========================================
%function IsSimstructBasedTarget()
  %return ::SimstructBasedTarget
%endfunction

%% Function: IsModelReferenceRTWTarget =========================================
%% Abstract:
%%    Return true if we are generating code for model reference
%function IsModelReferenceRTWTarget()
  %if "RTW" == ::CompiledModel.ModelReferenceTargetType
    %return TLC_TRUE
  %else
    %return TLC_FALSE
  %endif
%endfunction %% IsModelReferenceRTWTarget

%% Function: IsModelRefScalableBuild ==========================================
%% Abstract:
%%    Return true if we are generating code for model reference target
%%    and the generated code is scalable (logic written into .rtw file)
%function IsModelRefScalableBuild()
  %return  IsModelReferenceTarget() && ...
    ::CompiledModel.ModelReferenceGenScalableCode
%endfunction

%% Function: IsVariableStepModelReferenceTarget ================================
%% Abstract:
%%  Returns true if the solver type is variable step and we are building
%% a model reference target.  Note that only simstruct based are allowed.
%function IsVariableStepModelReferenceTarget()
  %return IsModelReferenceForASimstructBasedTarget() && ...
    ::CompiledModel.SolverType == "VariableStep"
%endfunction

%% Function: HasModelReferenceBlocks ===========================================
%% Abstract:
%%    Return true if we are generating code for a model that contains
%%    references to other models.
%function HasModelReferenceBlocks()
  %if !ISFIELD(::CompiledModel,"ModelReferenceBlocks")
    %return TLC_FALSE
  %else
    %assign nMdlRefBlks = SIZE(::CompiledModel.ModelReferenceBlocks, 0)
    %return (nMdlRefBlks > 0)
  %endif
%endfunction

%% Function: GetRootSystemFileName ============================================
%% Abstract:
%%    Get the file name for root system.
%%
%function GetRootSystemFileName()
  %return (::CompiledModel.System[::CompiledModel.NumSystems - 1].SystemFileName)
%endfunction

%% Function: FcnIsRootSystem ==================================================
%% Abstract:
%%   return true if system is root system.
%% 
%function FcnIsRootSystem(system)
  %if system.Type == "root"
    %return TLC_TRUE
  %else
    %return TLC_FALSE
  %endif
%endfunction

%% Function: GetModelrefSFunctionName =========================================
%% Abstract:
%%    Get the name of the s-function for the model reference target
%%
%function GetModelrefSFunctionName(name)
  %assign suffix = FEVAL("rtwprivate", "modelrefutil", name, "getBinExt", ::ProtectedModelReferenceTarget)
  %return name + suffix
%endfunction


%% Function: GetBaseSystemIdx ===============================================
%% Abstract:
%%  Get base system Idx. For standalone code generation, this is root system
%%  idx. For model reference, this is the hidden model reference subsystem.
%function GetBaseSystemIdx()
   %assign baseSysIdx = IsModelReferenceTarget() ? ...
     ::CompiledModel.NumSystems - 2 : ::CompiledModel.NumSystems - 1
   %return baseSysIdx
%endfunction


%% Function:  GetNumSystemsForCodeGen =========================================
%% Abstract:
%%     Return number of system to generate code for. For model reference
%% target, we do not need to generate code for root.
%%
%function GetNumSystemsForCodeGen()
  %assign numSys = IsModelReferenceTarget() ? ...
    ::CompiledModel.NumSystems - 1 : ::CompiledModel.NumSystems
  %return numSys
%endfunction %% GetNumSystemsForCodeGen

%function GetBaseFileName()
  %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
  %assign baseName   = SLibGetSystemOutputFileBaseName(baseSystem)
  %return baseName
%endfunction %% GetBaseFileName

%% Function:  GetHideChildDefineSymbol ========================================
%% Abstract:
%%   Return a symbol/Identifier which will be used to #ifndef'd sections of 
%% code in model.h. These sections of code need not be visible to parent
%% (parent model.h). Potential sections are 
%%     - Typedef's (BlockIO, DWORK)
%%     - Extern data declaration (extern rtB;)
%%     - #include "subsys.h"
%%     - #include " child.h"
%%     - subsystem function prototypes
%%
%function GetHideChildDefineSymbol(mode) void
  %assign retStr = ""
  %if IsModelRefScalableBuild() && !GenerateClassInterface
    %if mode == "ifndef"
      %assign retStr = "#ifndef %<::CompiledModel.Name>_MDLREF_HIDE_CHILD_"
      %assign retStr = retStr + "\n"
    %elseif mode == "endif"
      %assign retStr = "#endif /*%<::CompiledModel.Name>_MDLREF_HIDE_CHILD_*/"
      %assign retStr = retStr + "\n"
    %elseif mode == "define"
      %assign retStr = "%<::CompiledModel.Name>_MDLREF_HIDE_CHILD_" 
    %else
      %return ""
    %endif
  %endif
  %return retStr
%endfunction %% GetBaseFileName

%% Function: GetBaseFile ======================================================
%% Abstract:
%%    When generating code for model reference, this return the file
%%    associated with the top level subsystem. Otherwise, it return
%%    model file.
%function GetBaseFile(type)
  %assert(type == "SystemHeader" || type == "SystemBody")
  %assign baseName  = GetBaseFileName()
  %assign baseFile = SLibAddModelFile(type,"Simulink", baseName)
  %return baseFile
%endfunction %% GetBaseFile


%% Function: IsModelReferenceBaseSys ==========================================
%% Abstract:
%%    Return true if we are generating code for model reference target
%%    and the system is the hidden root system
%function IsModelReferenceBaseSys(ss)
  %return  IsModelReferenceTarget() && ss.SystemIdx == NumSystems-2
%endfunction

%% Function: LoadModelReferenceBlocksInterface ================================
%% Abstract:
%%      Read model reference interfaces from mat file and cache them in
%%      CompiledModel.ModelReferenceInterfaces
%%
%function LoadModelReferenceBlocksInterface() void
  %<LibAddToCompiledModel("ModelBlocksHaveNonInlinedSfcns", 0)>
  
  %assign zeroVec = CreateZeroVector(NumSampleTimes)
  %<LibAddToCompiledModel("ModelBlocksReqClockTicks", zeroVec)>
  %<LibAddToCompiledModel("ModelBlocksReqLongClockTicks", zeroVec)>
  %<LibAddToCompiledModel("ModelBlocksUseStopReq", 0)>
  %<LibAddToCompiledModel("ModelBlocksUseBlkStateChange", 0)>
  %<LibAddToCompiledModel("ModelBlockNeedsTriggerTID", 0)>
  
  %assign mdlsReqLongClockTicks = CreateZeroVector(NumSynchronousSampleTimes)
  %assign mdlsActRateInteraction = FEVAL("zeros", ...
    NumSynchronousSampleTimes, NumSynchronousSampleTimes)

  %assign hasMdlBlks = (ISFIELD(::CompiledModel,"ModelReferenceBlocks") && ...
    SIZE(::CompiledModel.ModelReferenceBlocks,0) > 0)
    
  %if !hasMdlBlks
    %return
  %endif

  %assign mdlRefBlks = CompiledModel.ModelReferenceBlocks
  %assign numMdlRefs = SIZE(mdlRefBlks,0)
  %with ::CompiledModel
    %assign buildStartDir = FEVAL("rtwprivate","rtwattic","getStartDir")
    %addtorecord ::CompiledModel ModelReferenceInterfaces {}
    
    %if GenerateClassInterface
      %assign mdlRefInstanceVariables = FEVAL("rtwprivate","getMdlRefInstanceVariableNames4CPP", ::CompiledModel.Name)
      %if !ISEMPTY(mdlRefInstanceVariables)
        %createrecord mdlRefInstRec {}
      %endif
    %endif
     
    %foreach rowIdx = numMdlRefs
      %assign mdlRefInfo = mdlRefBlks[rowIdx]
      %assign mSysIdx    = mdlRefInfo[0]
      %assign bIdx       = mdlRefInfo[1]
      %assign mdlrefBlk  = System[mSysIdx].Block[bIdx]
      %with mdlrefBlk
	%assign mdlName = ParamSettings.ReferencedModelName
        
        %if GenerateClassInterface && !ISEMPTY(mdlRefInstanceVariables)
          %assign mInstVarIdx = rowIdx
          %if mdlRefInstanceVariables.NumVariables > 1
            %foreach mdlInstVarIdx = mdlRefInstanceVariables.NumVariables
              %if mdlRefInstanceVariables.Flags[mdlInstVarIdx]==0 && ...
                mdlRefInstanceVariables.MdlNames[mdlInstVarIdx].Name == mdlName
                %assign mInstVarIdx = mdlInstVarIdx
                %assign mdlRefInstanceVariables.Flags[mdlInstVarIdx]=1
                %break
              %endif
            %endforeach
          %endif
          %assign fieldName = "MdlRefInstanceVar%<mInstVarIdx>"
          %addtorecord mdlRefInstRec %<fieldName> ...
            mdlRefInstanceVariables.Variables[mInstVarIdx].Variable              
        %endif

	%if !EXISTS(ModelReferenceInterfaces.%<mdlName>Interface)
	  %assign blkInterface = LoadModelrefInterfaceInMatInfoFile(...
	    mdlName, buildStartDir)

	  %addtorecord ::CompiledModel.ModelReferenceInterfaces \
	  %<mdlName>Interface blkInterface

	  %<PropModelBlocksInfoToCompiledModel(blkInterface, mdlrefBlk)>
	%endif
      %endwith
    %endforeach
    
    %if GenerateClassInterface
      %if EXISTS(mdlRefInstRec) && !ISEMPTY(mdlRefInstRec)
        %<LibAddToCompiledModel("CPPEncapsulationMdlRefRecord", mdlRefInstRec)>
      %endif
    %endif
  %endwith
%endfunction
  
%% Function: PropModelBlocksInfoToCompiledModel ================================
%% Abstract:
%%	    
%function PropModelBlocksInfoToCompiledModel(blkInterface, mdlrefBlock) void
  %% Non-inlined s-functions
  %if blkInterface.HasNonInlinedSfcn
    %assign ::CompiledModel.ModelBlocksHaveNonInlinedSfcns = 1
  %endif
	    
  %% FirstInitCond
  %if blkInterface.FirstInitConditionReq
    %assign ::CompiledModel.IsFirstInitCondMacroUsed = 1
  %endif
  
  %% If any of the submodels use a triggerTID, then this model
  %% will also need it if it is aperiodic fcn-call model.
  %if blkInterface.FcnCallMdlRefTriggerTIDIsReq && ...
    RTMMdlRefTriggerTIDMayBeRequired()
    %assign ::CompiledModel.ModelBlockNeedsTriggerTID = 1
  %endif
  
  %% None of these fields are needed for simstruct based targets
  %if SLibIsERTCodeFormat()
    %if IsModelReferenceTarget()
      %with InheritedFunctionCallSystems
        %% Add names of function-call systems that have reset states set to
        %% inherited until there are 10 systems, if we hit an error, 
        %% we limit the number of systems we show in the error.
        %assign numSystemsInBlk = SIZE(blkInterface.InheritedFcnCallSystems,1)
        %assign numSystemsInModel = NumInheritedFunctionCallSystems
      
        %if numSystemsInModel < 10
          %assign numSlotsLeft = 10 - numSystemsInModel
          %assign numSystemsToAdd = (numSlotsLeft < numSystemsInBlk) ? ...
            numSlotsLeft : numSystemsInBlk
          
          %foreach idx = numSystemsToAdd
            %addtorecord ::CompiledModel.InheritedFunctionCallSystems ...
              InheritedFunctionCallSystem %<blkInterface.InheritedFcnCallSystems[idx]>
          %endforeach
          
          %assign ::CompiledModel.InheritedFunctionCallSystems.NumInheritedFunctionCallSystems = ...
            numSystemsInModel + numSystemsToAdd
        %endif
      %endwith
    %endif
    
    %% Rate interaction
    %if blkInterface.RequireMultiRateSampleHits
      %% If a submodel needs specialSampleHits, then the parent also
      %% must be multi-tasking.  The single tasking timing engine
      %% does not keep track of specialSampleHits for non-simstruct
      %% based code.  The internal simulink timing engine does keep
      %% track of specialSampleHits.
      %if SLibSingleTasking() && !IsModelReferenceForASimstructBasedTarget()
        %assign modelName = ::CompiledModel.Name
        %assign refName   = blkInterface.Name 
        %assign msg = FEVAL("DAStudio.message", ...
          "Simulink:modelReference:multiTaskingInSingleTasking", ...
          "%<modelName>", "%<refName>")
        %<LibReportError("%<msg>")>
      %endif
      
      %assign ::CompiledModel.RequireMultiRateSampleHits = 1
    %endif

    %% For simstruct-based targets, we always use the ss macro
    %if blkInterface.StopReqAccessed
      %assign ::CompiledModel.ModelBlocksUseStopReq = 1
    %endif
    
    %if blkInterface.BlkStateChangeAccessed
      %assign ::CompiledModel.ModelBlocksUseBlkStateChange = 1
    %endif
    
    
    %% TID ticks
    %assign origBlockFcn = ::BlockFcn
    %foreach i = NumSampleTimes
      %assign iChildTid = MapParentTID2ChildTID(mdlrefBlock, i)
      
      %if iChildTid >= 0 %% If the block has this tid
        %if blkInterface.ClockTicksReq[iChildTid]
          %assign ::CompiledModel.ModelBlocksReqClockTicks[i] = 1
          
          %% For async sample times, assume that Outputs is
          %% accessing this.  Do Enable/Disable need to be added?
          %if LibAsynchronousTriggeredTID(i) 
            %assign ::BlockFcn = "OutputUpdate"
          %endif
          %<SLibSetNeedAbsoluteTime(i)>
          %if LibAsynchronousTriggeredTID(i) 
            %assign ::BlockFcn = origBlockFcn
          %endif
        %endif
        %if blkInterface.LongClockTicksReq[iChildTid]
          %assign ::CompiledModel.ModelBlocksReqLongClockTicks[i] = 1
          %assert SLibNeedAbsoluteTimeForTID(i)
        %endif
        
        %if blkInterface.NeedFloatTime[iChildTid]
          %<SLibSetNeedFloatAbsoluteTime(i)>
        %endif
      %endif
    %endforeach
    %foreach i = NumSynchronousSampleTimes
      %assign iChildTid = MapParentTID2ChildTID(mdlrefBlock, i)
      
      %if iChildTid >= 0 %% If the block has this tid
        %if blkInterface.RequireMultiRateSampleHits 
          %foreach j = NumSynchronousSampleTimes
            %assign jChildTid = MapParentTID2ChildTID(mdlrefBlock, j)
            %if jChildTid >= 0 	 %% If the block has this tid   
              %if blkInterface.ActualRateInteraction[iChildTid][jChildTid]
                %assign ::CompiledModel.MatrixOfRequireRateInteraction[i][j] = 1
                %assign ::CompiledModel.RequireRateInteraction = TLC_TRUE
              %endif
            %endif
          %endforeach
        %endif
      %endif
    %endforeach
  %endif
%endfunction %%PropModelBlocksInfoToCompiledModel


%% Function: GetBuildStartDir =================================================
%% Abstract:
%%     Return dir where the user initiated the build, i.e., pwd before
%%     code generation.
%%
%function GetBuildStartDir() Output
  %assign buildStartDir = FEVAL("rtwprivate","rtwattic","getStartDir")
  %return buildStartDir
%endfunction

%% Function: CacheModelrefInterfaceInMatInfoFile  =============================
%% Abstract:
%%      Store interface of model reference blocks in .mat file.
%%      This function should go to model ref lib file. However, since
%%      other related functions are in this file, we keep it here.
%function CacheModelrefInterfaceInMatInfoFile(mdlref, type, interface) void
  %assert (IsModelReferenceTarget())
  %assign targetType = IsModelReferenceSimTarget() ? "SIM" : "RTW"
  %assign rtwinfomat = FEVAL("rtwprivate", "rtwinfomatman", type,...
    "binfo", "%<mdlref>", ...
    "%<targetType>", interface)
%endfunction

%% Function: LoadModelrefInterfaceInMatInfoFile ===============================
%% Abstract:
%%    Load and return model reference interface info from mat file.
%%
%function LoadModelrefInterfaceInMatInfoFile(mdlref, buildStartDir)
  %% Note: Use
  %%    "SIM" : For model reference sim target or accelerator.
  %%            Note that we run model reference blocks in Simulink. However,
  %%            we may use some of the interface field in the
  %%            blocks/modelref.tlc
  %%     "RTW": Standalone target or model reference coder target
  %if IsModelReferenceSimTarget() || Accelerator
    %assign targetType = "SIM"
  %else
    %assign targetType = "RTW"
  %endif
  %assign modelInterface = FEVAL("rtwprivate", "rtwinfomatman", ...
    "loadInterface", "binfo", mdlref, targetType)
  %return modelInterface
%endfunction

%% Function: LoadRTWInfoMatFileforTLC ===============================
%% Abstract:
%%    Load rtwinfomat into a TLC structure and cached it into ::CompiledModel.
%%
%function LoadRTWInfoMatFileforTLC() void
  %assign FILESEP       = FEVAL("filesep")
  %assign targetType    = ::CompiledModel.ModelReferenceTargetType
  
  %assign infoStruct    = FEVAL("rtwprivate", "rtwinfomatman", "loadforTLC", "binfo", LibGetModelName(), targetType)
  %assign rootFolder    = FEVAL("rtwprivate", "rtwinfomatman", "getAnchorDir", "binfo", LibGetModelName(), targetType)
  
  %addtorecord ::CompiledModel RTWInfoMatFile infoStruct
  %% convert to absolute path
  %assign ::CompiledModel.RTWInfoMatFile.sharedSourcesDir = FEVAL("fullfile", rootFolder, ::CompiledModel.RTWInfoMatFile.sharedSourcesDir, FILESEP)
%endfunction

%% Function: GetModelrefInterface ==============================================
%% Abstract:
%%       Given a model reference block, return block interface which is cached
%%       in CompiledModel
%%
%function GetModelrefInterface(blk)
  %% it must be model referefce
  %assert (TYPE(blk.Type) == "Identifier" && blk.Type == "ModelReference")
  %assign mdlName = blk.ParamSettings.ReferencedModelName
  %assert(EXISTS(::CompiledModel.ModelReferenceInterfaces.%<mdlName>Interface))
  %return ::CompiledModel.ModelReferenceInterfaces.%<mdlName>Interface
%endfunction


%function IsBaseSystem(system)
  %assign isBase = 0
  %if IsModelReferenceTarget()
    %assign isBase = IsModelReferenceBaseSys(system)
  %elseif system.Type == "root"
    %assign isBase = 1
  %endif
  %return isBase
%endfunction


%function GetDataCFile()
 %assign  dataFile = SLibAddModelFile("SystemBody","Simulink", "%<Name>_data")
 %return dataFile
%endfunction

%function GetPrivateHFile()
  %assign privFile = SLibAddModelFile("SystemHeader","Simulink", "%<Name>_private")
  %return privFile
%endfunction

%% Function:  IsMultiInsatnceERTOrModelReference ==============================
%% Abstract:
%%    Return true if it is Multi instance ERT or Model reference
%%
%function IsMultiInsatnceERTOrModelReference()
  %return MultiInstanceERTCode || IsModelReferenceTarget()
%endfunction

%% Function: GetModelRefRegistrationFcnName ===================================
%% Abstract:
%%    Returns the name of the model reference registration function, the 
%% form is %<BaseSubsysName>_initialize
%%
%function GetModelRefRegistrationFcnName()
  %assign initFcnName = System[GetBaseSystemIdx()].HiddenRootInitializeFcn
  %return "%<initFcnName>"
%endfunction


%function CreateZeroVector(numElm)
  %assign vec = []
  %foreach idx = numElm
    %assign vec = vec + 0
  %endforeach
  %return vec
%endfunction


%% Function: MapParentTID2ChildTID ==========================================
%% Abstract:
%%   Map parents TID to child system TID. Return -1 is not match tid is found.  
%function MapParentTID2ChildTID(block, tid)
  %assign localTid = -1 %% 
  %with block
    %if TYPE(TID) != "Identifier" %% Ignore constant/triggered sample time
      %if TYPE(TID) == "Number"
	%if ISEQUAL(TID, tid)
	  %assign localTid = 0
	%endif
      %elseif TYPE(TID) == "Vector"
	%foreach tidIdx = SIZE(TID,1)
	  %% Note: Constant sample times are (-2)
	  %if ISEQUAL(TID[tidIdx], tid)
	    %assign localTid = tidIdx
	    %break
	  %endif
	%endforeach
      %else
	%assert(0)
      %endif
    %endif
  %endwith
  %return localTid
%endfunction

%% Function: FcnMapTIDForRateGrouping ==========================================
%% Abstract:
%%   We need to remove any TID's for the model reference block that are
%% not needed when we do rate grouping.  This includes constant TID's and
%% TID1 when Tid01Eq is true for the submodel.
%function FcnMapTIDForRateGrouping(block, tid) void
  %assign output_tid = tid
  %if (TYPE(tid) == "Vector") 
    %% Remove the constant tid from the vector
    %assign output_tid = []
    %foreach i = SIZE(tid,1)
      %if tid[i] != -2
        %assign output_tid = output_tid + tid[i]
      %endif
    %endforeach

    %% If the size of output_tid is 1, make it a scalar
    %if TYPE(output_tid) == "Vector" && SIZE(output_tid,1) == 1
      %assign output_tid = output_tid[0]
    %endif
  
    %% If the modelref block has only two TID's and Tid01Eq,
    %% we can treat the block as single rate.  Blocks that
    %% have more than 2 tid's will be taken care of later.
    %assign intf = GetModelrefInterface(block)
    %if (SIZE(output_tid, 1) == 2) && intf.Tid01Eq
      %assign output_tid = 0
    %endif
  %endif
  %return output_tid
%endfunction %% FcnMapTIDForRateGrouping

%% Function: GetNumberOfNoncontSignalsFeedingDerivPorts ========================
%% Abstract:
%%  Get the total number of noncontinuous signals feeding deriv ports 
%% in a model.
%function GetNumberOfNoncontSignalsFeedingDerivPorts() void
  %if ISFIELD(::CompiledModel,"SolverResetInfo")
    %return ::CompiledModel.SolverResetInfo.NumNonContDerivSignals
  %else
    %return 0
  %endif
%endfunction %% GetNumberOfNoncontSignalsFeedingDerivPorst

%% Function: HasNonContSigFeedingOutport =======================================
%% Abstract:
%%  Returns true if any of the outports have a discontinuity (a continuous
%%  sample time, but are fed by a discrete block).  This only works for
%%  modelref targets.
%function HasNonContSigFeedingOutport() void
  %assert (IsModelReferenceTarget())  
  %assign hasNonContOutput = TLC_FALSE
  %if IsModelReferenceForASimstructBasedTarget()
    %foreach idx = ::CompiledModel.ExternalOutputs.NumExternalOutputs
      %if ::CompiledModel.ExternalOutputs.ExternalOutput[idx].NonContinuous
        %assign hasNonContOutput = TLC_TRUE
        %break
      %endif
    %endforeach
  %endif
  %return hasNonContOutput
%endfunction %% HasNonContSigFeedingOutport

%% Function: GetNonContOutputPorts =============================================
%% Abstract:
%%  Return an array which has length of the number of root outports.  Each
%% element is the number of noncontinuous signals feeding that port.
%function GetNonContOutputPorts() void
  %assert (IsModelReferenceTarget())  
  %assign nonContPorts = []
  %if IsModelReferenceForASimstructBasedTarget()
    %foreach idx = ::CompiledModel.ExternalOutputs.NumExternalOutputs
      %if ::CompiledModel.ExternalOutputs.ExternalOutput[idx].NonContinuous
        %assign numNonCont = ...
          ::CompiledModel.SolverResetInfo.NonContOutputSignals.NonContOutput[idx].NumNonContOutputSignals
        %assign nonContPorts = nonContPorts + %<numNonCont>
      %else
        %assign nonContPorts = nonContPorts + 0
      %endif
    %endforeach
  %endif
  %return nonContPorts
%endfunction

%% Function: SLibGetGlobalTimingBridge ========================================
%% Abstract:
%%  Return the name of the global timing bridge for modelref, and mark it
%% as accessed.  If it's not accessed, we do not need to declare it or pass
%% it through the registration function.
%function SLibGetGlobalTimingBridge() void
  %assert (IsModelReferenceTarget() || HasModelReferenceBlocks()) 
  %assign ::tMdlRefTimingBridgeAccessed = TLC_TRUE
  %if RTMTimingBridgeIsReqFcn() 
    %return RTMGet("timingBridge")
  %else
    %return ::tMdlRefTimingBridge  
  %endif
%endfunction

%% Function: SLibModelNeedsTriggerTIDArg =======================================
%% Abstract:
%%  Does this model need a triggerTID argument in the registration function?
%% Note that this is only true for referenced models, but parent models may
%% also call this function.  The model will have a triggerTID if there is a
%% triggerTID field in the rtModel, or some submodel uses a triggerTID.
%function SLibModelNeedsTriggerTIDArg() void
  %assert (IsModelReferenceTarget() || HasModelReferenceBlocks())
  %return RTMMdlRefTriggerTIDIsReqFcn() || ...
    ::CompiledModel.ModelBlockNeedsTriggerTID
%endfunction
  

%% Function: SLibMdlRefNetPreprocessorCondition =============================
%% Abstract:
%%   Return a block's net preprocessor condition
%%
%function SLibMdlRefNetPreprocessorCondition(block) void
  %assign condition = block.ParamSettings.NetPreprocessorCondition
  %if ISEMPTY(condition)
    %return ""
  %else
    %return condition
  %endif
%endfunction
  
%% Function: SLibMdlRefIfNetPreprocessorCondition =============================
%% Abstract:
%%   Return a block's net opening preprocessor condition
%%
%function SLibMdlRefIfNetPreprocessorCondition(block) void
  %assign condition = block.ParamSettings.NetPreprocessorCondition
  %if ISEMPTY(condition)
    %return ""
  %else
    %return "#if %<condition>"
  %endif
%endfunction
  
%% Function: SLibMdlRefEndIfNetPreprocessorCondition ==========================
%% Abstract:
%%   Return a block's net closing preprocessor condition
%%
%function SLibMdlRefEndIfNetPreprocessorCondition(block) void
  %assign condition = block.ParamSettings.NetPreprocessorCondition
  %if ISEMPTY(condition)
    %return ""
  %else
    %return "#endif /* %<condition> */"
  %endif
%endfunction
  
%% Function: SLibMdlRefLocalPreprocessorCondition =============================
%% Abstract:
%%   Return a block's local preprocessor condition
%%
%function SLibMdlRefLocalPreprocessorCondition(block) void
  %assign condition = block.ParamSettings.LocalPreprocessorCondition
  %if ISEMPTY(condition)
    %return ""
  %else
    %return condition
  %endif
%endfunction
  
%% Function: SLibMdlRefIfLocalPreprocessorCondition ===========================
%% Abstract:
%%   Return a block's local opening preprocessor condition
%%
%function SLibMdlRefIfLocalPreprocessorCondition(block) void
  %assign condition = block.ParamSettings.LocalPreprocessorCondition
  %if ISEMPTY(condition)
    %return ""
  %else
    %return "#if %<condition>"
  %endif
%endfunction
  
%% Function: SLibMdlRefEndIfLocalPreprocessorCondition ========================
%% Abstract:
%%   Return a block's local closing preprocessor condition
%%
%function SLibMdlRefEndIfLocalPreprocessorCondition(block) void
  %assign condition = block.ParamSettings.LocalPreprocessorCondition
  %if ISEMPTY(condition)
    %return ""
  %else
    %return "#endif /* %<condition> */"
  %endif
%endfunction
  
%% DocFunction{Advanced Functions}: LibAppendToModelReferenceUserData =========
%%
%% Abstract:
%%
%% Appends the given data object to the userdata in the binfo file
%% for the model currently being built.  This function can only be
%% called when generating code for model reference targets, not for SIM target.
%% 
%% This data cannot be a Vector or Matrix.  To work around this limitation, 
%% create a record with a field containing the Vector or Matrix data and 
%% pass this record into this function.
%%
%function LibAppendToModelReferenceUserData(data) void
  %if ! LibIsModelReferenceRTWTarget()
     %assign errTxt = "To use LibAppendToModelReferenceUserData the target type must be RTW"
     %<LibReportError(errTxt)>
  %endif

  %assign datatype = TYPE(data)
  %if ( ISEQUAL(datatype, "Vector") || ISEQUAL(datatype, "Matrix"))
     %assign errTxt = "To use LibAppendToModelReferenceUserData the data cannot be a matrix or vector.  Instead, create a record with a field containing the vector or matrix data and pass this record into this function."
     %<LibReportError(errTxt)>
  %endif

  %assign targetType = ::CompiledModel.ModelReferenceTargetType

  %assign modelName     = ::CompiledModel.Name

  %assign infoStruct = FEVAL("rtwprivate", "rtwinfomatman",...
                             "appendToUserData", "binfo", ...
                             "%<modelName>", "%<targetType>", data)
%endfunction



%% DocFunction{Advanced Functions}: LibGetModelReferenceUserData ==============
%%
%% Abstract:
%%
%% Gets the user data for the given model.  This returns a vector with
%% one element for each time LibAppendToUserData was called in the given
%% model.
%%
%% This function cannot be called during builds where the target type is SIM.
%%
%function LibGetModelReferenceUserData(modelName)
  %if LibIsModelReferenceSimTarget()
     %assign errTxt = "To use LibGetModelReferenceUserData the target type cannot be SIM"
     %<LibReportError(errTxt)>
  %endif

  %assign size = FEVAL("rtwprivate", "rtwinfomatman", ...
       "getUserDataSize", "binfo", "%<modelName>", "RTW")

  %assign toReturn = []

  %foreach idx = size
     %assign midx = idx + 1 %% M is 1 based, TLC is 0 based
         
     %assign data = FEVAL("rtwprivate", "rtwinfomatman", ...
                          "getUserData", "binfo", "%<modelName>", "RTW", midx)

     %assign toReturn = toReturn + data
  %endforeach
  
  %return toReturn
%endfunction



%% DocFunction{Advanced Functions}: LibGetReferencedModelNames ================
%%
%% Abstract:
%%
%% Gets the names of the models referenced by the model that is currently
%% being built.  This returns the data as a structure with two fields:
%%
%%    1) NumReferencedModels:  an integer with the number of model names
%%    2) ReferencedModel:  an array of structures, where each structure
%%                         has a field Name containing the name
%%                         of a referenced model
%%
%function LibGetReferencedModelNames()
  %% If there are no model reference blocks, then 
  %% ::CompiledModel.ModelReferenceBlocks will not exist.
  %% As a result, we need to handle the case of no model reference 
  %% blocks separately.
  %if ! HasModelReferenceBlocks()
     %createrecord toReturn { }
     %addtorecord toReturn NumReferencedModels 0
     %addtorecord toReturn ReferencedModel []
     %return toReturn
  %endif

  %assign mdlRefBlks = ::CompiledModel.ModelReferenceBlocks
  %assign numMdlRefs = SIZE(mdlRefBlks,0)
  %createrecord modelNames { }

  %% Loop over each model reference block and get the name of the
  %% referenced model.
  %foreach rowIdx = numMdlRefs
      %assign mdlRefInfo = mdlRefBlks[rowIdx]
      %assign mSysIdx    = mdlRefInfo[0]
      %assign bIdx       = mdlRefInfo[1]
      %assign mdlrefBlk  = ::CompiledModel.System[mSysIdx].Block[bIdx]
      %assign mdlName    = mdlrefBlk.ParamSettings.ReferencedModelName 

      %if !ISFIELD(modelNames, mdlName)
          %addtorecord modelNames %<mdlName> 1
      %endif
  %endforeach

  %assign modelNames = FIELDNAMES(modelNames)
  %assign numModelNames = SIZE(modelNames, 1)

  %% Now that we have the names of all the models, construct
  %% the structure to return.
  %createrecord toReturn { }
  %addtorecord toReturn NumReferencedModels numModelNames
  %foreach nameIdx = numModelNames
      %assign modelName = modelNames[nameIdx]
      %addtorecord toReturn ReferencedModel { Name "%<modelName>"}
  %endforeach

  %return toReturn
%endfunction


%% Function: SLibGetCPPMdlRefObjName =============================
%% Abstract:
%%   For C++ encapsulation MdlRef support, given model reference
%%   block that is within a non-virtual subsystem, find the corresponding
%%   DWork record for the mdlref block in the Subsystem.
%%
%function SLibGetSubsysDWorkForCPPMdlRefBlk(blk) void
  %assert GenerateClassInterface
  %assert blk.Type == "ModelReference"
  %assert SLibIsLangCPPEncap(blk.MdlRefTargetLang)
  %assert ISFIELD(blk,"CPPObjDWorkIdxInSubsys")

  %% Containing subsystem
  %assign sys            = ::CompiledModel.System[blk.BlockIdx[0]]
  %% Get one callsite of the containing subsystem
  %assign callSite       = sys.CallSites[0]
  %assign graphicalSys   = ::CompiledModel.System[callSite[2]]
  %assign subsysBlk      = graphicalSys.Block[callSite[3]]
  %assign dworkIdx       = subsysBlk.DWork[blk.CPPObjDWorkIdxInSubsys].FirstRootIdx
  
  %return ::CompiledModel.DWorks.DWork[dworkIdx]
%endfunction %% 


%% Function: SLibGetCPPMdlRefObjName =============================
%% Abstract:
%%   For C++ encapsulation MdlRef support, given a subsystem idx
%%   and the modelref block id, find the corresponding object
%%   name on which the member functions can be called.
%%
%function SLibGetCPPMdlRefObjName(sysIdx,blkIdx) void
   %assert GenerateClassInterface
   %assert ISFIELD(::CompiledModel, "CPPEncapsulationMdlRefRecord")
   %assert System[sysIdx].Block[blkIdx].Type == "ModelReference"   
   %assert SLibIsLangCPPEncap(System[sysIdx].Block[blkIdx].MdlRefTargetLang)
   
   %assign blk = System[sysIdx].Block[blkIdx]

    %if ISFIELD(blk,"CPPObjDWorkIdxInSubsys")
      %assign dwRec = SLibGetSubsysDWorkForCPPMdlRefBlk(blk)
      %return LibGetRecordIdentifier(dwRec)
   %endif
     
   %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
     ::CompiledModel.ModelReferenceBlocks : []
  
  
   %assign mdlRefBlkInd = -1
  
   %if !ISEMPTY(mdlRefBlks)
     %foreach rowIdx = SIZE(mdlRefBlks,0)
       %assign mdlRefInfo = mdlRefBlks[rowIdx]
       %assign mSysIdx = mdlRefInfo[0]
       %assign bIdx    = mdlRefInfo[1]
       
       %if mSysIdx == sysIdx && bIdx == blkIdx
         %assign mdlRefBlkInd = rowIdx
         %break
       %endif
     %endforeach
   %endif
  
   %assign mdlRefInstCPPVar = ...
     GETFIELD(::CompiledModel.CPPEncapsulationMdlRefRecord,...
     "MdlRefInstanceVar%<mdlRefBlkInd>")

   %return mdlRefInstCPPVar
   
%endfunction %%SLibGetCPPMdlRefObjName


%% Function: SLibCalcMdlRefObjSubsysAccessPath =================
%% Abstract:
%%   For C++ encapsulation MdlRef support, given a non-inlined
%%   subsystem idx, the modelref block id, the instance id, and sysFcn, 
%%   calculate the corresponding object access path via the subsystem 
%%   dwork.
%%
%function SLibCalcMdlRefObjSubsysAccessPath(sysIdx,blkIdx,instIdx,sysFcn) void
   %assert GenerateClassInterface
   %assert System[sysIdx].Block[blkIdx].Type == "ModelReference"   
   %assert SLibIsLangCPPEncap(System[sysIdx].Block[blkIdx].MdlRefTargetLang)
   %assert !LibSystemIsRoot(System[sysIdx]) && ...
           !IsModelReferenceBaseSys(System[sysIdx])
   
   %assign locCacheBlockFcn = ::BlockFcn
   %assign ::BlockFcn = sysFcn
   
   %assign dworkIdx = SLibGetStructDWorkIdxForModelRefBlk(System[sysIdx].Block[blkIdx])
   %assign dwRec = ...
     ::CompiledModel.DWorks.DWork[::CompiledModel.System[sysIdx].Block[blkIdx].DWork[dworkIdx].FirstRootIdx]
   %assign varGroupIdx = FcnSysVarGroupIndex(System[sysIdx], "DWork", instIdx)
   %assign baseSysIdx = GetBaseSystemIdx()
   %assign dworkPath = SLibCGIRVarGroupPath(varGroupIdx, baseSysIdx, ...
                         System[sysIdx].CrossNoArgFcnBound)
   %assign mdlRefInstCPPVar = ...
           SLibGetCPPMdlRefObjName(System[sysIdx].SystemIdx,...
                      System[sysIdx].Block[blkIdx].BlockIdx[2])                    
   %assign cppVarPath = dworkPath + mdlRefInstCPPVar

   
   
   %assign ::BlockFcn = locCacheBlockFcn
   
   %return cppVarPath
   
%endfunction %%SLibCalcMdlRefObjSubsysAccessPath

%% Function: SLibModelHierarchyContainsNoninlinedSfcn ===========================
%% Abstract:
%%    Return true if this model, or any model below contains a non-inlined
%% S-Function
%%
%function SLibModelHierarchyContainsNoninlinedSfcn()
  %if ::CompiledModel.NumChildSFunctions > 0 || ...
    ::CompiledModel.ModelBlocksHaveNonInlinedSfcns
    %return TLC_TRUE
  %else
    %return TLC_FALSE
  %endif
%endfunction

%% Function: GetAcceleratorStringForFunction ===================================
%% Abstract:
%%    Helper function to return the string used by accelerator to call
%% back into the Simulink engine to call a certain block method.
%function GetAcceleratorStringForFunction(sysFcn) void
  %assign accFunction = ""
  %switch (sysFcn)
    %case "Initialize"
      %assign accFunction = "SS_CALL_MDL_INITIALIZE_CONDITIONS"
      %break
      
    %case "Enable"
      %assign accFunction = "SS_CALL_RTW_GENERATED_ENABLE"
      %break
      
    %case "Disable"
      %assign accFunction = "SS_CALL_RTW_GENERATED_DISABLE"
      %break
      
    %case "Output"
    %case "OutputUpdate"
      %assign accFunction = "SS_CALL_MDL_OUTPUTS"
      %break
      
    %case "Update"
      %assign accFunction = "SS_CALL_MDL_UPDATE"
      %break
      
    %case "FinalizeDims"
      %assign accFunction = "SS_CALL_MDL_FINALIZE_ALL_DIMS"
      %break
      
    %case "ZeroCrossing"
      %assign accFunction = "SS_CALL_MDL_ZERO_CROSSINGS"
      %break
      
    %case "Projection"
      %assign accFunction = "SS_CALL_MDL_PROJECTION"
      %break
      
    %case "Derivative"
      %assign accFunction = "SS_CALL_MDL_DERIVATIVES"
      %break
      
    %case "ForcingFunction"
      %assign accFunction = "SS_CALL_MDL_FORCINGFUNCTION"
      %break
      
    %case "MassMatrix"
      %assign accFunction = "SS_CALL_MDL_MASSMATRIX"
      %break
      
    %case "Terminate"
      %assign accFunction = "SS_CALL_MDL_TERMINATE"
      %break
  %endswitch
  
  %return accFunction
%endfunction


%% Function: SLibSerializeFcnArgs =============================================
%% Abstract:
%%   Helper function to write out a vector of arguments into a comma
%% separated list.
%function SLibSerializeFcnArgs(recArgs)
  %assign fcnArgs = ""
  %foreach idx = SIZE(recArgs,1)
    %if idx == 0
      %assign fcnArgs = recArgs[idx]
    %else
      %assign fcnArgs = fcnArgs + ", %<recArgs[idx]>"
    %endif
  %endforeach

  %return fcnArgs
%endfunction

%% Function: SLibGetModelArgumentIdentifier =============================
%% Abstract:
%%  Helper function to get the name of the model workspace variable for
%%  a model argument in a referenced model
%function SLibGetModelArgumentIdentifier(canPrmDef, canPrmIdx)
  %% If the arg is not used, just use the name in the canPrmDef since
  %% the variable won't really be used as an argument.
  %if (canPrmDef.IsUsed == "no")
    %assign ident = LibGetRecordIdentifier(canPrmDef)
  %else
    %assign baseIdx = GetBaseSystemIdx()
    %assign callSite = System[baseIdx].CallSites[0]
    %assign ssBlk       = System[callSite[2]].Block[callSite[3]]
    %assign childPrmIdx = ...
      ssBlk.CallSiteInfo.CanonicalPrmArg[canPrmIdx].ChildPrmArgIdx
    %assign canPrm  = SLibGetCallSitePrmArg(callSite, childPrmIdx)
    %assign ident = LibGetRecordIdentifier(canPrm.ASTNode)
  %endif

  %return ident 
%endfunction

%% Function: SLibSetModelRefCacheFcnCallInputInfo =============================
%% Abstract:
%%  Helper function for supporting root-level function-call inports,
%%  this is used to cache away information about each task.
%function SLibSetModelRefCacheFcnCallInputInfo(portIdx, fcnType, taskName, tid, isAsync, groupIdx) void
  %assert IsModelReferenceTarget() || Accelerator || ...
    (FEVAL("slfeature", "RootFcnCallInportTopLevelBuild") > 0)
  %assign mdlRefSys = ::CompiledModel.System[GetBaseSystemIdx()]
  
  %if !LibIsSystemField(mdlRefSys, "FcnCallInputInfo")
    %createrecord fcnCallInfo {}
    %<LibAddToSystem(mdlRefSys, "FcnCallInputInfo", fcnCallInfo)>
  %endif
  
  %assign currField = LibGetSystemField(mdlRefSys, "FcnCallInputInfo")

  %% We don't seem to handle going from OutputUpdate to Output, just
  %% switch the fcnType here.
  %if fcnType == "OutputUpdate"
    %assign fcnType = "Output"
  %endif
  
  %if !ISEMPTY(currField) 
    %foreach idx = SIZE(currField.FcnCallInfo, 1)
      %assign info = currField.FcnCallInfo[idx]
      %if info.TaskName == taskName
        %% It is possible this function is called multiple times for the same taskName, 
        %% e.g., child module calls a parent module's SubFunction, but we only want to
        %% register the same taskName once
        %return
      %endif
    %endforeach
  %endif
  
  %addtorecord currField FcnCallInfo { ...
    FcnType  STRING(fcnType); ...
    TaskName STRING(taskName); ...
    TID      tid;...
    PortIdx  portIdx;...
    isAsync  isAsync;...
    FcnCallPortGroupIndex groupIdx}
  
  %<LibSetSystemField(mdlRefSys, "FcnCallInputInfo", currField)>  

%endfunction

%% Function: SLibModelRefMakeSimTargetRootFcnCallOutput =========================
%% Abstract:
%%  Generate the code for a model ref root function call output for Model
%%  Reference SIM target
%function SLibModelRefMakeSimTargetRootFcnCallOutput(srcKey, fcnTypeStr) Output
  %assign simS = RTMGet("MdlRefSfcnS")
  %assign macroName = "ssModelRefMakeRootOutportFcnCall" + fcnTypeStr
  
  %<macroName>(%<simS>, 0, "%<srcKey>")
%endfunction
  
%% Function: SLibModelRefRegisterRootFcnCallOutputCoderInfo
%% Abstract:
%%  Record information about the method names used to make function call
%%  outputs on different ports
%function SLibModelRefRegisterRootFcnCallOutputCoderInfo(modelName, portIdx, fcnType, methodName) void
  %assert IsModelReferenceRTWTarget()
  %assign mdlRefSys = ::CompiledModel.System[GetBaseSystemIdx()]
  
  %if !LibIsSystemField(mdlRefSys, "FcnCallOutputCoderInfo")
    %createrecord fcnCallInfo {}
    %<LibAddToSystem(mdlRefSys, "FcnCallOutputCoderInfo", fcnCallInfo)>
  %endif
  
  %assign currField = LibGetSystemField(mdlRefSys, "FcnCallOutputCoderInfo")

  %addtorecord currField FcnCallInfo { ...
    ModelName  STRING(modelName);...
    PortIdx    portIdx;...
    FcnType    STRING(fcnType);...
    MethodName STRING(methodName)}
    
  %<LibSetSystemField(mdlRefSys, "FcnCallOutputCoderInfo", currField)>  
%endfunction


%% Function: SLibModelRefRegisterRootFcnCallOutputSimInfo
%% Abstract:
%%  Record information about the method names used to make function call
%%  outputs on different ports
%function SLibModelRefRegisterRootFcnCallOutputSimInfo(srcKey, outputPortIdx) void
  %assert IsModelReferenceSimTarget()
  %assign mdlRefSys = ::CompiledModel.System[GetBaseSystemIdx()]
  
  %if !LibIsSystemField(mdlRefSys, "FcnCallOutputSimInfo")
    %createrecord fcnCallInfo {}
    %<LibAddToSystem(mdlRefSys, "FcnCallOutputSimInfo", fcnCallInfo)>
  %endif
  
  %assign currField = LibGetSystemField(mdlRefSys, "FcnCallOutputSimInfo")

  %addtorecord currField FcnCallInfo { ...
    SrcKey         STRING(srcKey);...
    OutputPortIdx  outputPortIdx... 
  }
    
  %<LibSetSystemField(mdlRefSys, "FcnCallOutputSimInfo", currField)>  
%endfunction


%function SLibEmitModelRefSimulinkAcceleratorFcnCallMethodPointerRegistration() Output
  %assign baseSys = ::CompiledModel.System[GetBaseSystemIdx()]
  
  %if LibIsSystemField(baseSys, "FcnCallOutputSimMethod")
    %assign fcnCallInfo = LibGetSystemField(baseSys, "FcnCallOutputSimMethod")
    %assign ssVar = RTMGetModelSS()
    
    /* Registration of function pointers for function call subsystems called
     * from Model blocks */
    %foreach idx = SIZE(fcnCallInfo.FcnCallInfo, 1)
      %assign info = fcnCallInfo.FcnCallInfo[idx]
      
      %assign sysIndex   = info.SysIndex
      %assign blkIndex   = info.BlkIndex
      %assign methodType = info.Type
      %assign methodName = info.Method
      %assign portNum    = info.PortNum
      %assign fcnEnum    = "SS_MODELREF_FCNCALL_" + FEVAL("upper", info.Type)
      %assign slBlkIndex = ::CompiledModel.System[sysIndex].Block[blkIndex].SL_BlockIdx
      
      ssSetModelRefSimulinkAcceleratorFcnCallMethod(%<ssVar>, %<sysIndex>, %<slBlkIndex>, %<portNum>, &%<methodName>, %<fcnEnum>);
    %endforeach
  %endif
%endfunction


%% Function: SLibModelRefRegisterSimTargetFcnCallMethodPointers
%% Abstract:
%%  Record information about the which methods need to be registered with 
%%  Simulink so they can be executed in response to function calls
%function SLibModelRefRegisterSimTargetFcnCallMethodPointers(srcKey, functionType, methodName, ...
                                                             sysIndex, blkIndex, portNum) void
  %assign mdlRefSys = ::CompiledModel.System[GetBaseSystemIdx()]
  
  %if !LibIsSystemField(mdlRefSys, "FcnCallOutputSimMethod")
    %createrecord fcnCallInfo {}
    %<LibAddToSystem(mdlRefSys, "FcnCallOutputSimMethod", fcnCallInfo)>
  %endif
  
  %assign currField = LibGetSystemField(mdlRefSys, "FcnCallOutputSimMethod")

  %addtorecord currField FcnCallInfo { ...
    SrcKey   STRING(srcKey);...
    Type     STRING(functionType);...
    Method   STRING(methodName);...
    SysIndex sysIndex;...
    BlkIndex blkIndex;...
    PortNum  portNum...
  }
    
  %<LibSetSystemField(mdlRefSys, "FcnCallOutputSimMethod", currField)>  
%endfunction


%% Function: SLibSetModelRefCachePeriodicFcnCallInputInfo =====================
%% Abstract:
%%  Helper function for supporting root-level periodic function-call inports,
%%  this is used to cache away information about each periodic task.
%function SLibSetModelRefCachePeriodicFcnCallInputInfo(portIdx, fcnType, fcnName, tid) void
  %<SLibSetModelRefCacheFcnCallInputInfo(portIdx, fcnType, fcnName, tid, TLC_FALSE, -1)>
%endfunction


%% Function: SLibSetModelRefCacheAsyncFcnCallInputInfo ========================
%% Abstract:
%%  Helper function for supporting root-level async function-call inports, this
%%  is used by the inserted s-function to cache away information about each async
%%  task.
%function SLibSetModelRefCacheAsyncFcnCallInputInfo(taskName, portIdx, tid, fcnType, groupIndex) void
  %<SLibSetModelRefCacheFcnCallInputInfo(portIdx, fcnType, taskName, tid, TLC_TRUE, groupIndex)>
%endfunction

%% Function: ModelBlockHasAsyncInput ===========================================
%%   Helper function to determine if a Model block has async function-call
%% inputs
%function ModelBlockHasAsyncInput(tid, block) void
  %return LibAsynchronousTriggeredTID(tid) && ...
    block.ParamSettings.HasAsyncFcnCallInput
%endfunction

%% Function: SLibGetSSExportMethodCall =======================================
%%   Dump out a call in the model reference s-function to register an exported
%% method for function-call inputs.
%function SLibGetSSExportMethodCall(fcnInfo, taskFcnName) void
  %switch fcnInfo.FcnType
    %case "Output"
      %assign retVal = "ssExportOutputFcn(S, %<fcnInfo.PortIdx>, %<taskFcnName>);"
      %break
      
    %case "Disable"
      %assign retVal = "ssExportDisableFcn(S, %<fcnInfo.PortIdx>, %<taskFcnName>);"
      %break

    %case "Enable"
      %assign retVal = "ssExportEnableFcn(S, %<fcnInfo.PortIdx>, %<taskFcnName>);"
      %break
      
    %default
      %<LibReportFatalError("Unexpected fcnType: %<fcnInfo.FcnType>")>
  %endswitch
  
  %return retVal
%endfunction
      

%% Function: SLibIsModelRefAsyncTID ============================================
%% Abstract:
%%  We now support async TID's in referenced models, but only when they
%% come from a root function-call inport.
%function SLibIsModelRefAsyncTID(tid)
  %return IsModelReferenceTarget() && LibAsynchronousTriggeredTID(tid)
%endfunction


%% Function: SLibCreateWrapperForModelBlockFCI ================================
%% Abstract:
%%   Core method to create the wrapper function for a model block
%% function-call input.
%function SLibCreateWrapperForModelBlockFCI(modelBlock, fcnType) void
  %if !ISFIELD(modelBlock.WrapperFcns, "%<fcnType>")
    %return ""
  %endif

  %assign fcnBuffers = modelBlock.WrapperFcns.%<fcnType>
  %assign locSS = RTMGetModelSS()
  %assign args = tSimStructType + " *const " + locSS
  %assign args = args + ", int_T " + tControlPortIdx
  %assign args = args + ", int_T " + tTID
  
  %openfile fcnBuf
  %foreach idx = SIZE(fcnBuffers,1)
    %assign fcnBuffer = modelBlock.WrapperFcns.%<fcnType>[idx]
    %assign tid = CAST("Number", fcnBuffer.TID)
    %assign isAsync = fcnBuffer.isAsync
    
    /* 
    * Force non-inlined (FNI) function call stub
    * for '%<modelBlock.Name>'
    */    
    boolean_T %<fcnBuffer.FcnName>(%<args>) {
    %if isAsync && ...
      modelBlock.ParamSettings.IsTopAsync[fcnBuffer.FcnCallPortGroupIndex] && ...
      fcnType == "OutputUpdate"
      %<SLibDumpOutputUpdateCodeForAsyncTid(tid)>\
    %elseif ISFIELD(modelBlock, "CallerBlkIdx")
      %assign callerBlkIdx = modelBlock.CallerBlkIdx
      %assign sfcnBlkEl = modelBlock.CallerBlkPortEl
      %assign sfcnBlk = System[callerBlkIdx[0]].Block[callerBlkIdx[2]]
      %<SLibBlockExecuteSysFcn(sfcnBlk, sfcnBlkEl, fcnType)>\
    %else
      %<CallModelBlockAsyncFcnCallInput(modelBlock, fcnBuffer.FcnPortIdx, ...
        tid, fcnType)>\
    %endif
    }
  %endforeach
  %closefile fcnBuf
 
  %return fcnBuf
%endfunction


%% Function: SLibGenerateFNIStubsForModelBlocks ===============================
%% Abstract:
%%   If there are any non-inlined s-function calling Model block function-call
%% inputs, generate the wrapper functions we attach to the s-function.
%function SLibGenerateFNIStubsForModelBlocks() void
  %openfile fcnBuff
  %if ISFIELD(::CompiledModel, "NumModelReferenceBlocks")
    %foreach idIdx = NumModelReferenceBlocks
      %assign blkIdx    = ModelReferenceBlocks[idIdx]
      %assign mdlBlock  = ::CompiledModel.System[blkIdx[0]].Block[blkIdx[1]]
      %if ISFIELD(mdlBlock, "WrapperFcns")
        %<SLibCreateWrapperForModelBlockFCI(mdlBlock, "OutputUpdate")>\
        %<SLibCreateWrapperForModelBlockFCI(mdlBlock, "Enable")>\
        %<SLibCreateWrapperForModelBlockFCI(mdlBlock, "Disable")>\
      %endif
    %endforeach
  %endif
  %closefile fcnBuff
  %return fcnBuff
%endfunction


%% Function: SLibGetArgumentsForFcnCallInput ===================================
%% Abstract: 
%%   Returns a string used for the definition of the task associated with
%% a root-level function-call inport in a referenced model.  For async, the 
%% CurrentTID in the baseSystem will specify which async task this is for.
%function SLibGetArgumentsForFcnCallInput(baseSystem, fcnName) void
  %assign recArgs = []
  %if Accelerator
    %assign recArgs = recArgs + "%<tSimStructType> *S"
  %else
    %assign recArgs = SLibModelReferenceAppendInputsOutputs(TLC_FALSE, ...
      ::BlockFcn, fcnName, TLC_TRUE, baseSystem.CurrentTID, recArgs)  
  %endif
  
  %% Format the return with comma's in between each argument.
  %return SLibSerializeFcnArgs(recArgs)
%endfunction

%% Function: SLibCallModelBlockFcnCallInput ====================================
%% Abstract:
%%   Called for s-functions making function-calls to Model blocks.
%function SLibCallModelBlockFcnCallInput(sysIdx, blkIdx, portIdx, ...
  blkFcn, tid, callTaskTopBlk) Output
  %% To generate the right code for a branched/wide async fcn-call
  %% initiator, we need to let the s-function make the call.
  %if callTaskTopBlk
    %assign blkIdx = [%<sysIdx>, %<blkIdx>, %<portIdx>]
    %assign taskTopBlock = FcnGetTaskTopSfcnBlock(tid)
    %<SLibGetAsyncSysCodeForTaskTopBlk(taskTopBlock, tid, ...
      "ModelReference", blkIdx)>\
  %else
    %assign system = System[sysIdx]
    %with system
      %assign block = Block[blkIdx]
      %with block
        %<CallModelBlockAsyncFcnCallInput(block, portIdx, tid, blkFcn)>\
      %endwith
    %endwith  
  %endif
%endfunction

%% Function: SLibGetModelBlockFcnCallInputInfo =================================
%% Abstract:
%%   Get the FcnCallInfo for the specified input and fcnType of a Model block.
%function SLibGetModelBlockFcnCallInputInfo(block, portIdx, fcnType) void
  %assign blockInterface = GetModelrefInterface(block)
  %assign fcnCallInfo = []
  
  %% We treat OutputUpdate as Output
  %if fcnType == "OutputUpdate"
    %assign fcnType = "Output"
  %endif
  
  %assert (portIdx != -1)
  
  %% For now, loop over the info to find the one associated
  %% with the port.  We should make this a direct index.
  %foreach idx = SIZE(blockInterface.FcnCallInputs, 1)
    %assign locCallInfo = blockInterface.FcnCallInputs[idx]
    %if locCallInfo.PortIdx == portIdx && ...
      locCallInfo.FcnType == fcnType
      %assign fcnCallInfo = locCallInfo
      %break
    %endif
  %endforeach

  %return fcnCallInfo
%endfunction

%% Function: CallModelBlockAsyncFcnCallInput ==================================
%% Abstract:
%%    Call the given function for an async task in a referenced model.
%function CallModelBlockAsyncFcnCallInput(block, portIdx, localTid, ...
  fcnType) void
  
  %assign blockInterface = GetModelrefInterface(block)
  
  %assign fcnCallInfo = SLibGetModelBlockFcnCallInputInfo(block, portIdx, fcnType)
 
  %% If we found a corresponding function in the referenced model, call
  %% that function
  %assign fcnCall = ""
  %if !ISEMPTY(fcnCallInfo)
    %if Accelerator
      %assign fcnCall = SLibCallModelBlockFcnCallInputInSimulink(block, portIdx, ...
        localTid, fcnType)
    %else
      %assign fcnCall = SLibCallModelBlockFunction([], block, fcnCallInfo.TaskName, ...
        blockInterface, fcnCallInfo.TaskFcnInfo.FcnRec, 0, localTid, 0, "")
    %endif
  %endif
  
  %return fcnCall
%endfunction  

%function SLibGetSysFcnCall(block, fcnType) void
  %assign retBuff = ""
  %switch fcnType
    %case "OutputUpdate"
      %assign retBuff = LibBlockExecuteFcnCall(block, 0)
      %break
      
    %case "Enable"
    %case "Disable"
      %assign retBuff = block.%<fcnType>CodeCache
      %break
      
    %default
      %assign errTxt = ["Invalid function type %<fcnType>"]
      %<LibReportError(errTxt)>
      %break
  %endswitch

  %return retBuff
%endfunction
          
%function SLibFindPortGroupIndex(inportIndex)
  %assign retVal = -1
  %with ::CompiledModel.ExternalPortGroups
    %foreach groupIdx = NumFcnCallPortGroups
      %if FcnCallPortGroup[groupIdx].FcnCallInputPort == inportIndex
        %assign retVal = groupIdx
        %break
      %endif
    %endforeach
  %endwith
    
  %return retVal
%endfunction


%% Function: SLibModelRefInportExecuteFcnCall =================================
%% Abstract:
%%   Used by root-level async function-call inputs for model reference.  This 
%% will call the connected function-call subsystems and cache the code.
%function SLibModelRefInportExecuteFcnCall(block, system, fcnType) void

  %assert Accelerator || ...
    (FEVAL("slfeature", "RootFcnCallInportTopLevelBuild") > 0)
  %%modelref rootInport async gen. is directly from IR 
  %assert !IsModelReferenceTarget()
  
  %assign extInput = ExternalInputs.ExternalInput[SFcnParamSettings.Inport]
  
  %if block.ParamSettings.Asynchronous == "yes"
    %assign currentTID = system.CurrentTID
    %assign system.CurrentTID = FcnGetAsyncTidFromSfcnBlk(block, 0)
    %assign taskName = extInput.Async%<fcnType>Fcn
  %endif
  
  %% For now, output is always non-empty
  %assign checkForEmpty = (fcnType != "OutputUpdate")

  %if SLibSystemFcnRateGrouping(system, fcnType) || ...
    LibAsynchronousTriggeredTID(system.CurrentTID)
    %assign localTid = system.CurrentTID
  %else
    %assign localTid = ""
  %endif
  
  %% Call the appropriate method on the attached fcn-call systems
  %assign fcnCallBuff = SLibGetSysFcnCall(block, fcnType)

  %if checkForEmpty && ISEMPTY(fcnCallBuff)
    %return
  %endif
  
  %% Declare any local variables needed in the task entry function
  %assign globalVars = LibInitializeGlobalVars(system, fcnType)
  %assign localVars = FcnDumpMRLocalVars(system, fcnType, localTid)
  
  %% There are cases where we need to add variables from the "Output"
  %% function also.
  %if fcnType == "OutputUpdate"
    %assign localVars = localVars + FcnDumpMRLocalVars(system, "Output", localTid)
  %endif
  
  %% The async task function may have canonical inputs and outputs
  %% if it is hooked up directly to root inports and outports.
  %if IsModelReferenceTarget() || Accelerator
    %assign argList = SLibGetArgumentsForFcnCallInput(system, taskName)
  %elseif (FEVAL("slfeature", "RootFcnCallInportTopLevelBuild") > 0)
    %% Assume there is no argument for top-level build.
    %assign argList = ""
  %endif
  
  %openfile tmpBuf
  
  /* %<fcnType> task function for Block: '%<extInput.BlockName>' */
  void %<taskName>(%<argList>) {
    %<localVars>\
    
    %<globalVars>\
    
    %<fcnCallBuff>\
  }
  %closefile tmpBuf
  
  %if block.ParamSettings.Asynchronous == "yes"
    %assign system.CurrentTID = currentTID
  %endif
    
  %assign srcFile = LibGetModelDotCFile()
  %<LibSetSourceFileSection(srcFile, "Functions", tmpBuf)>
  
  %openfile extBuf
  %assign extArgList = argList
  %if ISEMPTY(argList)
    %assign extArgList = "void"
  %endif
  extern void %<taskName>(%<extArgList>);
  %closefile extBuf
  
  %assign hFile = LibGetModelDotHFile()
  %<LibSetSourceFileSection(hFile, "Definitions", extBuf)>
   

  %if block.ParamSettings.Asynchronous == "yes"
    %assign tid = FcnGetAsyncTidFromSfcnBlk(block, 0)
  %else
    %assign tid = ""
  %endif
  %assign groupIndex = SLibFindPortGroupIndex(SFcnParamSettings.Inport)
  %<SLibSetModelRefCacheAsyncFcnCallInputInfo(taskName, SFcnParamSettings.Inport, ...
    tid, fcnType, groupIndex)>
%endfunction

%endif %%_MODELREFUTIL_

%% [EOF] modelrefutil.tlc
