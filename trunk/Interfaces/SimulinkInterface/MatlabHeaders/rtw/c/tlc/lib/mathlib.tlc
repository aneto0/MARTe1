%%
%% Copyright 1994-2012 The MathWorks, Inc.
%%
%% Abstract: 
%%
%%   Methods and default data to allow target-specific datatyped
%%   run-time library support.  The target must register replacement 
%%   prototypes before including codegenentry.tlc.
%%
%%   NOTE: Since this file can be %included before codegenentry,
%%         many common TLC constants and utilities are not
%%         available for use in all methods in this library.
%%
%if EXISTS("_MATHLIB_") == 0
%assign _MATHLIB_ = 1

%% Function: FcnGetDataTypeIdFromName =========================================
%% Abstract:
%%   Return the TLC data type ID from the given MATLAB, RTW, or C 
%%   size-specific data type name.
%%
%%   The current implementation of the math library populates the 
%%   function data table (both the default and target registration passes)
%%   before the TLC data type ID's are defined, so MATLAB data type names 
%%   are used, with later translation from TLC enums for sanity.
%%
%function FcnGetDataTypeIdFromName(dTypeName) void
    %switch dTypeName
     %case "double"
     %case "real_T"
      %return tSS_DOUBLE
     %case "float"
     %case "single"
     %case "real32_T"
      %return tSS_SINGLE
     %case "int32_T"
     %case "int32"
      %return tSS_INT32
     %case "int16_T"
     %case "int16"
      %return tSS_INT16
     %case "int8_T"
     %case "int8"
      %return tSS_INT8
     %case "uint32_T"
     %case "uint32"
      %return tSS_UINT32
     %case "uint16_T"
     %case "uint16"
      %return tSS_UINT16
     %case "uint8_T"
     %case "uint8"
      %return tSS_UINT8
     %case "boolean_T"
     %case "boolean"
     %case "logical"
       %return tSS_BOOLEAN
     %case "pointer"
       %return tSS_POINTER
     %case "int_T"
     %case "integer"
       %return tSS_INTEGER
     %case "long"
       %return tSS_LONG
     %case "ulong"
       %return tSS_ULONG
     %case "long_long"
       %return tSS_LONG_LONG
     %case "ulong_long"
       %return tSS_ULONG_LONG
     %case "double_unint32_T"
       %return tSS_TIMER_UINT32_PAIR
     %case "void"
       %return tSS_VOID
     %case "size_t"
       %return tSS_SIZET
     %default
      %exit "MATHLIB: Unsupported datatype %<dTypeName>."
    %endswitch
%endfunction %% FcnGetDataTypeIdFromName


%% Function: FcnGetMathDataTypeNameFromId =====================================
%% Abstract:
%%    Return the canonical (MATLAB plus others) data type name given the 
%%    TLC type ID.  Cannot just use SLibGetMLTypeFromId() because support
%%    doesn't exist for all the TLC data types.
%%
%function FcnGetMathDataTypeNameFromId(dTypeId) void
  %assign typeName = SLibGetMLDataTypeFromId(dTypeId)
  %if ISEQUAL(typeName,"numeric")
    %%
    %% see if there is a better answer
    %%
    %switch dTypeId
      %case tSS_INTEGER
        %return "integer"
      %case tSS_POINTER
        %return "pointer"
      %case tSS_VOID
        %return "void"
      %case tSS_SIZET
        %return "size_t"
      %case tSS_LONG
        %return "long"
      %case tSS_ULONG
        %return "ulong"
      %case tSS_LONG_LONG
        %return "long_long"
      %case tSS_ULONG_LONG
        %return "ulong_long"
      %default
        %return typeName
    %endswitch
  %endif
  %return typeName
%endfunction %% FcnGetMathDataTypeNameFromId


%% Function: LibMathFcnExists ==========================
%% Abstract:
%%    Return whether or not an implementation function exists for a given
%%    generic operation (function), given the specified function prototype.
%%
%function LibMathFcnExists(RTWFcnName, RTWFcnTypeId) void
  %assign RTWType = FcnGetMathDataTypeNameFromId(RTWFcnTypeId)
  %assign FcnInfo = FEVAL("rtwgettargetfcnlib", LibGetModelName(), ...
    RTWFcnName, RTWType)
  %return !ISEMPTY(FcnInfo)
%endfunction %% LibMathFcnExists


%% Function: LibCreateHomogMathFcnRec ==================
%%
%function LibCreateHomogMathFcnRec(FcnName, FcnTypeId) void
  %% Test that we can use call the UDD based math function attached to the model
  %assign RTWType = FcnGetMathDataTypeNameFromId(FcnTypeId)
  %assign FcnInfo = FEVAL("rtwgettargetfcnlib", LibGetModelName(), ...
    FcnName, RTWType)
  %if ISEMPTY(FcnInfo)
    %assign msg = "Database has no function '%<FcnName>' returning '%<RTWType>'"
    %<LibReportFatalError(msg)>
  %endif

  %assign NumInputs = FcnInfo.NumInputs
  %createrecord FcnRec { Name FcnName; RetTypeId FcnTypeId; NumArgs NumInputs }
  %foreach k = NumInputs
    %addtorecord FcnRec ArgList { Expr "u%<k>"; TypeId FcnTypeId; IsPtr 0; IsCplx 0; IsConst 1 }
  %endforeach
  %return FcnRec
%endfunction


%% Function: LibCreateHomogFcnRec ==================
%%
%function LibCreateHomogFcnRec(FcnName, InputTypeId) void
  %% Test that we can use call the UDD based math function attached to the model
  %assign RTWType = FcnGetMathDataTypeNameFromId(InputTypeId)
  %assign FcnInfo = FEVAL("rtwgettargetfcnlib", LibGetModelName(), ...
    FcnName, RTWType)
  
  %if ISEMPTY(FcnInfo)
    %assign msg = "Database has no function '%<FcnName>' returning '%<RTWType>'"
    %<LibReportFatalError(msg)>
  %endif

  %assign NumInputs = FcnInfo.NumInputs
  %createrecord FcnRec { Name FcnName; RetTypeId FcnGetDataTypeIdFromName(FcnInfo.FcnType); NumArgs NumInputs }
  %foreach k = NumInputs
    %addtorecord FcnRec ArgList { Expr "u%<k>"; TypeId InputTypeId; IsPtr 0; IsCplx 0; IsConst 1 }
  %endforeach
  %return FcnRec
%endfunction


%% Function: LibSetMathFcnRecArgExpr ===================
%%
%function LibSetMathFcnRecArgExpr(FcnRec, idx, argStr) void
  %if idx < SIZE(FcnRec.ArgList,1)
    %assign FcnRec.ArgList[idx].Expr = argStr
  %else
    %% START_ASSERT
    %exit "Internal error:  argument index exceeds function prototype argument count"
    %% END_ASSERT
  %endif
  %return FcnRec
%endfunction %% LibSetMathFcnRecArgExpr


%% Function: LibGetMathConstant ========================
%% Abstract:
%%    Return a valid math constant expression with the proper datatype.
%%    This function can only be called after funclib.tlc is included.
%%
%function LibGetMathConstant(ConstName,ioTypeId) void

  %assign constInfo = SLibGetMathConstantInfo(ConstName,ioTypeId)
  %if ~ISEMPTY(constInfo)
    %return constInfo.Expr
  %else
    %return ""
  %endif

%endfunction
  
%% Function: SLibGetMathConstantInfo ========================
%% Abstract:
%%    Return a valid math constant expression with the proper datatype packed
%%    in a record along with the headerfile required to be included.
%%    This function can only be called after funclib.tlc is included.
%%
%function SLibGetMathConstantInfo(ConstName,ioTypeId) void

  %% Test that we can use call the UDD based math function attached to the model
  %assign RTWType = FcnGetMathDataTypeNameFromId(ioTypeId)
  %assign FcnInfo = FEVAL("rtwgettargetfcnlib", LibGetModelName(),  ...
    ConstName, RTWType)
  
  %if ISEMPTY(FcnInfo)
    %return ""
  %else
    %assign FcnName   = FcnInfo.FcnName
    %assign FcnType   = FcnInfo.FcnType
    %assign HdrFile   = FcnInfo.HdrFile
  %endif

  %assign FcnTypeId = FcnGetDataTypeIdFromName(FcnType)
  
  %if LibGetDataTypeIdAliasedThruToFromId(FcnTypeId) != ...
    LibGetDataTypeIdAliasedThruToFromId(ioTypeId)
    %assign outputCastBegin = "((%<LibGetDataTypeNameFromId(ioTypeId)>)"
    %assign outputCastEnd   = ")"
  %else
    %assign outputCastBegin = ""
    %assign outputCastEnd   = ""
  %endif

  %% --- Register references
  %if !ISEMPTY(HdrFile)
    %if HdrFile != "<math.h>" && HdrFile != "math.h"
      %if ISFIELD(::CompiledModel,"GenUtilsSrcInSharedLocation") && (::CompiledModel.GenUtilsSrcInSharedLocation == 1)
        %<LibAddtoSharedUtilsIncludes(HdrFile)>
      %else
        %<LibAddToCommonIncludes(HdrFile)>
      %endif
    %endif
  %endif
  %assign callExpr = "(" + outputCastBegin + FcnName + outputCastEnd +")"

  %% Need to clean up header file string
  %if ISEMPTY(HdrFile)
    %assign HdrFile = ""
  %elseif ISEMPTY(FEVAL("strfind",HdrFile,"<")) && ...
    ISEMPTY(FEVAL("strfind",HdrFile,"\""))
    %assign HdrFile = "\"" + HdrFile + "\""
  %endif

  %createrecord ConstInfo { Expr callExpr; HeaderFile HdrFile  }
  
  %return ConstInfo

%endfunction
  
%%  Function: SLibGenRTLibFcnCallForDataTypeId  ==============================
%% Abstract:
%%  Generate an expression to perform the requested generic run-time function
%%  consuming the required arguments contained in the FcnRec record's ArgList.
%%  The resulting string is not an lvalue.  If the requested generic function 
%%  is not supported, the empty string "" is returned.
%%
%%  If output type does not match generic output type, an output cast is added.
%%  If an input arg type does not match the generic input type, a cast is
%%  added to the input argument.
%%
%%  FcnRec record definition:
%%    Name      - generic function name
%%    RetTypeId - generic function return type (tSS_DOUBLE, void, etc.)
%%    NumArgs   - length of ArgList
%%    ArgList   - record array containing these fields:
%%                Expr    - Expression for argument instance (string)
%%                TypeId  - datatype ID of argument instance
%%                IsPtr   - arg is a pointer
%%                IsCplx  - arg is complex
%%                IsConst - arg is const (read-only)
%%
%function SLibGenRTLibFcnCallForDataTypeId(FcnRec, dtypeId) void
  %% Test that we can use call the UDD based math function attached to the model
  %assign RTWType = FcnGetMathDataTypeNameFromId(dtypeId)
  %assign FcnInfo = FEVAL("rtwgettargetfcnlib", LibGetModelName(), ...
    FcnRec.Name, RTWType)
  
  %if ISEMPTY(FcnInfo)
    %return ""
  %else
    %assign FcnName   = FcnInfo.FcnName
    %assign FcnType   = FcnInfo.FcnType
    %assign HdrFile   = FcnInfo.HdrFile
    %assign NumInputs = FcnInfo.NumInputs
  %endif

  %if NumInputs != FcnRec.NumArgs
    %% START_ASSERT
    %assign msg = "Number of arguments indicated in FcnRec must match"...
      "generic operation's number of arguments."
    %<LibReportFatalError(msg)>
    %% END_ASSERT
  %endif

  %% Note that LibAddTflHeadersToCommonIncludes() will take care of adding the #include
  %% of HdrFile to the common includes; we don't need to do it here.
  
  %assign FcnTypeId = FcnGetDataTypeIdFromName(FcnType)
  
  %% Type cast the return value if needed
  %if LibGetDataTypeIdAliasedThruToFromId(FcnTypeId) != ...
    LibGetDataTypeIdAliasedThruToFromId(FcnRec.RetTypeId)
    %assign outExpr = "(%<LibGetDataTypeNameFromId(FcnRec.RetTypeId)>)"
  %else
    %assign outExpr = ""
  %endif
  %assign outExpr = outExpr + FcnName + "("

  %% Generate the callsite arg list
  %foreach k = NumInputs
    %if k > 0
      %if !FEVAL("rem",k,2)
        %assign comma = ",\n"
      %else
        %assign comma = ","
      %endif
    %else
      %assign comma = ""
    %endif
    %assign outExpr = "%<outExpr>%<comma>%<FcnRec.ArgList[k].Expr>"
  %endforeach
  %return "%<outExpr>)"
%endfunction %% SLibGenRTLibFcnCallForDataTypeId


  
%% Function: SLibGenRTLibFcnCall ==============================================
%%  Abstract: This function is similar with SLibGenRTLibFcnCallForDataTypeId.
%%  The difference is data type id is not defined, use retunr data type to 
%%  choose function.
%%
%function SLibGenRTLibFcnCall(FcnRec) void
  
  %return SLibGenRTLibFcnCallForDataTypeId(FcnRec, FcnRec.RetTypeId)
  
%endfunction %% SLibGenRTLibFcnCall


%% Function: LibGenMemFcnCall =================================================
%% Abstract:
%%    Return a complete callsite expression for a memxxx() function of string.h
%%
%%       o) fcnName    - Name of the memxxx() function
%%       o) input0Arg  - string expression of input arg 0
%%       o) input1Arg  - string expression of input arg 1
%%       o) input2Arg  - string expression of input arg 2
%%
%%
%function LibGenMemFcnCall(fcnName, input0Arg, input1Arg, input2Arg) void
  %assign fcnInfo = SLibGenMemFcnCallInfo(fcnName, input0Arg, input1Arg, input2Arg)
  %if ISEMPTY(fcnInfo)
    %return ""
  %else
    %return fcnInfo.Expr
  %endif
%endfunction


%function SLibGenMemFcnCallInfo(fcnName, input0Arg, input1Arg, input2Arg) void
  %switch fcnName
    %case "memcpy"
      %createrecord FcnRec { Name fcnName; RetTypeId FcnGetDataTypeIdFromName("void"); IsPtr 1; IsCplx 0; IsConst 0; NumArgs 3 }
      %addtorecord FcnRec ArgList { Expr input0Arg; TypeId FcnGetDataTypeIdFromName("void"); IsPtr 1; IsCplx 0; IsConst 0 }
      %addtorecord FcnRec ArgList { Expr input1Arg; TypeId FcnGetDataTypeIdFromName("void"); IsPtr 1; IsCplx 0; IsConst 0 }
      %addtorecord FcnRec ArgList { Expr input2Arg; TypeId FcnGetDataTypeIdFromName("size_t"); IsPtr 0; IsCplx 0; IsConst 0 }
      %break
    %case "memset"
      %if EXISTS(::Memset2Zero) && ::Memset2Zero==1
        %% Strip out spaces since TLC does not pass them to MATLAB correctly
        %assign input1Arg_tmp = ""
        %if TYPE(input1Arg) != "String"
          %assign input1Arg_tmp = "%<input1Arg>"
        %else
          %foreach idx = SIZE(input1Arg,1)
            %if input1Arg[idx] != " "
              %assign input1Arg_tmp = input1Arg_tmp + "%<input1Arg[idx]>"
            %endif
          %endforeach
        %endif
        %if ISEMPTY(FEVAL("regexp",input1Arg_tmp,"[^0.]"))
          %% doing a memset to zero. See if there is a replacement for this.
          %createrecord FcnRec { Name "memset2zero"; RetTypeId FcnGetDataTypeIdFromName("void"); IsPtr 1; IsCplx 0; IsConst 0; NumArgs 3 }
          %addtorecord FcnRec ArgList { Expr input0Arg; TypeId FcnGetDataTypeIdFromName("void"); IsPtr 1; IsCplx 0; IsConst 0 }
          %addtorecord FcnRec ArgList { Expr input1Arg; TypeId FcnGetDataTypeIdFromName("integer"); IsPtr 0; IsCplx 0; IsConst 0 }
          %addtorecord FcnRec ArgList { Expr input2Arg; TypeId FcnGetDataTypeIdFromName("size_t"); IsPtr 0; IsCplx 0; IsConst 0 }
          %assign fcnCall = SLibGenFcnCallInfo( FcnRec, 0)
          %if !ISEMPTY(fcnCall)
            %return fcnCall
          %endif
        %endif
      %endif
      %createrecord FcnRec { Name fcnName; RetTypeId FcnGetDataTypeIdFromName("void"); IsPtr 1; IsCplx 0; IsConst 0; NumArgs 3 }
      %addtorecord FcnRec ArgList { Expr input0Arg; TypeId FcnGetDataTypeIdFromName("void"); IsPtr 1; IsCplx 0; IsConst 0 }
      %addtorecord FcnRec ArgList { Expr input1Arg; TypeId FcnGetDataTypeIdFromName("integer"); IsPtr 0; IsCplx 0; IsConst 0 }
      %addtorecord FcnRec ArgList { Expr input2Arg; TypeId FcnGetDataTypeIdFromName("size_t"); IsPtr 0; IsCplx 0; IsConst 0 }
      %break
    %case "memcmp"  
      %createrecord FcnRec { Name fcnName; RetTypeId FcnGetDataTypeIdFromName("integer"); IsPtr 0; IsCplx 0; IsConst 0; NumArgs 3 }
      %addtorecord FcnRec ArgList { Expr input0Arg; TypeId FcnGetDataTypeIdFromName("void"); IsPtr 1; IsCplx 0; IsConst 1 }
      %addtorecord FcnRec ArgList { Expr input1Arg; TypeId FcnGetDataTypeIdFromName("void"); IsPtr 1; IsCplx 0; IsConst 1 }
      %addtorecord FcnRec ArgList { Expr input2Arg; TypeId FcnGetDataTypeIdFromName("size_t"); IsPtr 0; IsCplx 0; IsConst 0 }
      %break
   %default
      %exit "MATHLIB: Unsupported function %<fcnName>."
  %endswitch
  %return SLibGenFcnCallInfo( FcnRec, 0)
%endfunction

%% Function: LibGenUnusedParamFcnCall =================================================
%% Abstract:
%%    Return a complete callsite expression the unused parameter macro.
%%
%%       o) fcnName    - Name of the unused parameter macro
%%       o) input0Arg  - string expression of param
%%
%%
%function LibGenUnusedParamFcnCall(fcnName, input0Arg) void
  %assign fcnInfo = SLibGenUnusedParamFcnCall(fcnName, input0Arg)
  %if ISEMPTY(fcnInfo)
    %return ""
  %else
    %return fcnInfo.Expr
  %endif
%endfunction

%function SLibGenUnusedParamFcnCall(fcnName, input0Arg) void
  %switch fcnName
    %case "RT_UNUSED_PARAMETER"
      %createrecord FcnRec { Name fcnName; RetTypeId FcnGetDataTypeIdFromName("void"); IsPtr 0; IsCplx 0; IsConst 0; NumArgs 1 }
      %addtorecord FcnRec ArgList { Expr input0Arg; TypeId FcnGetDataTypeIdFromName("void"); IsPtr 0; IsCplx 0; IsConst 0 }
      %break
   %default
      %exit "MATHLIB: Unsupported function %<fcnName>."
  %endswitch
  %return SLibGenFcnCallInfo( FcnRec, 0)
%endfunction

%% Function: LibGenStringFcnCall2Args =================================================
%% Abstract:
%%    Return a complete callsite expression for a strxxx() function with 2
%%    arguments of string.h
%%
%%       o) fcnName    - Name of the memxxx() function
%%       o) input0Arg  - string expression of input arg 0
%%       o) input1Arg  - string expression of input arg 1
%%
%%
%function LibGenStringFcnCall2Args(fcnName, input0Arg, input1Arg) void
  %assign fcnRec = LibCreateHomogMathFcnRec(fcnName, tSS_POINTER)
  %assign fcnRec = LibSetMathFcnRecArgExpr(fcnRec, 0, input0Arg)
  %assign fcnRec = LibSetMathFcnRecArgExpr(fcnRec, 1, input1Arg)
  %return SLibGenRTLibFcnCall(fcnRec)
%endfunction


%% Function: LibGenZCFcnCall =================================================
%% Abstract:
%%    Return a complete callsite expression for a rt_ZCFcn() function
%%
%%       o) dataTypeId - Data Type Id of input signal
%%       o) input0Arg  - string expression of input arg 0
%%       o) input1Arg  - string expression of input arg 1
%%       o) input2Arg  - string expression of input arg 2
%%
%%
%function LibGenZCFcnCall(dataTypeId, input0Arg, input1Arg, input2Arg) void
  %assign fcnRec = LibCreateHomogFcnRec("rt_zcFcn", dataTypeId)
  %assign fcnRec = LibSetMathFcnRecArgExpr(fcnRec, 0, input0Arg)
  %assign fcnRec = LibSetMathFcnRecArgExpr(fcnRec, 1, input1Arg)
  %assign fcnRec = LibSetMathFcnRecArgExpr(fcnRec, 2, input2Arg)
  %return SLibGenRTLibFcnCallForDataTypeId(fcnRec, dataTypeId)
%endfunction


%% Function: LibGenMathFcnCall ==================================================
%% Abstract:
%%    Return a complete callsite expression for a math function in the
%%    target environment given the following function prototype info:
%%
%%       o) RTWFcnName - Generic function name
%%       o) RTWFcnType - type needed for function I/O (e.g., tSS_DOUBLE)
%%       o) input1Arg  - string expression of input arg 1 of type RTWFcnType
%%       o) input2Arg  - if needed, addition input of type RTWFcnType
%%
%%    If no specification is found that exactly matches the
%%    given prototype, this function returns the output name 
%%    along with the casts needed at each position (input, output).
%%
%%    If use of a function requires a #include of a file besides math.h
%%    then the use of this function triggers the generation of the
%%    include file associated with this function.  See LibAddToModelHeaders
%%    to see how this mechanism works.
%%
%%
%function LibGenMathFcnCall(RTWFcnName, RTWFcnTypeId, input1Arg, input2Arg) void

  %if input2Arg != ""
    %return LibGenTwoInputFcnCall(RTWFcnName, RTWFcnTypeId, input1Arg, input2Arg)
  %else
    %return LibGenOneInputFcnCall(RTWFcnName, RTWFcnTypeId, input1Arg)
  %endif        
  
%endfunction %% LibGenMathFcnCall

%% Function: SLibGenPowFcnCall ===================
%% Abstract:
%%    Return a complete callsite expression for a math function in the
%%    target environment given the following function prototype info:
%%
%%       o) RTWFcnName - Generic function name
%%       o) RTWFcnType - type needed for function I/O (e.g., tSS_DOUBLE)
%%       o) input1Arg  - string expression of input arg 1 of type RTWFcnType
%%       o) input2Arg  - if needed, addition input of type RTWFcnType
%%
%%    If no specification is found that exactly matches the
%%    given prototype, this function returns the output name 
%%    along with the casts needed at each position (input, output).
%%
%function SLibGenPowFcnCall(RTWFcnName, RTWFcnTypeId, input1Arg, input2Arg) void

  %createrecord FcnRec { Name RTWFcnName; RetTypeId RTWFcnTypeId; NumArgs 2 }
  %addtorecord FcnRec ArgList { Expr input1Arg; TypeId RTWFcnTypeId; IsPtr 0; IsCplx 0; IsConst 0 }
  %addtorecord FcnRec ArgList { Expr input2Arg; TypeId RTWFcnTypeId; IsPtr 0; IsCplx 0; IsConst 0 }

  %assign fcnInfo = SLibGenFcnCallInfoWithCheck(FcnRec, 0, TLC_FALSE, TLC_FALSE)
  %if ISEMPTY(fcnInfo)
    %if GenCPP
      %<LibAddToCommonIncludes("<cmath>")>
      %assign fcnName = "std::pow"
    %else
      %<LibAddToCommonIncludes("<math.h>")>
      %assign fcnName = "pow"
    %endif
    %return fcnName + "(" + input1Arg + ", " + input2Arg + ")"
  %endif
  %return fcnInfo.Expr
%endfunction %% LibGenTwoInputFcnCall
  

%% Function: LibGenSharedMathFcnCall ================================================
%function LibGenSharedMathFcnCall(RTWFcnName, RTWFcnTypeId, input1Arg, input2Arg) void

  %% under backwards compatiability mode, it's identical to LibGenMathFcnCall.
  %% under shared mode, it will also record include file requirements into stack.
  %if RTWFcnName == "ldexp"
    %return LibGenNonHomogenousTwoInputFcnCall(RTWFcnName, tSS_DOUBLE, ...
      tSS_DOUBLE, input1Arg, ...
      tSS_INTEGER, input2Arg, 1)
  %else
    %createrecord FcnRec { Name RTWFcnName; RetTypeId RTWFcnTypeId; NumArgs 1 }
    %addtorecord FcnRec ArgList { Expr input1Arg; TypeId RTWFcnTypeId; IsPtr 0; IsCplx 0; IsConst 0 }
    
    %if input2Arg != ""
      %assign FcnRec.NumArgs = 2
      %addtorecord FcnRec ArgList { Expr input2Arg; TypeId RTWFcnTypeId; IsPtr 0; IsCplx 0; IsConst 0 }
    %endif

    %return LibGenFcnCall( FcnRec, 1)
  %endif
%endfunction %% LibGenSharedMathFcnCall



%% Function: LibAddTflHeadersToCommonIncludes ==================================
%function LibAddTflHeadersToCommonIncludes() void

  %% Test that we can call the UDD based math function attached to the model
  %assign Headers = FEVAL("rtwgettargetfcnlibheaders", LibGetModelName())
  %assign ShrdHeaders = FEVAL("rtwgettargetfcnlibsharedheaders", ...
    LibGetModelName())
  %if ISEMPTY(Headers) && ISEMPTY(ShrdHeaders)
    %return ""
  %endif

  %if !ISEMPTY(Headers) 
    %foreach idx = SIZE(Headers,1)
      %assign incFileName = FEVAL("regexprep", Headers[idx], "\"", "")
      %<LibAddToCommonIncludes(incFileName)>
    %endforeach
    %<SLibCheckComplexSupportRequired(Headers)>
  %endif

  %if !ISEMPTY(ShrdHeaders)
    %foreach idx = SIZE(ShrdHeaders,1)
      %assign incFileName = FEVAL("regexprep", ShrdHeaders[idx], "\"", "")
      %<LibAddToCommonIncludes(incFileName)>
    %endforeach
    %<SLibCheckComplexSupportRequired(ShrdHeaders)>
  %endif

%endfunction %% LibGetTflHeaders


%% Function: LibAddTflHeadersToSharedIncludes ===================================
%function LibAddTflHeadersToSharedIncludes() void
  %% Test that we can call the UDD based math function attached to the model
  %assign Headers = FEVAL("rtwgettargetfcnlibsharedheaders", LibGetModelName())

  %if ISEMPTY(Headers)
    %return ""
  %else
    %foreach idx = SIZE(Headers,1)
          %assign incFileName = FEVAL("regexprep", Headers[idx], "\"", "")
          %<SLibAddtoTFLSharedUtilsIncludes(incFileName)>
      %endforeach
      %<SLibCheckComplexSupportRequired(Headers)>
  %endif
%endfunction %% LibGetTflSharedHeaders

%% Function: SLibCheckComplexSupportRequired ====================================
%function SLibCheckComplexSupportRequired(Headers) void
  %if !ISEMPTY(Headers)
    %assign nHeaders = SIZE(Headers,1)
    %foreach idx = nHeaders
      %if (Headers[idx] == "blascompat32.h")   
        %if (SupportComplex == 0)                                
          %assign msg = "Use of blascompat32.h requires complex numbers to be supported. Please enable complex support."
          %<LibReportFatalError(msg)>
        %endif
      %endif                                                                             
    %endforeach                                                                               
  %endif
%endfunction %%SLibCheckComplexSupportRequired
  
%% Function: LibGenOneInputFcnCall ===================
%% Abstract:
%%    Return a complete callsite expression for a math function in the
%%    target environment given the following function prototype info:
%%
%%       o) RTWFcnName - Generic function name
%%       o) RTWFcnType - type needed for function I/O (e.g., tSS_DOUBLE)
%%       o) inputArg   - string expression of input arg of type RTWFcnType
%%
%%    If no specification is found that exactly matches the
%%    given prototype, this function returns the output name 
%%    along with the casts needed at each position (input, output).
%%
%function LibGenOneInputFcnCall(RTWFcnName, RTWFcnTypeId, inputArg) void

  %createrecord FcnRec { Name RTWFcnName; RetTypeId RTWFcnTypeId; NumArgs 1 }
  %addtorecord FcnRec ArgList { Expr inputArg; TypeId RTWFcnTypeId; IsPtr 0; IsCplx 0; IsConst 0 }
  
  %return LibGenFcnCall( FcnRec, 0)
%endfunction %% LibGenOneInputFcnCall
  
%% Function: LibGenTwoInputFcnCallInfo ===================
%% Abstract:
%%    Return a complete callsite expression for a math function 
%%    (along with the headerfile required to be included) in the
%%    target environment given the following function prototype info:
%%
%%       o) RTWFcnName - Generic function name
%%       o) RTWFcnType - type needed for function I/O (e.g., tSS_DOUBLE)
%%       o) input1Arg  - string expression of input arg 1 of type RTWFcnType
%%       o) input2Arg  - if needed, addition input of type RTWFcnType
%%
%%    If no specification is found that exactly matches the
%%    given prototype, this function returns the output name 
%%    along with the casts needed at each position (input, output).
%%
%function LibGenTwoInputFcnCallInfo(RTWFcnName, RTWFcnTypeId, input1Arg, input2Arg) void

  %createrecord FcnRec { Name RTWFcnName; RetTypeId RTWFcnTypeId; NumArgs 2 }
  %addtorecord FcnRec ArgList { Expr input1Arg; TypeId RTWFcnTypeId; IsPtr 0; IsCplx 0; IsConst 0 }
  %addtorecord FcnRec ArgList { Expr input2Arg; TypeId RTWFcnTypeId; IsPtr 0; IsCplx 0; IsConst 0 }

  %return SLibGenFcnCallInfo( FcnRec, 0)
%endfunction %% LibGenTwoInputFcnCallInfo
  
%% Function: LibGenTwoInputFcnCall ===================
%% Abstract:
%%    Return a complete callsite expression for a math function in the
%%    target environment given the following function prototype info:
%%
%%       o) RTWFcnName - Generic function name
%%       o) RTWFcnType - type needed for function I/O (e.g., tSS_DOUBLE)
%%       o) input1Arg  - string expression of input arg 1 of type RTWFcnType
%%       o) input2Arg  - if needed, addition input of type RTWFcnType
%%
%%    If no specification is found that exactly matches the
%%    given prototype, this function returns the output name 
%%    along with the casts needed at each position (input, output).
%%
%function LibGenTwoInputFcnCall(RTWFcnName, RTWFcnTypeId, input1Arg, input2Arg) void

  %assign fcnInfo = LibGenTwoInputFcnCallInfo(RTWFcnName, RTWFcnTypeId, input1Arg, input2Arg)
  %if ISEMPTY(fcnInfo)
    %return ""
  %endif
  %return fcnInfo.Expr
%endfunction %% LibGenTwoInputFcnCall
  
%% Function: LibGenNonHomogenousTwoInputFcnCall ===================
%% Abstract:
%%    Return a complete callsite expression for a math function in the
%%    target environment given the following function prototype info:
%%
%%       o) RTWFcnName - Generic function name
%%       o) RTWFcnTypeIdOut - type needed for function Output (e.g., tSS_DOUBLE)
%%       o) RTWFcnTypeId1 - type needed for function arg1 type (e.g., tSS_DOUBLE)
%%       o) input1Arg  - string expression of input arg 1 of type RTWFcnType
%%       o) RTWFcnTypeId2 - type needed for function arg 2 type (e.g., tSS_DOUBLE)
%%       o) input2Arg  - if needed, addition input of type RTWFcnType
%%       o) isShared - 1=Function destination is the shared directory
%%                     0=Function destination is model.c
%%
%%    If no specification is found that exactly matches the
%%    given prototype, this function returns the output name 
%%    along with the casts needed at each position (input, output).
%%
%function LibGenNonHomogenousTwoInputFcnCall(RTWFcnName, RTWFcnTypeIdOut, RTWFcnTypeId1, input1Arg, RTWFcnTypeId2, input2Arg, isShared) void
  %assign fcnInfo = SLibGenNonHomogenousTwoInputFcnCallInfo(RTWFcnName, RTWFcnTypeIdOut, RTWFcnTypeId1, input1Arg, RTWFcnTypeId2, input2Arg, isShared)
  %if ISEMPTY(fcnInfo)
    %return ""
  %endif
  %return fcnInfo.Expr
%endfunction %% LibGenTwoInputFcnCall
  
%% Function: SLibGenNonHomogenousTwoInputFcnCallInfo ===================
%% Abstract:
%%    Return a complete callsite expression and header file for a math function in the
%%    target environment given the following function prototype info:
%%
%%       o) RTWFcnName - Generic function name
%%       o) RTWFcnTypeIdOut - type needed for function Output (e.g., tSS_DOUBLE)
%%       o) RTWFcnTypeId1 - type needed for function arg1 type (e.g., tSS_DOUBLE)
%%       o) input1Arg  - string expression of input arg 1 of type RTWFcnType
%%       o) RTWFcnTypeId2 - type needed for function arg 2 type (e.g., tSS_DOUBLE)
%%       o) input2Arg  - if needed, addition input of type RTWFcnType
%%       o) isShared - 1=Function destination is the shared directory
%%                     0=Function destination is model.c
%%
%%    If no specification is found that exactly matches the
%%    given prototype, this function returns the output name 
%%    along with the casts needed at each position (input, output).
%%
%function SLibGenNonHomogenousTwoInputFcnCallInfo(RTWFcnName, RTWFcnTypeIdOut, RTWFcnTypeId1, input1Arg, RTWFcnTypeId2, input2Arg, isShared) void

  %createrecord FcnRec { Name RTWFcnName; RetTypeId RTWFcnTypeIdOut; NumArgs 2 }
  %addtorecord FcnRec ArgList { Expr input1Arg; TypeId RTWFcnTypeId1; IsPtr 0; IsCplx 0; IsConst 0 }
  %addtorecord FcnRec ArgList { Expr input2Arg; TypeId RTWFcnTypeId2; IsPtr 0; IsCplx 0; IsConst 0 }

  %return SLibGenFcnCallInfo( FcnRec, isShared)
%endfunction %% SLibGenNonHomogenousTwoInputFcnCallInfo
  
%% Function: LibGenOneInputOneOutputFcnCall ==========
%% Abstract:
%%    Return a complete callsite expression for a math function in the
%%    target environment given the following function prototype info:
%%
%%       o) RTWFcnName    - Generic function name
%%       o) RTWFcnTypeIn  - type needed for function input (e.g., tSS_DOUBLE)
%%       o) RTWFcnTypeOut - type needed for function output (e.g., tSS_DOUBLE)
%%       o) inputArg      - string expression of input arg of type RTWFcnTypeIn
%%
%%    If no specification is found that exactly matches the
%%    given prototype, this function returns the output name 
%%    along with the casts needed at each position (input, output).
%%
%function LibGenOneInputOneOutputFcnCall(RTWFcnName, RTWFcnTypeIdIn, RTWFcnTypeIdOut, inputArg) void
  %assign fcnInfo = SLibGenOneInputOneOutputFcnCallInfo(RTWFcnName, RTWFcnTypeIdIn, RTWFcnTypeIdOut, inputArg)
  %if ISEMPTY(fcnInfo)
    %return ""
  %endif
  %return fcnInfo.Expr
%endfunction %% LibGenOneInputOneOutputFcnCall
  
%% Function: SLibGenOneInputOneOutputFcnCallInfo ==========
%% Abstract:
%%    Return a complete callsite expression for a math function in the
%%    target environment given the following function prototype info:
%%
%%       o) RTWFcnName    - Generic function name
%%       o) RTWFcnTypeIn  - type needed for function input (e.g., tSS_DOUBLE)
%%       o) RTWFcnTypeOut - type needed for function output (e.g., tSS_DOUBLE)
%%       o) inputArg      - string expression of input arg of type RTWFcnTypeIn
%%
%%    If no specification is found that exactly matches the
%%    given prototype, this function returns the output name 
%%    along with the casts needed at each position (input, output).
%%
%function SLibGenOneInputOneOutputFcnCallInfo(RTWFcnName, RTWFcnTypeIdIn, RTWFcnTypeIdOut, inputArg) void

  %createrecord FcnRec { Name RTWFcnName; RetTypeId RTWFcnTypeIdOut; NumArgs 1}

  %if (RTWFcnTypeIdIn == tSS_POINTER)
    %assign IsPtr = 1
  %else
    %assign IsPtr = 0
  %endif

  %addtorecord FcnRec ArgList { Expr inputArg; TypeId RTWFcnTypeIdIn; IsPtr %<IsPtr>; IsCplx 0; IsConst 0 }
  
  %return SLibGenFcnCallInfo(FcnRec, 0)
%endfunction %% SLibGenOneInputOneOutputFcnCallInfo
 
 
%% Function: FcnGenerateFcnCallInfo ==============================
%% Abstract:
%%  Helper function to generate the function call expression. 
%function FcnGenerateFcnCallInfo( FcnRec, sharedLib, FcnRecForTfl, FcnInfo, ...
                                   isRetVoid, RetTypeId, RetTypeIsPtr) void 
 
  %assign FcnName   = FcnInfo.FcnName
  %assign FcnType   = FcnInfo.FcnType
  %assign RetIsPtr  = FcnInfo.IsPtr
  %assign HdrFile   = FcnInfo.HdrFile
  %assign NumInputs = FcnInfo.NumInputs
  %assign Args      = FcnInfo.Args

  %if FcnInfo.NumDWorkArgs > 1
    %% START_ASSERT
    %assign msg = "TLC cannot handle more than one DWork argument at this time."...
      "Please rework the TFL entry for (%<FcnName>.)"
    %<LibReportFatalError(msg)>
    %% END_ASSERT
  %endif
  
  
  %if isRetVoid == TLC_TRUE
    %assign FcnTypeId = FcnGetDataTypeIdFromName(FcnType)
    %% Type cast the return value if needed
    %assign outExpr = SLibGenCastExpr(FcnTypeId, RetIsPtr, RetTypeId, RetTypeIsPtr)
    %assign outExpr = outExpr + FcnName + "("
  %else
    %assign outExpr = FcnName + "("
  %endif
  %% Generate the callsite arg list

  %if NumInputs == 1
    %if Args.Name != "u1" && Args.Name != "d1"
      %% START_ASSERT
      %assign msg = "TLC cannot handle injected constants at this time."...
        "Please rework the TFL entry for (%<FcnName>, %<FcnRecForTfl.ArgList.TypeId>)."...
        "Hint: arg name %<Args.Name> may be problematic."
      %<LibReportFatalError(msg)>
      %% END_ASSERT
    %endif

    %% Type cast the input arg if needed
    %assign ArgTypeId = FcnGetDataTypeIdFromName(Args.Type)
    %if Args.Name == "u1"
      %assign castExpr = SLibGenCastExpr(FcnRec.ArgList.TypeId, FcnRec.ArgList.IsPtr, ArgTypeId, Args.IsPtr)
      %assign outExpr = "%<outExpr>%<castExpr>%<FcnRec.ArgList.Expr>"
    %elseif Args.Name == "d1"
      %assign castExpr = SLibGenCastExprDoublePtr(FcnRec.DWorkArgList.TypeId, ...
        FcnRec.DWorkArgList.IsPtr, FcnRec.DWorkArgList.IsDoublePtr, ...
        ArgTypeId, Args.IsPtr, Args.IsDoublePtr)
      %if Args.IsDoublePtr == 1 && FcnRec.DWorkArgList.IsPtr == 1 && FcnRec.DWorkArgList.IsDoublePtr == 0
        %assign dwork = "&%<FcnRec.DWorkArgList.Expr>"
      %else
        %assign dwork = "%<FcnRec.DWorkArgList.Expr>"
      %endif
      %assign outExpr = "%<outExpr>%<castExpr>%<dwork>"
    %endif
  %else
    %% Check for output remapping. Error out if remapping occurred.
    %foreach k = NumInputs
      %if "y1" == Args[k].Name
        %% START_ASSERT
        %assign msg = "TLC cannot handle mapping function ouput as input argument at this time."...
          "Please rework the TFL entry for (%<FcnName>, %<Args[k].Type>)."...
          "Hint: arg name %<Args[k].Name> must be a returned from function %<FcnName>."
        %<LibReportFatalError(msg)>
        %% END_ASSERT
      %endif
    %endforeach

    %foreach k = NumInputs
      %if k > 0
        %if !FEVAL("rem",k,2)
          %assign comma = ",\n"
        %else
          %assign comma = ", "
        %endif
      %else
        %assign comma = ""
      %endif

      %% Determine if the argument is in the correct order
      %% Args[] - array of prototype arguments
      %% FcnRec.Args[] - array of "conceptual args"
      %% Assumes the "conceptual arg" names are in order, u1, ..., un
      %% Does not handle the case of multiple args with the same name
      %assign found = 0
      %assign dworkfound = 0
        %% Find the correct index (argument reordering)
        %% Here's a truth table for the simple two arg reordering case
        %% foo( single u1, single u2 ) -> foo( single u2, double u1 )
        %%
        %% k  m  argName  Args[k].Name Args[k].Type index FcnRec.Args[index].Type
        %% =  =  ======   ============ ============ ===== =======================
        %% 0  0     -            -            -       -         -
        %% 0  1    u2           u2         single     1        single
        %% 1  0    u1           u1         double     0        single <- cast input
        %% 1  1     -            -            -       -         -
        %foreach m = FcnRec.NumArgs
            %assign argName = "u%<m+1>"
            %if argName == Args[k].Name
              %assign index = m
              %assign found = 1
              %break
            %endif
        %endforeach
        
        %if found == 0
          %foreach m = FcnRec.NumDWorkArgs
            %assign argName = "d%<m+1>"
            %if argName == Args[k].Name
              %assign index = m
              %assign dworkfound = 1
              %break
            %endif
          %endforeach
        %endif

      %if found == 1
        %% Type cast the input arg if needed
        %if Args[k].IsPtr==1
          %assign ArgTypeId = tSS_POINTER
        %else
          %assign ArgTypePlain = SLibStripQualifiers(Args[k].Type)
          %assign ArgTypeId = FcnGetDataTypeIdFromName(ArgTypePlain)
        %endif
        %if FcnRec.NumArgs == 1
          %assign castExpr = SLibGenCastExpr(FcnRec.ArgList.TypeId, FcnRec.ArgList.IsPtr, ArgTypeId, Args[k].IsPtr)
          %assign outExpr = "%<outExpr>%<comma>%<castExpr>%<FcnRec.ArgList.Expr>"
        %else
          %assign castExpr = SLibGenCastExpr(FcnRec.ArgList[index].TypeId, FcnRec.ArgList[index].IsPtr, ArgTypeId, Args[k].IsPtr)
          %assign outExpr = "%<outExpr>%<comma>%<castExpr>%<FcnRec.ArgList[index].Expr>"
        %endif
      %elseif dworkfound == 1
        %assign ArgTypeId = FcnGetDataTypeIdFromName(Args[k].Type)
        %if FcnRec.NumDWorkArgs == 1
          %assign castExpr = SLibGenCastExprDoublePtr(FcnRec.DWorkArgList.TypeId, ...
            FcnRec.DWorkArgList.IsPtr, FcnRec.DWorkArgList.IsDoublePtr, ...
            ArgTypeId, Args[k].IsPtr, Args[k].IsDoublePtr)
          %if Args[k].IsDoublePtr == 1 && FcnRec.DWorkArgList.IsPtr == 1 && FcnRec.DWorkArgList.IsDoublePtr == 0
            %assign dwork = "&%<FcnRec.DWorkArgList.Expr>"
          %else
            %assign dwork = "%<FcnRec.DWorkArgList.Expr>"
          %endif
        %else
          %assign castExpr = SLibGenCastExprDoublePtr(FcnRec.DWorkArgList.TypeId, ...
            FcnRec.DWorkArgList[index].IsPtr, FcnRec.DWorkArgList[index].IsDoublePtr, ...
            ArgTypeId, Args[k].IsPtr, Args[k].IsDoublePtr)
          %if Args[k].IsDoublePtr == 1 && FcnRec.DWorkArgList[index].IsPtr == 1 && FcnRec.DWorkArgList[index].IsDoublePtr == 0
            %assign dwork = "&%<FcnRec.DWorkArgList[index].Expr>"
          %else
            %assign dwork = "%<FcnRec.DWorkArgList[index].Expr>"
          %endif
        %endif
        %assign outExpr = "%<outExpr>%<comma>%<castExpr>%<dwork>"        
      %else
        %assign outExpr = "%<outExpr>%<comma>%<FcnInfo.Args[k].Expr>"
      %endif
      
    %endforeach
  %endif

  %% Don't add header file to shared includes until all error checking is complete
  %if (sharedLib == 1) && ISFIELD(::CompiledModel,"GenUtilsSrcInSharedLocation") && (::CompiledModel.GenUtilsSrcInSharedLocation == 1)
    %<LibAddtoSharedUtilsIncludes(HdrFile)>
  %endif

  %assign callExpr = "%<outExpr>)"

  %% Need to clean up header file string
  %if ISEMPTY(FEVAL("strfind",HdrFile,"<")) && ...
      ISEMPTY(FEVAL("strfind",HdrFile,"\""))
      %assign HdrFile = "\"" + HdrFile + "\""
  %endif
  %createrecord FunctionInfo { Expr callExpr; HeaderFile HdrFile  }

  %return FunctionInfo
 %endfunction %% FcnGenerateFcnCallInfo
 

 %% Function: FcnGenExprFromIR ===============================================
 %% Abstract:
 %%  The function creates the record of the given function and 
 %%  calls "rtwcgtlc" MEX function. The MEX function in turn 
 %%  calls into CGIR and gets either the inlined expression or 
 %%  the function call expression for the given function. 
 %%
 %function FcnGenExprFromIR( FcnRec, FcnInfo) void
    %assign RetType = FcnGetMathDataTypeNameFromId(FcnRec.RetTypeId)

   %if ISFIELD(FcnRec, "RetExpr")
    %assign RetExpr = "%<FcnRec.RetExpr>"
   %else
     %assign RetExpr = "yout"
   %endif
 
   %createrecord RecForTfl {RetTypeId RetType; RetName RetExpr; Key FcnRec.Name; ...
                             NumArgs FcnRec.NumArgs; InlineFcn FcnInfo.InlineFcn}
   
   %if FcnRec.NumArgs == 1
       %assign InputType = FcnGetMathDataTypeNameFromId(FcnRec.ArgList.TypeId)
       %addtorecord RecForTfl ArgList { TypeId InputType; Name FcnRec.ArgList.Expr }
   %else   
    %foreach k = FcnRec.NumArgs
       %assign InputType = FcnGetMathDataTypeNameFromId(FcnRec.ArgList[k].TypeId)
       %addtorecord RecForTfl ArgList { TypeId InputType; Name FcnRec.ArgList[k].Expr }
    %endforeach
   %endif
   %if !SLibIsValidCoderContext()
     %error "This math libary function is not available if the TLC command is invoked offline"
   %endif
   %assign rtwCtx = ::CompiledModel.RTWContext
   %assign vec = FEVAL("rtwprivate", "rtwcustomtfl", rtwCtx, RecForTfl)   
   %return vec
 %endfunction %% FcnGenExprFromIR
 
 
%% Function: LibGenFcnCall ==============================
%% Abstract:
%%  Generate an expression to perform the requested generic run-time function
%%  consuming the required arguments contained in the FcnRec record's ArgList.
%%  This API does NOT support function inlining and returns a function expr (call)
%%  even if the corresponding TflCustom entry exists for the given function and 
%%  has InlineFcn parameter set to true. This API is kept for legacy support.
%%  The resulting string is not an lvalue.  If the requested generic function 
%%  is not supported, the empty string "" is returned.
%%
%%  If output type does not match generic output type, an output cast is added.
%%  If an input arg type does not match the generic input type, a cast is
%%  added to the input argument.
%%
%%  FcnRec record definition:
%%    Name      - generic function name
%%    RetTypeId - generic function return type (tSS_DOUBLE, etc.)
%%    NumArgs   - length of ArgList
%%    ArgList   - record array containing these fields:
%%                Expr    - Expression for argument instance (string)
%%                TypeId  - datatype ID of argument instance
%%                IsPtr   - arg is a pointer
%%                IsCplx  - arg is complex
%%                IsConst - arg is const (read-only)
%%
%function LibGenFcnCall(FcnRec, sharedLib) void
  %assign fcnInfo = SLibGenFcnCallInfo(FcnRec, sharedLib)
  %if ISEMPTY(fcnInfo)
    %return ""
  %endif
  %return fcnInfo.Expr
%endfunction %% LibGenFcnCall

%% Function: SLibGenFcnCallInfo ==============================
%% Abstract:
%%  Generate an expression to perform the requested generic run-time function
%%  consuming the required arguments contained in the FcnRec record's ArgList.
%%  This API does NOT support function inlining and returns a function expr (call)
%%  even if the corresponding TflCustom entry exists for the given function and 
%%  has InlineFcn parameter set to true. This API is kept for legacy support.
%%  The expression is packed into a record along with the required header file.
%%  The resulting string is not an lvalue.  If the requested generic function 
%%  is not supported, the empty string "" is returned.
%%
%%  If output type does not match generic output type, an output cast is added.
%%  If an input arg type does not match the generic input type, a cast is
%%  added to the input argument.
%%
%%  FcnRec record definition:
%%    Name      - generic function name
%%    RetTypeId - generic function return type (tSS_DOUBLE, etc.)
%%    NumArgs   - length of ArgList
%%    ArgList   - record array containing these fields:
%%                Expr    - Expression for argument instance (string)
%%                TypeId  - datatype ID of argument instance
%%                IsPtr   - arg is a pointer
%%                IsCplx  - arg is complex
%%                IsConst - arg is const (read-only)
%%
%function SLibGenFcnCallInfo(FcnRec, sharedLib) void
  %assign fcnInfo =SLibGenFcnCallInfoWithCheck(FcnRec, sharedLib, TLC_TRUE, TLC_FALSE)
  %if ISEMPTY(fcnInfo)
    %return ""
  %endif
  %return fcnInfo
%endfunction %% SLibGenFcnCallInfo

%% Function: SLibGenFcnCallInfoWithCheck ==============================
%% Abstract:
%%  Generate an expression to perform the requested generic run-time function
%%  consuming the required arguments contained in the FcnRec record's ArgList.
%%  This API does NOT support function inlining and returns a function expr (call)
%%  even if the corresponding TflCustom entry exists for the given function and 
%%  has InlineFcn parameter set to true. This API is kept for legacy support.
%%  The expression is packed into a record along with the required header file.
%%  The resulting string is not an lvalue.  If the requested generic function 
%%  is not supported, the empty string "" is returned.
%%
%%  If output type does not match generic output type, an output cast is added.
%%  If an input arg type does not match the generic input type, a cast is
%%  added to the input argument.
%%
%%  FcnRec record definition:
%%    Name      - generic function name
%%    RetTypeId - generic function return type (tSS_DOUBLE, etc.)
%%    NumArgs   - length of ArgList
%%    ArgList   - record array containing these fields:
%%                Expr    - Expression for argument instance (string)
%%                TypeId  - datatype ID of argument instance
%%                IsPtr   - arg is a pointer
%%                IsCplx  - arg is complex
%%                IsConst - arg is const (read-only)
%%
%function SLibGenFcnCallInfoWithCheck(FcnRec, sharedLib, allowCustomization, nameOnly) void
  
  %copyrecord FcnRecForTfl FcnRec

  %assign isRetVoid = ISFIELD(FcnRec, "RetTypeId")
  %% Convert the TypeIDs into strings

  %assign RetTypeIsPtr = []
  %assign RetTypeId = []

  %if isRetVoid == TLC_TRUE 
    %assign RetTypeId = FcnRec.RetTypeId
    %assign RetTypeIsPtr = 0
        %if ISFIELD(FcnRec, "IsPtr")
      %if FcnRec.IsPtr == 1
        %assign RetTypeIsPtr = 1
      %endif
    %endif
    %assign FcnRecForTfl.RetTypeId = FcnGetMathDataTypeNameFromId(RetTypeId)
  %endif
  %assign ArgIds = []
  %if FcnRec.NumArgs == 1
    %assign argType = FcnGetMathDataTypeNameFromId(FcnRec.ArgList.TypeId)
    %assign FcnRecForTfl.ArgList.TypeId = argType
  %else
    %foreach k = FcnRec.NumArgs
      %assign argType = FcnGetMathDataTypeNameFromId(FcnRec.ArgList[k].TypeId)
      %assign FcnRecForTfl.ArgList[k].TypeId = argType
    %endforeach
  %endif

  %% Test that we can use call the UDD based math function attached to the model
  %assign FcnInfo = FEVAL("rtw_tfl_query", LibGetModelName(),  FcnRecForTfl)
  
  %if ISEMPTY(FcnInfo)
    %return FcnInfo
  %else
    %assign CustomizationEntry = FcnInfo.CustomizationEntry
  %endif

  %if CustomizationEntry == 0 && ISEMPTY(FcnInfo.ImplCallback)
    %if nameOnly == TLC_FALSE
      %assign functionInfo = FcnGenerateFcnCallInfo(FcnRec, sharedLib, FcnRecForTfl, FcnInfo, ...
                                                    isRetVoid, RetTypeId, RetTypeIsPtr)
      %return functionInfo
    %else
      %return FcnInfo
    %endif
  %else 
    %if allowCustomization == TLC_TRUE
      
      %% For legacy support turn Function Inlining OFF
      %assign FcnInfo.InlineFcn = TLC_FALSE
      %assign vec = FcnGenExprFromIR(FcnRec, FcnInfo)
      %assign callExpr = "%<vec[1]>"
      %if nameOnly == TLC_FALSE
        %createrecord FunctionInfo { Expr callExpr; HeaderFile " "}
      %else
        %assign fcn_name = FEVAL("regexprep",callExpr,"\(([^\}]+)\)","")
        %createrecord FunctionInfo { FcnName fcn_name}
      %endif
      %return FunctionInfo
    %else
      %return []
    %endif
  %endif

%endfunction %% SLibGenFcnCallInfo


%% Function: LibGenFcnExpr ==============================
%% Abstract:
%%  Generate an expression to perform the requested generic run-time function
%%  consuming the required arguments contained in the FcnRec record's ArgList. 
%%  This API also supports function inlining and returns function body if a 
%%  corresponding TflCustom entry exists for the given function.  
%%  The resulting string is not an lvalue.  If the requested generic function 
%%  is not supported, the empty string "" is returned.
%%
%%  If output type does not match generic output type, an output cast is added.
%%  If an input arg type does not match the generic input type, a cast is
%%  added to the input argument.
%%
%%  FcnRec record definition:
%%    Name        - generic function name
%%    RetTypeId   - generic function return type (tSS_DOUBLE, etc.)
%%    RetExpr     - Expression for return argument (string)
%%    NumArgs     - length of ArgList
%%    ArgList     - record array containing these fields:
%%                  Expr    - Expression for argument instance (string)
%%                  TypeId  - datatype ID of argument instance
%%                  IsPtr   - arg is a pointer
%%                  IsCplx  - arg is complex
%%                  IsConst - arg is const (read-only)
%%
%function LibGenFcnExpr(FcnRec, sharedLib) void
  %assign fcnInfo = SLibGenFcnExprInfo(FcnRec, sharedLib)
  %if ISEMPTY(fcnInfo)
    %return ""
  %endif
  %return fcnInfo.Expr
%endfunction %% LibGenFcnExpr

%% Function: SLibGenFcnExprInfo ==============================
%% Abstract:
%%  Generate an expression to perform the requested generic run-time function
%%  consuming the required arguments contained in the FcnRec record's ArgList.
%%  This API also supports function inlining and returns function body if a 
%%  corresponding TflCustom entry exists for the given function.  
%%  The expression is packed into a record along with the required header file.
%%  The resulting string is not an lvalue.  If the requested generic function 
%%  is not supported, the empty string "" is returned.
%%
%%  If output type does not match generic output type, an output cast is added.
%%  If an input arg type does not match the generic input type, a cast is
%%  added to the input argument.
%%
%%  FcnRec record definition:
%%    Name      - generic function name
%%    RetTypeId - generic function return type (tSS_DOUBLE, etc.)
%%    RetExpr   - Expression for return argument (string)
%%    NumArgs   - length of ArgList
%%    ArgList   - record array containing these fields:
%%                Expr    - Expression for argument instance (string)
%%                TypeId  - datatype ID of argument instance
%%                IsPtr   - arg is a pointer
%%                IsCplx  - arg is complex
%%                IsConst - arg is const (read-only)
%%
%function SLibGenFcnExprInfo(FcnRec, sharedLib) void
  
  %copyrecord FcnRecForTfl FcnRec

  %assign isRetVoid = ISFIELD(FcnRec, "RetTypeId")
  %% Convert the TypeIDs into strings

  %assign RetTypeId = []
  %assign RetTypeIsPtr = []
  %if isRetVoid == TLC_TRUE 
    %assign RetTypeId = FcnRec.RetTypeId
    %assign RetTypeIsPtr = 0
    %if ISFIELD(FcnRec, "IsPtr")
      %if FcnRec.IsPtr == 1
        %assign RetTypeIsPtr = 1
      %endif
    %endif
    %assign FcnRecForTfl.RetTypeId = FcnGetMathDataTypeNameFromId(RetTypeId)
  %endif
  %assign ArgIds = []
  %if FcnRec.NumArgs == 1
    %assign argType = FcnGetMathDataTypeNameFromId(FcnRec.ArgList.TypeId)
    %assign FcnRecForTfl.ArgList.TypeId = argType
  %else
    %foreach k = FcnRec.NumArgs
      %assign argType = FcnGetMathDataTypeNameFromId(FcnRec.ArgList[k].TypeId)
      %assign FcnRecForTfl.ArgList[k].TypeId = argType
    %endforeach
  %endif

  %% Test that we can use call the UDD based math function attached to the model
  %assign FcnInfo = FEVAL("rtw_tfl_query", LibGetModelName(),  FcnRecForTfl)
   
  %if ISEMPTY(FcnInfo)
    %return FcnInfo
  %else
    %assign CustomizationEntry = FcnInfo.CustomizationEntry
  %endif

  %if CustomizationEntry == 0
    %assign functionInfo = FcnGenerateFcnCallInfo(FcnRec, sharedLib, FcnRecForTfl, FcnInfo, ...
                                                  isRetVoid, RetTypeId, RetTypeIsPtr)
         
    %assign functionInfo.Expr = "%<FcnRec.RetExpr> = %<functionInfo.Expr>;" 
    %return functionInfo												  
  %else 
    %assign vec = FcnGenExprFromIR(FcnRec, FcnInfo)
    %assign callExpr = "%<vec[2]>"
    %createrecord FunctionInfo { Expr callExpr; HeaderFile " "}
    %return FunctionInfo        
  %endif

%endfunction %% SLibGenFcnExprInfo



%% Function: SLibGenCastExpr ==============================================
%%  Abstract: This function generates a cast expression if the two
%%  input arguments are not the same time. If the args are the same
%%  an empty string is returned
%%
%function SLibStripQualifiers(DataTypeStr) void
  %assign plainT = DataTypeStr
  %if !ISEMPTY(FEVAL("strfind",plainT,"const"))
    %assign plainT = FEVAL("strrep",plainT,"const ","")
  %elseif !ISEMPTY(FEVAL("strfind",plainT,"volatile"))
    %assign plainT = FEVAL("strrep",plainT,"volatile ","")
  %endif
  %return plainT
%endfunction
  

%% Function: SLibGenCastExpr ==============================================
%%  Abstract: This function generates a cast expression if the two
%%  input arguments are not the same time. If the args are the same
%%  an empty string is returned
%%
%function SLibGenCastExpr(FromDataType, FromIsPtr, ToDataType, ToIsPtr) void
  %return SLibGenCastExprDoublePtr(FromDataType, FromIsPtr, TLC_FALSE, ToDataType, ToIsPtr, TLC_FALSE)
%endfunction

%% Function: SLibGenCastExprDoublePtr =======================================
%%  Abstract: This function generates a cast expression if the two
%%  input arguments are not the same time. If the args are the same
%%  an empty string is returned
%%
%function SLibGenCastExprDoublePtr(FromDataType, FromIsPtr, FromIsDoublePtr, ToDataType, ToIsPtr, ToIsDoublePtr) void
  %if LibGetDataTypeIdAliasedThruToFromId(FromDataType) != ...
      LibGetDataTypeIdAliasedThruToFromId(ToDataType) || ...
      (FromIsPtr != ToIsPtr && ToIsDoublePtr == TLC_FALSE) || ...
      (FromIsDoublePtr != ToIsDoublePtr)
    %if ((ToDataType == tSS_SIZET) && (tSS_SIZET < 0))
      %assign numBitsStr = "uint" + "%<IntegerSizes.IntNumBits>"
      %if FcnGetMathDataTypeNameFromId(FromDataType) == numBitsStr
        %return ""
      %else
        %assign typeName = "size_t"
      %endif
    %elseif ((ToDataType == tSS_LONG) && (tSS_LONG < 0))
      %assign numBitsStr = "int" + "%<IntegerSizes.LongNumBits>"
      %if FcnGetMathDataTypeNameFromId(FromDataType) == numBitsStr
        %return ""
      %else
        %assign typeName = "long"
      %endif
    %elseif ((ToDataType == tSS_ULONG) && (tSS_ULONG < 0))
      %assign numBitsStr = "uint" + "%<IntegerSizes.LongNumBits>"
      %if FcnGetMathDataTypeNameFromId(FromDataType) == numBitsStr
        %return ""
      %else
        %assign typeName = "unsigned long"
      %endif
    %elseif (ToDataType == tSS_VOID)
      %if (FromDataType != tSS_VOID) 
        %assign typeName = "void"
      %else
        %return ""
      %endif
    %else
      %assign typeName = LibGetDataTypeNameFromId(ToDataType)
    %endif
    %assign ptrExpr = ""
    %if ToIsPtr == 1
      %assign ptrExpr = "*"
    %elseif ToIsDoublePtr == 1
      %if FromIsPtr == 1
        %assign ptrExpr = "*"
      %else
        %assign ptrExpr = "**"
      %endif
    %endif
    %assign castExpr = "(%<typeName>" + ptrExpr + ")"
    %if castExpr == "(pointer_T)" || castExpr == "(pointer_T*)"
      %assign castExpr = ""
    %endif
  %else
    %assign castExpr = ""
  %endif
  %return castExpr
%endfunction %% SLibGenCastExpr
  
%% Function: SLibGetMathFcnNameFromTFL ==================================================
%% Abstract:
%%    Return the implementation name for the given generic math function name
%%
%%       o) RTWFcnName - Generic function name
%%       o) RTWFcnType - type needed for function output (e.g., tSS_DOUBLE)
%%       o) Arg1Type   - type needed for function input (e.g., tSS_DOUBLE)
%%       o) Arg2Type   - if needed, type needed for function input (e.g., tSS_DOUBLE)
%%
%%    If no specification is found that exactly matches the
%%    given prototype, the empty string is returned
%%
%%    If use of a function requires a #include of a file
%%    then the use of this function triggers the generation of the
%%    include file associated with this function.
%%
%%
%function SLibGetMathFcnNameFromTFL(RTWFcnName, RTWFcnTypeId, Arg1Type, Arg2Type) void

  %createrecord FcnRec { Name RTWFcnName; RetTypeId RTWFcnTypeId; NumArgs 1 }
  %addtorecord FcnRec ArgList { Expr ""; TypeId Arg1Type; IsPtr 0; IsCplx 0; IsConst 0 }
    
  %if Arg2Type != ""
    %assign FcnRec.NumArgs = 2
    %addtorecord FcnRec ArgList { Expr ""; TypeId Arg2Type; IsPtr 0; IsCplx 0; IsConst 0 }
  %endif
  
  %assign FcnInfo = SLibGenFcnCallInfoWithCheck(FcnRec, 0, TLC_TRUE, TLC_TRUE)
  
  %if ISEMPTY(FcnInfo)
    %return ""
  %endif
  %return FcnInfo.FcnName
%endfunction %% SLibGetMathFcnNameFromTFL

%% ==========================================================================
%% Run TLC based TargetFcnLib callbacks a second time. This will catch any
%% callbacks that need to be invoked due to TLC TFL queries that happen
%% after the first set of callbacks (specifically initnonfinite)
%function SLibRunTFLCallbacks() void
%assign numcbs = FEVAL("rtwprivate","rtw_get_tfl_cb_info", LibGetModelName(), -1)
%% Allow a maximum of 5 callback recursions
%foreach j = 5
  %if numcbs == 0
    %break
  %endif
  %foreach i = numcbs
    %assign fctInfo = FEVAL("rtwprivate","rtw_get_tfl_cb_info", ...
      LibGetModelName(), i+1)

    %% Only generate if the file has not been generated and does not already exist
    %if ISEMPTY(FEVAL("strfind", ::CalledTflTlcCallbacks, fctInfo.FileName+","))
      %assign ::CalledTflTlcCallbacks = ::CalledTflTlcCallbacks + fctInfo.FileName + ","
      %assign fullPath = FEVAL("fullfile",GenUtilsPath,fctInfo.FileName)
      %assign headerExists = FEVAL("exist","%<fullPath>.h")
      %assign sourceExists = FEVAL("exist","%<fullPath>.%<LangFileExt>")
      %if !(headerExists || sourceExists)
        %assign fileH = SLibGetFileRecForUtilCode("util_hdr", fctInfo.FileName)
        %<LibSetSourceFileOutputDirectory(fileH,GenUtilsPath)>
        %assign fileC = SLibGetFileRecForUtilCode("util_src", fctInfo.FileName)
        %<LibSetSourceFileOutputDirectory(fileC,GenUtilsPath)>      
        %if FILE_EXISTS(fctInfo.genCallback)
          %% Remove '.tlc' from callback name and use as the 'Type' for generatefile.
          %assign type = FEVAL("regexprep","%<fctInfo.genCallback>",".tlc","","ignorecase")
          %generatefile "%<type>" "%<fctInfo.genCallback>"
          %if GENERATE_TYPE_FUNCTION_EXISTS(fctInfo, fctInfo.FcnName, type)
            %% Generate the contents of the header and source files
            %assign result =  GENERATE_TYPE(fctInfo, fctInfo.FcnName, type, fileH, fileC)
          %else
            %assign args = [%<fctInfo.FcnName>, %<fctInfo.genCallback>]
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:FcnNotFoundinTFL", args)>
          %endif
        %else
          %<SLibReportErrorWithIdAndArgs("RTW:tlc:FileNotFoundinTFL", "%<fctInfo.genCallback>")>
        %endif
      %else
        %if headerExists
          %<SLibAddGeneratedFileToList(fctInfo.FileName + ".h", "utility", "header","")>
        %endif
        %if sourceExists
          %<SLibAddGeneratedFileToList(fctInfo.FileName + "." + LangFileExt, "utility", "source","")>
        %endif
        %<SLibRefreshTflHitCache(fctInfo)>
      %endif
    %endif
  %endforeach
  %assign numcbs = FEVAL("rtwprivate","rtw_get_tfl_cb_info",LibGetModelName(),-2)
%endforeach
%endfunction %% SLibRunTFLCallbacks

%% Function SLibRefreshTflHitCache(fctInfo) ========================================
%% Abstract:
%%   When a utility file alreay exists, refresh the TFL cache list for other 
%% utilty files that it depends on.
%% 
%function SLibRefreshTflHitCache(fctInfo) void
  %if !ISEMPTY(fctInfo.genCallback) && fctInfo.genCallback == "genrtnonfinite.tlc" && !EXISTS(CustomNonFinites)
    %assign type = FEVAL("regexprep","%<fctInfo.genCallback>",".tlc","","ignorecase")
    %generatefile "%<type>" "%<fctInfo.genCallback>"
    %if FILE_EXISTS(fctInfo.genCallback) && GENERATE_TYPE_FUNCTION_EXISTS(fctInfo, fctInfo.FcnName, type)
      %assign fileH = SLibGetFileRecForUtilCode("util_hdr", fctInfo.FileName)
      %assign fileC = SLibGetFileRecForUtilCode("util_src", fctInfo.FileName)
      %% refresh the TFL hit cache without generating the real files 
      %assign result =  GENERATE_TYPE(fctInfo, fctInfo.FcnName, type, fileH, fileC)
      %<SLibSetModelFileAttribute(fileH, "Filter", 1)>
      %<SLibSetModelFileAttribute(fileC, "Filter", 1)>
    %else
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:FcnNotFoundinTFL", ...
        ["%<fctInfo.FcnName>", "%<fctInfo.genCallback>"])>
    %endif    
  %endif
%endfunction

%endif %% _MATHLIB_

%% [EOF] mathlib.tlc
